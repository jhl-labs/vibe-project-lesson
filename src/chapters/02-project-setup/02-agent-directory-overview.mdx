import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { FileTree } from '../../components/FileTree';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 2: 프로젝트 설정/프로젝트 지식 구조" />

# 프로젝트 지식 구조

> AI 에이전트가 프로젝트를 이해하기 위한 지식 베이스 설계

## 왜 프로젝트 지식 구조가 필요한가

AI 코딩 에이전트는 대화가 시작될 때 **프로젝트에 대해 아무것도 모릅니다**. 기술 스택, 아키텍처, 코딩 컨벤션, 도메인 용어 — 이 모든 정보를 명시적으로 제공해야 합니다.

프로젝트 지식 구조가 없으면:
- AI가 프로젝트와 다른 코딩 스타일로 코드를 생성
- 아키텍처 레이어를 무시한 의존성 방향 위반
- 프로젝트에 이미 있는 유틸리티를 중복 구현
- 도메인 용어를 잘못 사용하거나 변수명이 불일치

프로젝트 지식 구조가 잘 갖춰지면:
- 첫 프롬프트부터 프로젝트 컨벤션에 맞는 코드 생성
- 기존 패턴을 일관되게 따르는 코드 품질 유지
- 반복적인 컨텍스트 설명 없이 바로 작업 시작 가능

## AI 도구별 공식 설정 경로

각 AI 코딩 도구는 **자체적인 공식 설정 경로**를 가지고 있습니다. 이 경로에 파일을 두어야 해당 도구가 자동으로 인식합니다.

<ComparisonTable
  title="AI 도구별 공식 설정 경로"
  headers={['도구', '프로젝트 설정 파일', '추가 설정']}
  rows={[
    { feature: 'Claude Code', values: ['CLAUDE.md, .claude/CLAUDE.md', '.claude/rules/, .claude/agents/, .claude/skills/'] },
    { feature: 'GitHub Copilot', values: ['.github/copilot-instructions.md', '.github/instructions/*.instructions.md'] },
    { feature: 'Cursor', values: ['.cursor/rules/*.mdc', 'description, globs, alwaysApply 메타데이터'] },
    { feature: 'OpenAI Codex', values: ['AGENTS.md', '프로젝트 루트에 단일 파일'] },
    { feature: 'Windsurf', values: ['.windsurf/rules/*.md (구: .windsurfrules)', '글로벌 규칙 + 워크스페이스 규칙'] },
  ]}
/>

<Callout type="warning" title="공식 경로만 자동 인식됩니다">
  위 표의 경로에 있는 파일만 각 도구가 **자동으로** 읽습니다.
  임의의 디렉토리에 있는 파일은 명시적으로 연결하지 않는 한 어떤 도구도 자동 인식하지 않습니다.
</Callout>

### AI 도구별 설정 경로 심화 비교

단순히 파일 경로만 다른 것이 아닙니다. 각 도구는 **설정 파일의 포맷, 메타데이터, 적용 범위, 참조 메커니즘**까지 고유한 방식을 갖습니다. 이 차이를 정확히 이해해야 프로젝트 지식 구조를 효율적으로 설계할 수 있습니다.

<ComparisonTable
  title="AI 도구별 설정 메커니즘 심화 비교"
  headers={['특성', 'Claude Code', 'Cursor', 'GitHub Copilot', 'Windsurf', 'Roo Code']}
  rows={[
    { feature: '설정 포맷', values: ['Markdown (.md)', 'Markdown + YAML (.mdc)', 'Markdown (.md)', 'Markdown (.md) (구: 단일 텍스트)', 'Markdown (.md) + YAML'] },
    { feature: '메타데이터 지원', values: ['YAML frontmatter (rules)', 'description, globs, alwaysApply', 'applyTo frontmatter (.instructions.md)', 'globs, description 지원', 'YAML frontmatter'] },
    { feature: '범위 지정 (Scoping)', values: ['paths 필드로 glob 패턴', 'globs 필드로 파일 매칭', 'applyTo 필드로 glob 패턴', 'globs 패턴 지원', 'glob 패턴 지원'] },
    { feature: '외부 참조', values: ['@path 구문으로 import', '@file 구문', '직접 참조 불가', '직접 참조 불가', '@file 구문'] },
    { feature: '조건부 로드', values: ['path-scoped로 조건부', 'alwaysApply: false로 조건부', 'applyTo로 조건부', 'globs로 조건부', '조건부 지원'] },
    { feature: '계층 구조', values: ['조직 > 프로젝트 > 사용자 > 로컬', '프로젝트 단위', '조직 > 저장소', '글로벌 + 워크스페이스', '프로젝트 단위'] },
    { feature: '개인 설정 분리', values: ['CLAUDE.local.md', '없음 (수동 .gitignore)', '없음', '없음', '없음 (글로벌 규칙으로 대체)'] },
  ]}
/>

<Callout type="tip" title="Roo Code (구 Roo-Cline)">
  Roo Code는 VS Code 기반 AI 에이전트로, `.roo/rules/` 디렉토리에 규칙을 저장합니다.
  Cursor와 유사한 YAML frontmatter 기반 규칙 시스템을 지원하며, 모드별(Code, Architect, Ask 등) 규칙 분리가 가능합니다.
  Claude Code의 `.claude/rules/`와 구조적으로 유사하여 지식 마이그레이션이 비교적 수월합니다.
</Callout>

---

## 도구별 파일 읽기 관계

다음 다이어그램은 각 AI 도구가 어떤 파일을 자동으로 읽는지 보여줍니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph ROOT_DIR ["프로젝트 루트"]
      CM["CLAUDE.md"]
      AM["AGENTS.md"]
    end
    subgraph CLAUDE_DIR [".claude/"]
      Rules["rules/"]
      Agents["agents/"]
      Skills["skills/"]
      Commands["commands/"]
      SettingsFile["settings.json"]
    end
    subgraph OTHER_DIR ["기타 도구 설정"]
      CopilotFile[".github/copilot-instructions.md"]
      CursorFile[".cursor/rules/*.mdc"]
      WindsurfFile[".windsurf/rules/"]
    end
    CC["Claude Code"] --> CM;
    CC --> Rules;
    CC --> Agents;
    CC --> Skills;
    CC --> Commands;
    CC --> SettingsFile;
    CC -.->|"@import"| ROOT_DIR;
    CC -.->|"@import로 참조"| AM;
    GH["GitHub Copilot"] --> CopilotFile;
    GH -->|"읽음"| AM;
    CU["Cursor"] --> CursorFile;
    CU -->|"읽음"| AM;
    OA["OpenAI Codex"] --> AM;
    WS["Windsurf"] --> WindsurfFile;
    style CC fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style GH fill:#f0f0f0,stroke:#333,color:#2d2a26
    style CU fill:#f0f0f0,stroke:#333,color:#2d2a26
    style OA fill:#f0f0f0,stroke:#333,color:#2d2a26
    style WS fill:#f0f0f0,stroke:#333,color:#2d2a26`}
  title="AI 도구별 파일 읽기 관계"
  caption="실선: 자동 로드 | 점선: 명시적 @import 또는 참조 필요 | Claude Code에서 AGENTS.md는 CLAUDE.md에서 @import해야 로드됩니다"
/>

---

## 크로스 도구 표준: AGENTS.md

여러 AI 도구를 병행 사용하는 프로젝트에서는 **AGENTS.md**가 유일한 크로스 도구 표준입니다.

| 항목 | 내용 |
|------|------|
| **관리 주체** | Linux Foundation 산하 Agentic AI Foundation (2025년 12월 설립, [Announcement](https://www.linuxfoundation.org/press/linux-foundation-announces-the-formation-of-the-agentic-ai-foundation)) |
| **창립 멤버** | Anthropic, Block, OpenAI |
| **지원 도구** | OpenAI Codex, Cursor, Google Jules, GitHub Copilot (coding agent 모드) 등 |
| **채택 규모** | 60,000+ GitHub 저장소 |

<CodeBlock
  code={`# AGENTS.md (프로젝트 루트)

## Project Overview
TypeScript + Express.js REST API with Clean Architecture.

## Coding Standards
- Use camelCase for variables, PascalCase for classes
- Max function length: 30 lines
- Always handle errors explicitly

## Architecture
4-layer: Presentation → Application → Domain ← Infrastructure
Domain layer has no external dependencies.

## Testing
- Unit tests required for all domain logic
- Integration tests for API endpoints
- Use vitest as test runner`}
  language="markdown"
  filename="AGENTS.md"
/>

<Callout type="tip" title="AGENTS.md vs CLAUDE.md">
  `AGENTS.md`는 OpenAI Codex, Cursor, GitHub Copilot 등 여러 도구가 공통으로 읽는 범용 지시사항입니다.
  `CLAUDE.md`는 Claude Code 전용 지시사항으로, `@import`, `.claude/rules/` 연동 등 Claude Code 고유 기능을 활용할 수 있습니다.
  **참고:** Claude Code는 AGENTS.md를 자동으로 읽지 않습니다. CLAUDE.md에서 `@AGENTS.md`로 임포트하면 두 파일을 함께 활용할 수 있습니다.
</Callout>

---

## Claude Code 공식 설정 구조

Claude Code는 다음 공식 경로를 자동으로 인식합니다.

<FileTree
  title=".claude/ — Claude Code 공식 설정"
  data={[
    {
      name: '.claude/',
      type: 'folder',
      highlight: true,
      children: [
        {
          name: 'commands/',
          type: 'folder',
          description: '커스텀 슬래시 커맨드 (.md)',
          children: [
            { name: 'commit.md', type: 'file', description: '/commit' },
            { name: 'review.md', type: 'file', description: '/review' },
            { name: 'test.md', type: 'file', description: '/test' },
          ],
        },
        {
          name: 'skills/',
          type: 'folder',
          description: '실행 가능한 스킬 (SKILL.md)',
          children: [
            { name: 'code-review/', type: 'folder', description: 'SKILL.md 포함 디렉토리' },
            { name: 'deploy/', type: 'folder', description: 'SKILL.md 포함 디렉토리' },
          ],
        },
        {
          name: 'agents/',
          type: 'folder',
          description: '커스텀 서브에이전트 (.md)',
          children: [
            { name: 'code-reviewer.md', type: 'file', description: 'YAML 프론트매터 + 지시사항' },
            { name: 'debugger.md', type: 'file', description: 'YAML 프론트매터 + 지시사항' },
          ],
        },
        {
          name: 'rules/',
          type: 'folder',
          description: '자동 로드되는 프로젝트 규칙 (.md)',
          children: [
            { name: 'code-style.md', type: 'file', description: '코드 스타일 규칙' },
            { name: 'testing.md', type: 'file', description: '테스트 규칙' },
            { name: 'security.md', type: 'file', description: '보안 규칙' },
            {
              name: 'backend/',
              type: 'folder',
              description: '서브디렉토리도 재귀 검색',
              children: [
                { name: 'api.md', type: 'file', description: 'path-scoped 규칙' },
              ],
            },
          ],
        },
        { name: 'settings.json', type: 'file', description: '권한, 훅, MCP 서버 설정 (팀 공유)' },
        { name: 'settings.local.json', type: 'file', description: '개인 설정 오버라이드 (.gitignore)' },
      ],
    },
  ]}
/>

| 디렉토리/파일 | 역할 | 로드 시점 | 비고 |
|--------------|------|----------|------|
| `commands/` | 커스텀 슬래시 커맨드 | `/커맨드명` 입력 시 | 개별 .md 파일이 `/파일명`으로 호출됨 |
| `skills/` | 실행 가능한 스킬 | `/스킬명` 입력 시 | 각 스킬은 `SKILL.md`를 포함하는 디렉토리 |
| `agents/` | 커스텀 서브에이전트 | Task 도구 사용 시 | YAML 프론트매터 + 마크다운으로 정의 |
| `rules/` | 모듈화된 프로젝트 규칙 | **항상 자동 로드** | path-scoped 규칙 지원. 서브디렉토리 재귀 검색 |
| `settings.json` | 권한, 훅, MCP 서버 설정 | **항상 자동 로드** | 팀 공유용 (Git 커밋) |
| `settings.local.json` | 개인 설정 오버라이드 | **항상 자동 로드** | `.gitignore` 자동 추가 |

### Claude Code 컨텍스트 로딩 순서

Claude Code가 대화를 시작할 때 프로젝트 지식을 로드하는 순서입니다:

<MermaidDiagram
  chart={`flowchart TB
    A["1. 조직 관리 정책\n(Managed Policy)"] --> B
    B["2. CLAUDE.md\n(프로젝트 루트)"] --> C
    C["3. .claude/CLAUDE.md"] --> D
    D["4. .claude/rules/*.md\n(자동 로드)"] --> E
    E["5. CLAUDE.md의 @import\n(재귀적 로드, AGENTS.md 포함 가능)"] --> F
    F["6. CLAUDE.local.md\n(개인 설정)"] --> G
    G["7. ~/.claude/CLAUDE.md\n(사용자 전역 설정)"]
    style A fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#16a34a,color:#2d2a26
    style C fill:#fdf2ee,stroke:#16a34a,color:#2d2a26
    style D fill:#fdf2ee,stroke:#9333ea,color:#2d2a26
    style E fill:#fdf2ee,stroke:#9333ea,color:#2d2a26
    style F fill:#fdf2ee,stroke:#6b7280,color:#2d2a26
    style G fill:#fdf2ee,stroke:#6b7280,color:#2d2a26`}
  title="Claude Code 컨텍스트 로딩 순서"
  caption="위에서 아래 순서로 로드됩니다. 조직 관리 정책은 macOS: /Library/Application Support/ClaudeCode/, Linux: /etc/claude-code/"
/>

<Callout type="info" title=".claude/rules/의 path-scoped 규칙">
  `.claude/rules/` 파일은 YAML 프론트매터의 `paths` 필드로 특정 파일 패턴에만 적용할 수 있습니다.
  예를 들어 `paths: ["src/api/**"]`를 설정하면, 해당 규칙은 API 관련 파일을 다룰 때만 컨텍스트에 포함됩니다.
  이렇게 하면 불필요한 규칙으로 컨텍스트 윈도우를 소비하지 않습니다.
</Callout>

---

## 프로젝트 지식 구조 설계 원칙

지식 구조는 단순히 파일을 배치하는 것이 아니라, **설계 원칙**에 따라 체계적으로 구성해야 합니다. 소프트웨어 아키텍처의 핵심 원칙들이 지식 구조에도 동일하게 적용됩니다.

### 단일 진실 공급원 (Single Source of Truth)

동일한 정보가 여러 파일에 중복되면, 한쪽을 수정할 때 다른 쪽을 놓치는 **정보 불일치** 문제가 발생합니다. 이는 AI 에이전트에게 모순된 지시를 주어 예측 불가능한 코드 생성으로 이어집니다.

<ComparisonTable
  title="SSOT 적용 예시"
  headers={['항목', '잘못된 방식', '올바른 방식']}
  rows={[
    { feature: '코딩 컨벤션', values: ['CLAUDE.md와 AGENTS.md에 각각 작성', 'AGENTS.md에 작성하고 CLAUDE.md에서 @AGENTS.md로 참조'] },
    { feature: '아키텍처 규칙', values: ['rules/architecture.md와 docs/architecture.md에 동일 내용', 'rules/architecture.md에 핵심 규칙만, docs/에는 상세 설명 (역할 분리)'] },
    { feature: '환경 변수 목록', values: ['CLAUDE.md, README.md, .env.example에 각각 나열', '.env.example을 SSOT로 지정하고 다른 파일에서 참조만'] },
    { feature: '빠른 명령어', values: ['CLAUDE.md와 package.json scripts에 이중 관리', 'CLAUDE.md에서 npm scripts를 참조하도록 안내'] },
  ]}
/>

<CodeBlock
  code={`# CLAUDE.md — SSOT 패턴 적용

## 프로젝트 개요
TypeScript + Next.js + PostgreSQL | 클린 아키텍처

## 빠른 명령어
package.json scripts 참조: npm run dev / test / lint / build

## 공통 규칙
@AGENTS.md

## 아키텍처 (핵심 규칙은 .claude/rules/에서 자동 로드)
상세 설명은 @docs/architecture.md 참조

## 도메인 용어
@docs/glossary.md`}
  language="markdown"
  filename="CLAUDE.md - SSOT 패턴: 중복 없이 참조로 연결"
/>

### DRY (Don't Repeat Yourself) 원칙

지식 파일에서도 DRY 원칙은 필수적입니다. 반복은 유지보수 부담을 기하급수적으로 늘립니다.

| 위반 패턴 | 문제 | 해결 방법 |
|-----------|------|----------|
| 같은 네이밍 규칙을 3개 파일에 작성 | 하나를 수정하면 나머지 2개가 구식 정보 | `.claude/rules/naming.md`에 한 번만 작성 |
| CLAUDE.md에 전체 아키텍처 다이어그램 삽입 | 컨텍스트 윈도우 낭비, 매 대화마다 로드 | 핵심 규칙만 rules/에, 상세는 @import |
| 각 도구 설정에 동일한 보안 규칙 복사 | 도구가 늘수록 관리 지점 증가 | AGENTS.md에 공통 보안 규칙, 도구별 고유 설정만 각자 |

### 관심사의 분리 (Separation of Concerns)

지식 파일도 하나의 파일이 하나의 관심사만 다뤄야 합니다. 코딩 컨벤션, 아키텍처 규칙, 보안 정책, 테스트 전략을 하나의 거대한 CLAUDE.md에 모두 넣으면 유지보수성이 급격히 떨어집니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph BAD ["잘못된 구조: 모놀리식"]
      MONO["CLAUDE.md\n(500줄+)\n컨벤션+아키텍처+보안+테스트+도메인"]
    end
    subgraph GOOD ["올바른 구조: 관심사 분리"]
      ENTRY["CLAUDE.md\n(30줄)\n프로젝트 개요 + @import"]
      ENTRY --> R1[".claude/rules/\ncode-style.md"]
      ENTRY --> R2[".claude/rules/\narchitecture.md"]
      ENTRY --> R3[".claude/rules/\nsecurity.md"]
      ENTRY --> R4[".claude/rules/\ntesting.md"]
      ENTRY --> D1["@docs/\nglossary.md"]
    end
    style BAD fill:#fef2f2,stroke:#ef4444,color:#2d2a26
    style GOOD fill:#f0fdf4,stroke:#22c55e,color:#2d2a26
    style MONO fill:#fecaca,stroke:#ef4444,color:#2d2a26
    style ENTRY fill:#bbf7d0,stroke:#22c55e,color:#2d2a26`}
  title="지식 구조: 모놀리식 vs 관심사 분리"
  caption="왼쪽: 하나의 거대한 파일에 모든 정보 | 오른쪽: 역할별로 분리하고 진입점에서 연결"
/>

### 최소 노출 원칙 (Least Context)

자동 로드되는 파일에는 **반드시 필요한 최소한의 정보만** 포함해야 합니다. 모든 대화에서 컨텍스트 윈도우에 로드되는 파일이 길면, 실제 작업에 사용할 수 있는 토큰이 줄어듭니다.

| 자동 로드 파일 | 권장 크기 | 포함할 내용 | 제외할 내용 |
|---------------|----------|------------|------------|
| CLAUDE.md | 30-50줄 | 프로젝트 개요, 빠른 명령어, 핵심 제약 | 상세 아키텍처, 도메인 용어집 |
| .claude/rules/*.md | 파일당 50-100줄 | 핵심 코딩 규칙, 패턴 | 예제 코드 모음, 튜토리얼 |
| AGENTS.md | 50줄 이내 | 공통 컨벤션, 기본 아키텍처 | 도구별 고유 설정 |

---

## 디렉토리 구조 유형별 가이드

각 AI 도구의 설정 디렉토리는 고유한 구조와 규칙을 가집니다. 실제 프로젝트에서 어떻게 구성하는지 유형별로 살펴봅니다.

### .claude/ 디렉토리 심화

<FileTree
  title=".claude/ — 실전 구성 예시 (중규모 프로젝트)"
  data={[
    {
      name: '.claude/',
      type: 'folder',
      highlight: true,
      children: [
        {
          name: 'rules/',
          type: 'folder',
          description: '자동 로드 규칙 (관심사별 분리)',
          children: [
            { name: 'code-style.md', type: 'file', description: '네이밍, 포맷팅, 임포트 순서' },
            { name: 'architecture.md', type: 'file', description: '레이어 규칙, 의존성 방향' },
            { name: 'security.md', type: 'file', description: '입력 검증, 인증, 시크릿 관리' },
            { name: 'testing.md', type: 'file', description: '테스트 패턴, 커버리지 기준' },
            { name: 'error-handling.md', type: 'file', description: '에러 클래스, 로깅 규칙' },
            {
              name: 'frontend/',
              type: 'folder',
              description: 'path-scoped: src/frontend/**',
              children: [
                { name: 'react-patterns.md', type: 'file', description: '컴포넌트 규칙' },
                { name: 'state-management.md', type: 'file', description: '상태 관리 패턴' },
              ],
            },
            {
              name: 'backend/',
              type: 'folder',
              description: 'path-scoped: src/backend/**',
              children: [
                { name: 'api-design.md', type: 'file', description: 'REST API 규칙' },
                { name: 'database.md', type: 'file', description: '쿼리, 마이그레이션 규칙' },
              ],
            },
          ],
        },
        {
          name: 'commands/',
          type: 'folder',
          description: '팀 공유 슬래시 커맨드',
          children: [
            { name: 'commit.md', type: 'file', description: 'Conventional Commit 생성' },
            { name: 'review.md', type: 'file', description: '코드 리뷰 체크리스트 실행' },
            { name: 'migrate.md', type: 'file', description: 'DB 마이그레이션 스크립트 생성' },
          ],
        },
        {
          name: 'agents/',
          type: 'folder',
          description: '전문 서브에이전트',
          children: [
            { name: 'code-reviewer.md', type: 'file', description: '보안/성능 중심 리뷰' },
            { name: 'test-writer.md', type: 'file', description: '테스트 케이스 전문 작성' },
            { name: 'debugger.md', type: 'file', description: '에러 추적 전문' },
          ],
        },
        { name: 'settings.json', type: 'file', description: '권한, 훅, MCP 서버' },
        { name: 'settings.local.json', type: 'file', description: '개인 설정 (.gitignore)' },
      ],
    },
  ]}
/>

<CodeBlock
  code={`# .claude/rules/backend/api-design.md
---
paths:
  - "src/api/**"
  - "src/routes/**"
  - "src/controllers/**"
---

## API 설계 규칙

### 엔드포인트 네이밍
- 리소스 중심: /users, /orders (동사 사용 금지)
- 중첩 리소스: /users/:id/orders
- 최대 깊이: 3단계

### 응답 형식
- 성공: { data: T, meta?: { page, total } }
- 에러: { error: { code, message, details? } }
- HTTP 상태 코드: 200, 201, 400, 401, 403, 404, 500만 사용

### 버전 관리
- URL prefix: /api/v1/, /api/v2/
- Breaking change 시 반드시 새 버전`}
  language="markdown"
  filename=".claude/rules/backend/api-design.md — path-scoped 규칙 예시"
/>

### .cursor/ 디렉토리 구조

<CodeBlock
  code={`.cursor/
├── rules/
│   ├── global.mdc          # alwaysApply: true — 항상 적용
│   ├── react.mdc           # globs: "src/components/**" — React 파일에만
│   ├── api.mdc             # globs: "src/api/**" — API 파일에만
│   └── testing.mdc         # globs: "**/*.test.*" — 테스트 파일에만
└── (settings는 VS Code settings.json에서 관리)`}
  language="text"
  filename=".cursor/ 디렉토리 구조"
/>

<CodeBlock
  code={`---
description: "React 컴포넌트 작성 규칙"
globs: "src/components/**/*.tsx"
alwaysApply: false
---

## 컴포넌트 규칙
- 함수형 컴포넌트만 사용 (class 컴포넌트 금지)
- Props는 interface로 정의 (type alias 아님)
- 컴포넌트 파일 하나에 export 하나
- 스타일은 CSS Modules 사용`}
  language="markdown"
  filename=".cursor/rules/react.mdc — globs로 범위 지정"
/>

### .github/ 디렉토리 구조 (Copilot)

<CodeBlock
  code={`.github/
├── copilot-instructions.md           # 프로젝트 전역 지시사항
├── instructions/
│   ├── react.instructions.md         # React 관련 지시
│   ├── api.instructions.md           # API 관련 지시
│   └── testing.instructions.md       # 테스트 관련 지시
└── workflows/                        # CI/CD (Copilot과 별개)`}
  language="text"
  filename=".github/ 디렉토리 구조 (Copilot 설정)"
/>

<Callout type="info" title="GitHub Copilot의 instructions 파일">
  `.github/instructions/` 디렉토리의 `*.instructions.md` 파일은 YAML 프론트매터의 `applyTo` 필드로 범위를 지정합니다.
  예를 들어 `applyTo: "src/components/**/*.tsx"`를 설정하면 해당 패턴의 파일 작업 시에만 적용됩니다.
  Claude Code의 path-scoped rules와 유사한 개념으로, glob 패턴 기반 범위 지정을 지원합니다.
</Callout>

---

## 권장 프로젝트 지식 베이스 구성

프로젝트 지식을 **Claude Code 공식 경로**에 배치하는 권장 구성입니다:

<FileTree
  title="프로젝트 지식 베이스 권장 구조"
  data={[
    { name: 'CLAUDE.md', type: 'file', highlight: true, description: '진입점 — 핵심 규칙 + @import' },
    { name: 'CLAUDE.local.md', type: 'file', description: '개인 설정 (자동 .gitignore)' },
    { name: 'AGENTS.md', type: 'file', highlight: true, description: '크로스 도구 표준 (선택)' },
    {
      name: '.claude/',
      type: 'folder',
      highlight: true,
      children: [
        {
          name: 'rules/',
          type: 'folder',
          description: '자동 로드되는 프로젝트 규칙',
          children: [
            { name: 'code-style.md', type: 'file', description: '코딩 컨벤션' },
            { name: 'architecture.md', type: 'file', description: '아키텍처 규칙' },
            { name: 'security.md', type: 'file', description: '보안 규칙' },
            { name: 'backend/', type: 'folder', description: 'path-scoped 규칙 서브디렉토리' },
          ],
        },
        {
          name: 'agents/',
          type: 'folder',
          description: '커스텀 서브에이전트',
        },
        {
          name: 'skills/',
          type: 'folder',
          description: '실행 가능한 스킬',
        },
        {
          name: 'commands/',
          type: 'folder',
          description: '커스텀 슬래시 커맨드',
        },
        { name: 'settings.json', type: 'file', description: '권한, 훅, MCP 서버' },
      ],
    },
  ]}
/>

### 자동 로드 vs 수동 참조

| 대상 | 로드 방식 | 참조 방법 |
|------|----------|----------|
| `CLAUDE.md` | **항상 자동** | - |
| `AGENTS.md` | **수동** (자동 로드 아님) | CLAUDE.md에서 `@AGENTS.md`로 임포트 |
| `.claude/rules/*.md` | **항상 자동** (path-scoped 가능) | - |
| `.claude/agents/*.md` | Task 도구 호출 시 | Claude가 자동 선택 |
| `.claude/skills/*/SKILL.md` | `/스킬명` 입력 시 | 사용자가 명시적 호출 |
| `.claude/commands/*.md` | `/커맨드명` 입력 시 | 사용자가 명시적 호출 |
| 임의 경로의 .md 파일 | **수동** | CLAUDE.md에서 `@path/to/file.md` |

<Callout type="important" title="자동 로드되는 파일은 간결하게 유지하세요">
  `CLAUDE.md`와 `.claude/rules/`는 **모든 대화에서 자동으로 컨텍스트에 포함**됩니다.
  이 파일들이 길면 매번 토큰을 소비하고, 핵심 정보가 묻히는 Lost in the Middle 현상이 발생합니다.
  자동 로드 파일에는 핵심 규칙만 두고, 상세 내용은 별도 파일에 분리하여 `@import`로 연결하세요.
</Callout>

---

## 공식 경로에서 파일을 참조하는 방법

### Claude Code: @import 구문과 .claude/rules/

`.claude/rules/` 디렉토리의 파일은 자동으로 로드됩니다. 추가로 외부 파일을 CLAUDE.md에서 `@import`할 수 있습니다:

<CodeBlock
  code={`# CLAUDE.md (프로젝트 루트)

## 프로젝트 개요
TypeScript + Express.js + PostgreSQL / Clean Architecture 4레이어

## 빠른 명령어
npm run dev / npm test / npm run lint

## 상세 컨텍스트 (자동 임포트)
@docs/context.md
@docs/api-guide.md`}
  language="markdown"
  filename="CLAUDE.md — .claude/rules/는 자동 로드, 추가 파일은 @import"
/>

<Callout type="info" title="@ 임포트 동작 방식">
  CLAUDE.md에서 `@path/to/file.md` 구문으로 외부 파일을 임포트합니다.
  경로는 import를 포함한 파일 기준으로 해석됩니다 (작업 디렉토리 아님).
  `@~/` 경로로 홈 디렉토리 파일도 참조 가능합니다.
  코드 블록 내부의 `@`는 무시됩니다.
  **`@` 없이 경로만 텍스트로 적으면 Claude Code가 해당 파일을 자동으로 읽지 않습니다.**
</Callout>

### GitHub Copilot: instructions 파일에 내용 복사

<CodeBlock
  code={`# .github/copilot-instructions.md

## Architecture
4-layer Clean Architecture: Presentation → Application → Domain ← Infrastructure

## Coding Conventions
- File naming: kebab-case.ts
- Functions: max 30 lines, max 3 parameters
- Use Conventional Commits`}
  language="markdown"
  filename=".github/copilot-instructions.md"
/>

### Cursor: .mdc 규칙에서 @file 참조

<CodeBlock
  code={`---
description: "프로젝트 아키텍처 규칙"
globs: "src/**/*"
alwaysApply: false
---

@.claude/rules/architecture.md 의 레이어 규칙을 따르세요.
Domain 레이어는 외부 의존성을 가질 수 없습니다.`}
  language="markdown"
  filename=".cursor/rules/architecture.mdc — @file로 규칙 참조"
/>

### 크로스 도구: AGENTS.md

<CodeBlock
  code={`# AGENTS.md

## Architecture
4-layer Clean Architecture: Presentation -> Application -> Domain <- Infrastructure

## Conventions
camelCase, kebab-case.ts, max 30 lines per function

## Security
NEVER hardcode secrets, ALWAYS validate inputs`}
  language="markdown"
  filename="AGENTS.md — 여러 AI 도구가 공통으로 읽는 범용 지시사항"
/>

---

## 지식 파일 간 상호 참조 전략

프로젝트 지식이 여러 파일로 분리되면, **파일 간 참조 관계**를 명확히 설계해야 합니다. 참조가 엉키면 순환 의존이 발생하거나, 필요한 정보를 찾지 못하는 문제가 생깁니다.

### 참조 방향 원칙

<MermaidDiagram
  chart={`flowchart TB
    subgraph ENTRY ["진입점 레이어"]
      CM["CLAUDE.md"]
      AM["AGENTS.md"]
    end
    subgraph AUTO ["자동 로드 레이어"]
      R1["rules/code-style.md"]
      R2["rules/architecture.md"]
      R3["rules/security.md"]
    end
    subgraph DETAIL ["상세 참조 레이어"]
      D1["docs/context.md"]
      D2["docs/glossary.md"]
      D3["docs/api-spec.md"]
    end
    CM -->|"@import"| D1
    CM -->|"@import"| D2
    CM -->|"@import"| AM
    R2 -.->|"참조 안내"| D3
    D1 -.->|"참조 불가\n(자동 로드 아님)"| R1
    style ENTRY fill:#dbeafe,stroke:#3b82f6,color:#2d2a26
    style AUTO fill:#fef3c7,stroke:#f59e0b,color:#2d2a26
    style DETAIL fill:#f3e8ff,stroke:#a855f7,color:#2d2a26`}
  title="지식 파일 참조 방향"
  caption="진입점에서 상세로 참조 | 상세에서 자동 로드 레이어로 역참조하면 안 됨 | rules/는 자동 로드되므로 @import 불필요"
/>

### 참조 전략 규칙

| 규칙 | 설명 | 예시 |
|------|------|------|
| **단방향 참조** | 상위 레이어에서 하위 레이어로만 참조 | CLAUDE.md -> docs/context.md (O), docs/ -> rules/ (X) |
| **순환 금지** | A -> B -> A 형태의 순환 @import 금지 | 순환이 감지되면 무한 루프 위험 |
| **자동 로드 파일은 @import 불필요** | .claude/rules/는 이미 자동 로드됨 | CLAUDE.md에서 rules/ 파일을 다시 @import하면 중복 |
| **크로스 레퍼런스는 텍스트로** | 자동 로드 파일에서 다른 파일을 안내할 때는 텍스트로 | "상세 API 스펙은 docs/api-spec.md를 참조하세요" |

<CodeBlock
  code={`# .claude/rules/architecture.md — 상호 참조 예시

## 레이어 규칙
- Domain -> Infrastructure 의존 금지
- Application에서 Domain 서비스만 호출

## 상세 참조
- 전체 아키텍처 다이어그램: docs/architecture.md 참조
- API 인터페이스 계약: docs/api-spec.md 참조
- (위 파일들은 필요 시 CLAUDE.md의 @import로 로드됨)`}
  language="markdown"
  filename=".claude/rules/architecture.md — 텍스트로 상호 참조 안내"
/>

---

## 지식 구조 설계 전략

### CLAUDE.md vs .claude/rules/ 분리 기준

<ComparisonTable
  title="어디에 무엇을 넣을 것인가"
  headers={['구분', 'CLAUDE.md', '.claude/rules/', '@import 문서']}
  rows={[
    { feature: '로드 방식', values: ['항상 자동 로드', '항상 자동 로드', '@import 시 로드'] },
    { feature: '적합한 내용', values: ['프로젝트 개요, 빠른 명령어', '코딩 규칙, 아키텍처, 보안', '상세 컨텍스트, 도메인 문서'] },
    { feature: '권장 크기', values: ['50줄 이내', '파일당 100줄 이내', '제한 없음'] },
    { feature: 'path-scoped 지원', values: ['no', 'yes', 'no'] },
    { feature: '다른 도구 호환', values: ['Claude Code 전용', 'Claude Code 전용', '범용 (텍스트)'] },
  ]}
/>

<Callout type="tip" title="규칙 분리 기준">
  **CLAUDE.md**: "이 프로젝트가 뭔지" 한눈에 파악하는 정보 (프로젝트 개요, 빠른 명령어, 핵심 제약사항).
  **.claude/rules/**: "코드를 어떻게 작성할지" 상세 규칙 (네이밍, 스타일, 아키텍처, 테스트, 보안).
  **@import 문서**: "깊이 알아야 할 때" 참조하는 상세 정보 (도메인 용어집, API 스펙, 환경 설정).
</Callout>

### 멀티 도구 프로젝트에서의 전략

팀에서 여러 AI 도구를 사용하는 경우, 다음 전략을 권장합니다:

| 전략 | 설명 |
|------|------|
| **AGENTS.md를 정보의 단일 소스(SSOT)로 사용** | 프로젝트 개요, 아키텍처, 핵심 컨벤션을 AGENTS.md에 작성 |
| **도구별 설정에서 AGENTS.md를 참조** | CLAUDE.md, .cursor/rules/ 등에서 AGENTS.md의 내용을 중복 작성하지 않고 참조 |
| **도구 고유 기능은 각 도구 설정에** | Claude Code의 @import, Cursor의 globs 등 도구 고유 기능은 각자의 설정 파일에 |

<CodeBlock
  code={`# CLAUDE.md — 멀티 도구 프로젝트 예시

## 공통 규칙
@AGENTS.md

## Claude Code 전용 설정
- .claude/rules/에 path-scoped 규칙 활용
- 상세 컨텍스트: @docs/context.md
- 커스텀 커맨드: /commit, /review, /test 활용`}
  language="markdown"
  filename="CLAUDE.md — AGENTS.md를 @import하는 패턴"
/>

<Callout type="info" title="개인 설정 분리: CLAUDE.local.md">
  팀 공유용 CLAUDE.md 외에, **CLAUDE.local.md**를 만들면 개인 설정을 분리할 수 있습니다.
  이 파일은 자동 로드되며 `.gitignore`에 자동 추가됩니다.
  개인 코딩 스타일, 선호 도구, 실험적 설정 등을 팀 설정과 분리할 때 유용합니다.
</Callout>

<Callout type="warning" title="Cursor .cursorrules는 deprecated">
  Cursor의 `.cursorrules` 파일은 deprecated되었습니다.
  현재는 `.cursor/rules/` 디렉토리에 `.mdc` 파일로 규칙을 관리합니다.
  `description`, `globs`, `alwaysApply` 등 메타데이터를 지원하여 더 유연한 규칙 적용이 가능합니다.
</Callout>

---

## 자동 생성 vs 수동 관리 비교

프로젝트 지식 구조를 처음 만들 때, **자동 생성 도구를 활용할지 수동으로 관리할지** 결정해야 합니다. 각 접근 방식에는 뚜렷한 장단점이 있습니다.

<ComparisonTable
  title="자동 생성 vs 수동 관리"
  headers={['항목', '자동 생성 (claude /init 등)', '수동 관리']}
  rows={[
    { feature: '초기 셋업 속도', values: ['빠름 (수 초)', '느림 (수 시간)'] },
    { feature: '프로젝트 맞춤 정확도', values: ['중간 (템플릿 기반)', '높음 (도메인 지식 반영)'] },
    { feature: '유지보수 부담', values: ['재생성 시 덮어쓰기 위험', '수동 업데이트 필요'] },
    { feature: '팀 협업 적합성', values: ['팀 리뷰 필수', '팀 합의 과정에서 자연스럽게 품질 확보'] },
    { feature: '도메인 지식 반영', values: ['불가 (일반적 패턴만)', '가능 (비즈니스 규칙 포함)'] },
    { feature: '권장 시점', values: ['프로젝트 초기, 프로토타이핑', '프로덕션 진입 후, 팀 규모 성장 시'] },
  ]}
/>

### 자동 생성 도구들

| 도구/방법 | 생성 대상 | 특징 |
|-----------|----------|------|
| `claude /init` | CLAUDE.md | 프로젝트 구조를 분석하여 초기 CLAUDE.md 생성 |
| Claude Code 대화 | .claude/rules/*.md | "프로젝트 규칙을 분석해서 rules/ 파일을 생성해줘" |
| 커뮤니티 템플릿 | 전체 .claude/ 구조 | GitHub에서 공유되는 .claude/ 보일러플레이트 |
| `cursor init` | .cursor/rules/ | Cursor IDE에서 프로젝트 분석 후 규칙 생성 |

### 권장: 하이브리드 접근법

<MermaidDiagram
  chart={`flowchart LR
    A["1. 자동 생성\n(claude /init)"] --> B["2. 팀 리뷰\n(PR로 검토)"]
    B --> C["3. 도메인 지식 추가\n(수동 보강)"]
    C --> D["4. 정기 업데이트\n(분기별 리뷰)"]
    D -->|"프로젝트 변경 시"| C
    style A fill:#dbeafe,stroke:#3b82f6,color:#2d2a26
    style B fill:#fef3c7,stroke:#f59e0b,color:#2d2a26
    style C fill:#dcfce7,stroke:#22c55e,color:#2d2a26
    style D fill:#f3e8ff,stroke:#a855f7,color:#2d2a26`}
  title="하이브리드 접근법: 자동 생성 + 수동 보강"
  caption="자동 생성으로 시작하되, 팀 리뷰와 도메인 지식을 수동으로 보강하는 사이클"
/>

<Callout type="tip" title="자동 생성 후 반드시 리뷰하세요">
  `claude /init`으로 생성된 CLAUDE.md는 프로젝트의 파일 구조를 분석한 결과일 뿐, 비즈니스 규칙이나 팀 컨벤션은 반영하지 못합니다.
  자동 생성된 파일을 PR로 올려 팀이 함께 검토하고, 도메인 특화 정보를 추가하세요.
</Callout>

---

## 대규모 프로젝트에서의 지식 관리

### 모노레포 (Monorepo) 전략

모노레포 환경에서는 **루트 레벨 지식**과 **패키지별 지식**을 분리해야 합니다. Claude Code는 작업 디렉토리 기준으로 가장 가까운 CLAUDE.md를 우선 로드합니다.

<FileTree
  title="모노레포 지식 구조"
  data={[
    { name: 'CLAUDE.md', type: 'file', highlight: true, description: '루트: 공통 규칙, 모노레포 구조 안내' },
    { name: 'AGENTS.md', type: 'file', description: '크로스 도구 공통 규칙' },
    {
      name: '.claude/',
      type: 'folder',
      children: [
        {
          name: 'rules/',
          type: 'folder',
          description: '공통 규칙 (모든 패키지에 적용)',
          children: [
            { name: 'code-style.md', type: 'file', description: '공통 코딩 컨벤션' },
            { name: 'security.md', type: 'file', description: '공통 보안 규칙' },
            { name: 'git-workflow.md', type: 'file', description: '공통 Git 워크플로' },
          ],
        },
      ],
    },
    {
      name: 'packages/',
      type: 'folder',
      children: [
        {
          name: 'web-app/',
          type: 'folder',
          description: 'Next.js 프론트엔드',
          children: [
            { name: 'CLAUDE.md', type: 'file', highlight: true, description: '패키지별 규칙 (React, CSS 등)' },
          ],
        },
        {
          name: 'api-server/',
          type: 'folder',
          description: 'Express.js 백엔드',
          children: [
            { name: 'CLAUDE.md', type: 'file', highlight: true, description: '패키지별 규칙 (API, DB 등)' },
          ],
        },
        {
          name: 'shared-lib/',
          type: 'folder',
          description: '공유 유틸리티',
          children: [
            { name: 'CLAUDE.md', type: 'file', highlight: true, description: '패키지별 규칙 (순수 함수, 호환성 등)' },
          ],
        },
      ],
    },
  ]}
/>

<CodeBlock
  code={`# CLAUDE.md (모노레포 루트)

## 프로젝트 개요
이커머스 플랫폼 모노레포 (pnpm workspace)

## 패키지 구조
- packages/web-app: Next.js 프론트엔드 (포트 3000)
- packages/api-server: Express.js API (포트 8080)
- packages/shared-lib: 공유 유틸리티 (순수 함수)

## 공통 명령어
pnpm install / pnpm -r build / pnpm -r test

## 패키지별 작업 시
각 패키지 디렉토리의 CLAUDE.md를 반드시 참조하세요.
해당 디렉토리에서 Claude Code를 실행하면 자동 로드됩니다.

## 패키지 간 의존성 규칙
- shared-lib은 다른 패키지에 의존하지 않음
- web-app과 api-server는 shared-lib만 의존 가능
- web-app과 api-server 간 직접 의존 금지`}
  language="markdown"
  filename="모노레포 루트 CLAUDE.md"
/>

<CodeBlock
  code={`# CLAUDE.md (packages/api-server/)

## 패키지 개요
Express.js REST API | Clean Architecture 4레이어

## 명령어
pnpm dev / pnpm test / pnpm lint

## 아키텍처
src/presentation/ -> src/application/ -> src/domain/ <- src/infrastructure/

## 이 패키지만의 규칙
- 모든 엔드포인트는 OpenAPI 스키마 필수
- DB 쿼리는 반드시 repository 패턴 사용
- 에러 응답은 RFC 7807 형식

## 공유 패키지 사용
import { ... } from '@project/shared-lib' 형태로만 사용`}
  language="markdown"
  filename="패키지별 CLAUDE.md (api-server)"
/>

### 멀티 프로젝트 (Polyrepo) 전략

독립적인 저장소를 여러 개 운영하는 환경에서는 **조직 수준의 공통 규칙**을 관리하는 것이 핵심입니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph ORG ["조직 수준"]
      POLICY["관리 정책\n(Managed Policy)"]
      USERMD["사용자 전역\n~/.claude/CLAUDE.md"]
      TEMPLATE["템플릿 저장소\n(공통 .claude/ 구조)"]
    end
    subgraph PROJ_A ["프로젝트 A"]
      A_CM["CLAUDE.md"]
      A_RULES[".claude/rules/"]
    end
    subgraph PROJ_B ["프로젝트 B"]
      B_CM["CLAUDE.md"]
      B_RULES[".claude/rules/"]
    end
    subgraph PROJ_C ["프로젝트 C"]
      C_CM["CLAUDE.md"]
      C_RULES[".claude/rules/"]
    end
    POLICY -->|"조직 전체 적용"| PROJ_A
    POLICY -->|"조직 전체 적용"| PROJ_B
    POLICY -->|"조직 전체 적용"| PROJ_C
    USERMD -->|"개인 전역 설정"| PROJ_A
    USERMD -->|"개인 전역 설정"| PROJ_B
    USERMD -->|"개인 전역 설정"| PROJ_C
    TEMPLATE -.->|"복사/동기화"| A_RULES
    TEMPLATE -.->|"복사/동기화"| B_RULES
    TEMPLATE -.->|"복사/동기화"| C_RULES
    style ORG fill:#dbeafe,stroke:#3b82f6,color:#2d2a26
    style PROJ_A fill:#dcfce7,stroke:#22c55e,color:#2d2a26
    style PROJ_B fill:#dcfce7,stroke:#22c55e,color:#2d2a26
    style PROJ_C fill:#dcfce7,stroke:#22c55e,color:#2d2a26`}
  title="멀티 프로젝트 지식 관리"
  caption="조직 관리 정책과 사용자 전역 설정이 모든 프로젝트에 적용 | 템플릿 저장소에서 공통 규칙을 동기화"
/>

<ComparisonTable
  title="모노레포 vs 멀티 프로젝트 전략"
  headers={['항목', '모노레포', '멀티 프로젝트']}
  rows={[
    { feature: '공통 규칙 관리', values: ['루트 .claude/rules/에서 일괄 관리', '템플릿 저장소 또는 Managed Policy'] },
    { feature: '패키지별 규칙', values: ['각 패키지의 CLAUDE.md', '각 저장소의 CLAUDE.md'] },
    { feature: '규칙 동기화', values: ['Git으로 자동 동기화', '수동 복사 또는 자동화 스크립트 필요'] },
    { feature: '컨텍스트 격리', values: ['작업 디렉토리 기준 로드', '저장소 단위로 완전 격리'] },
    { feature: 'CI 통합', values: ['루트 CI에서 통합 검증', '각 저장소 CI에서 개별 검증'] },
  ]}
/>

---

## 지식 구조 마이그레이션 (도구 전환 시)

팀이 사용하는 AI 도구를 변경하거나, 새 도구를 추가할 때 기존 지식 구조를 어떻게 마이그레이션할지 계획해야 합니다.

### 마이그레이션 매핑

<ComparisonTable
  title="도구 간 지식 구조 매핑"
  headers={['기능', 'Claude Code', 'Cursor', 'GitHub Copilot', 'Roo Code']}
  rows={[
    { feature: '프로젝트 규칙', values: ['.claude/rules/*.md', '.cursor/rules/*.mdc', '.github/instructions/*.instructions.md', '.roo/rules/*.md'] },
    { feature: '전역 지시', values: ['CLAUDE.md', '.cursor/rules/ (alwaysApply)', '.github/copilot-instructions.md', '.roo/rules/ (global)'] },
    { feature: '범위 지정', values: ['paths: ["src/**"]', 'globs: "src/**"', 'applyTo: "src/**"', 'glob 패턴'] },
    { feature: '개인 설정', values: ['CLAUDE.local.md', '수동 .gitignore', '없음', '없음 (글로벌 규칙으로 대체)'] },
    { feature: '공통 포맷', values: ['AGENTS.md (@import 필요)', 'AGENTS.md 지원', 'AGENTS.md 지원', 'AGENTS.md 지원'] },
  ]}
/>

### 마이그레이션 체크리스트

| 단계 | 작업 | 비고 |
|------|------|------|
| 1. 기존 규칙 목록화 | 현재 도구의 모든 규칙 파일을 목록으로 정리 | 범위(scope) 정보 포함 |
| 2. 공통 부분 추출 | 도구 독립적인 규칙을 AGENTS.md로 이동 | 도구별 고유 구문 제거 |
| 3. 대상 도구 포맷 변환 | 메타데이터, 범위 지정 방식 변환 | YAML frontmatter vs globs |
| 4. 참조 구문 변환 | @import, @file 등 참조 구문을 대상 도구 방식으로 | Claude: @path, Cursor: @file |
| 5. 검증 | 대상 도구에서 규칙이 올바르게 로드되는지 확인 | 테스트 대화로 검증 |

<CodeBlock
  code={`# 마이그레이션 예시: Cursor -> Claude Code

# 변환 전: .cursor/rules/api.mdc
# ---
# description: "API 설계 규칙"
# globs: "src/api/**"
# alwaysApply: false
# ---
# REST API는 리소스 중심으로 설계하세요.

# 변환 후: .claude/rules/api.md
# ---
# paths:
#   - "src/api/**"
# ---
# ## API 설계 규칙
# REST API는 리소스 중심으로 설계하세요.

# 핵심 차이점:
# 1. 확장자: .mdc -> .md
# 2. 메타데이터: globs -> paths, description 제거
# 3. alwaysApply 없음 (paths가 없으면 항상 적용)`}
  language="bash"
  filename="Cursor -> Claude Code 마이그레이션 예시"
/>

---

## 지식 구조 버전 관리와 팀 리뷰

### Git으로 관리해야 할 파일과 제외할 파일

| 파일 | Git 관리 | 이유 |
|------|----------|------|
| CLAUDE.md | O | 팀 공유 프로젝트 규칙 |
| AGENTS.md | O | 크로스 도구 공통 규칙 |
| .claude/rules/*.md | O | 팀 공유 코딩 규칙 |
| .claude/commands/*.md | O | 팀 공유 커맨드 |
| .claude/agents/*.md | O | 팀 공유 에이전트 |
| .claude/settings.json | O | 팀 공유 권한/훅 설정 |
| CLAUDE.local.md | X | 개인 설정 (자동 .gitignore) |
| .claude/settings.local.json | X | 개인 설정 (자동 .gitignore) |

### 팀 리뷰 프로세스

지식 파일 변경도 코드 변경과 동일한 리뷰 프로세스를 거쳐야 합니다. 잘못된 규칙은 팀 전체의 AI 생성 코드 품질에 영향을 미칩니다.

<MermaidDiagram
  chart={`flowchart LR
    A["규칙 변경 필요\n인지"] --> B["브랜치 생성\nrules/update-xxx"]
    B --> C["규칙 파일 수정"]
    C --> D["PR 생성\n(변경 이유 명시)"]
    D --> E["팀 리뷰\n(2명 이상)"]
    E -->|"승인"| F["머지"]
    E -->|"수정 요청"| C
    F --> G["팀 공지\n(변경 사항 알림)"]
    style A fill:#fef3c7,stroke:#f59e0b,color:#2d2a26
    style D fill:#dbeafe,stroke:#3b82f6,color:#2d2a26
    style E fill:#fce7f3,stroke:#ec4899,color:#2d2a26
    style F fill:#dcfce7,stroke:#22c55e,color:#2d2a26`}
  title="지식 파일 변경 리뷰 프로세스"
  caption="코드 리뷰와 동일한 프로세스 | 규칙 변경은 팀 전체에 영향을 주므로 최소 2명 리뷰 권장"
/>

<CodeBlock
  code={`# PR 템플릿 — 지식 파일 변경

## 변경 대상
- [ ] CLAUDE.md
- [ ] AGENTS.md
- [ ] .claude/rules/
- [ ] .claude/commands/
- [ ] .claude/settings.json
- [ ] 기타: ___

## 변경 이유
<!-- 왜 이 규칙이 필요한지, 또는 기존 규칙의 어떤 문제를 해결하는지 -->

## 영향 범위
<!-- 이 변경이 어떤 작업에 영향을 미치는지 -->

## 검증 방법
<!-- AI에게 테스트 프롬프트를 주어 규칙이 적용되는지 확인한 결과 -->

## 관련 이슈
<!-- 관련 이슈 번호 또는 Slack 스레드 -->`}
  language="markdown"
  filename="PR 템플릿 — 지식 파일 변경 전용"
/>

---

## 실전 사례: 조직 규모별 구성

### 스타트업 (5명 이하, 단일 프로젝트)

스타트업은 속도가 중요합니다. 최소한의 파일로 빠르게 시작하고, 프로젝트가 성장하면서 점진적으로 구조를 확장합니다.

<CodeBlock
  code={`# 스타트업 지식 구조 (최소 구성)

project-root/
├── CLAUDE.md          # 프로젝트 개요 + 핵심 규칙 (50줄)
├── .claude/
│   ├── rules/
│   │   └── conventions.md    # 코딩 컨벤션 (1개 파일에 통합)
│   └── settings.json         # 기본 권한 설정
└── .cursor/rules/            # (Cursor 사용 시, .cursorrules는 deprecated)

# 특징:
# - 파일 수 최소화 (관리 부담 감소)
# - CLAUDE.md에 핵심 규칙 집중
# - .claude/rules/는 1-2개 파일로 시작
# - 도메인 지식은 CLAUDE.md에 인라인`}
  language="text"
  filename="스타트업 지식 구조"
/>

<Callout type="tip" title="스타트업 팁: 과도한 구조화를 피하세요">
  5명 이하 팀에서 10개 이상의 규칙 파일을 만들면 유지보수 부담이 더 큽니다.
  CLAUDE.md 하나와 rules/ 파일 1-2개로 시작하고, 실제로 필요할 때 분리하세요.
  YAGNI(You Aren't Gonna Need It) 원칙은 지식 구조에도 적용됩니다.
</Callout>

### 중견기업 (20-50명, 여러 팀)

중견 기업은 팀 간 일관성과 독립성의 균형이 중요합니다.

<CodeBlock
  code={`# 중견기업 지식 구조 (팀별 분리)

project-root/
├── CLAUDE.md                    # 프로젝트 개요 + @import
├── AGENTS.md                    # 크로스 도구 공통 규칙
├── .claude/
│   ├── rules/
│   │   ├── code-style.md        # 공통 코딩 컨벤션
│   │   ├── architecture.md      # 아키텍처 규칙
│   │   ├── security.md          # 보안 규칙
│   │   ├── testing.md           # 테스트 전략
│   │   ├── frontend/            # path-scoped: src/frontend/**
│   │   │   ├── react.md
│   │   │   └── styling.md
│   │   └── backend/             # path-scoped: src/backend/**
│   │       ├── api.md
│   │       └── database.md
│   ├── commands/
│   │   ├── commit.md
│   │   ├── review.md
│   │   └── deploy-check.md
│   ├── agents/
│   │   ├── code-reviewer.md
│   │   └── test-writer.md
│   └── settings.json
├── docs/
│   ├── context.md               # @import 대상: 상세 컨텍스트
│   ├── glossary.md              # @import 대상: 도메인 용어집
│   └── api-spec.md              # @import 대상: API 스펙
├── .cursor/rules/               # Cursor 사용 팀용
│   └── global.mdc
└── .github/
    └── copilot-instructions.md  # Copilot 사용 팀용

# 특징:
# - path-scoped 규칙으로 프론트/백엔드 분리
# - 팀 공유 커맨드와 에이전트 활용
# - 상세 문서는 docs/에 분리하여 @import
# - 멀티 도구 지원 (AGENTS.md 중심)`}
  language="text"
  filename="중견기업 지식 구조"
/>

### 대기업 (100명 이상, 모노레포 또는 멀티 프로젝트)

대기업 환경에서는 **조직 수준의 거버넌스**와 **프로젝트 수준의 자율성**을 동시에 달성해야 합니다.

<CodeBlock
  code={`# 대기업 지식 구조 (거버넌스 + 자율성)

## 조직 수준 (Managed Policy)
# Linux: /etc/claude-code/CLAUDE.md
# macOS: /Library/Application Support/ClaudeCode/CLAUDE.md
# -> 모든 프로젝트에 강제 적용
# -> 보안 정책, 규정 준수, 금지 패턴 등

## 공유 템플릿 저장소 (org/ai-config-templates)
# .claude/
#   rules/
#     org-security.md          # 조직 공통 보안 규칙
#     org-compliance.md        # 규정 준수 규칙
#     org-code-style.md        # 조직 공통 코딩 컨벤션
#   commands/
#     security-check.md        # 보안 검사 커맨드
#   settings.json              # 조직 표준 권한 설정

## 각 프로젝트 저장소
monorepo-root/
├── CLAUDE.md                    # 모노레포 루트 규칙
├── AGENTS.md                    # 크로스 도구 규칙
├── .claude/
│   ├── rules/                   # 조직 템플릿 + 프로젝트 고유 규칙
│   │   ├── org-security.md      # (조직 템플릿에서 동기화)
│   │   ├── org-compliance.md    # (조직 템플릿에서 동기화)
│   │   ├── project-arch.md      # 프로젝트 고유 아키텍처
│   │   └── project-domain.md    # 프로젝트 고유 도메인 규칙
│   └── settings.json
├── packages/
│   ├── service-a/
│   │   └── CLAUDE.md            # 서비스별 규칙
│   ├── service-b/
│   │   └── CLAUDE.md
│   └── shared/
│       └── CLAUDE.md

# 특징:
# - Managed Policy로 조직 보안 정책 강제
# - 템플릿 저장소에서 공통 규칙 동기화 (CI 자동화)
# - 각 프로젝트/서비스는 고유 규칙 추가 가능
# - 정기 감사로 규칙 준수 여부 확인`}
  language="text"
  filename="대기업 지식 구조"
/>

<ComparisonTable
  title="조직 규모별 지식 구조 비교"
  headers={['항목', '스타트업 (5명 이하)', '중견기업 (20-50명)', '대기업 (100명 이상)']}
  rows={[
    { feature: '파일 수', values: ['2-3개', '10-15개', '20개+ (조직 템플릿 별도)'] },
    { feature: '주요 관심사', values: ['빠른 시작, 단순함', '팀 간 일관성', '거버넌스, 규정 준수'] },
    { feature: '규칙 관리', values: ['개발자 자율', 'PR 리뷰', '플랫폼 팀 관리'] },
    { feature: '멀티 도구', values: ['불필요 (단일 도구)', 'AGENTS.md로 통합', 'AGENTS.md + Managed Policy'] },
    { feature: '도메인 지식', values: ['CLAUDE.md에 인라인', 'docs/에 분리 + @import', '도메인별 전용 규칙 파일'] },
    { feature: '업데이트 주기', values: ['필요 시 즉시', '분기별 리뷰', '월간 감사 + 분기별 업데이트'] },
  ]}
/>

---

## 지식 구조 아키텍처 종합

프로젝트 지식 구조의 전체 아키텍처를 정리합니다. 모든 레이어가 어떻게 연결되고, 어떤 도구가 어떤 파일을 읽는지 한눈에 볼 수 있습니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph ORG_LAYER ["조직 레이어"]
      MP["Managed Policy\n(조직 전체 강제)"]
      USERGL["~/.claude/CLAUDE.md\n(사용자 전역)"]
    end
    subgraph PROJECT_LAYER ["프로젝트 레이어"]
      CM["CLAUDE.md\n(진입점)"]
      AM["AGENTS.md\n(크로스 도구)"]
      LOCAL["CLAUDE.local.md\n(개인 설정)"]
    end
    subgraph RULES_LAYER ["규칙 레이어"]
      RS["rules/code-style.md"]
      RA["rules/architecture.md"]
      RX["rules/security.md"]
      RPF["rules/frontend/*.md\n(path-scoped)"]
      RPB["rules/backend/*.md\n(path-scoped)"]
    end
    subgraph ACTION_LAYER ["실행 레이어"]
      CMD["commands/*.md\n(슬래시 커맨드)"]
      AGT["agents/*.md\n(서브에이전트)"]
      SKL["skills/*/SKILL.md\n(실행 스킬)"]
    end
    subgraph DETAIL_LAYER ["상세 문서 레이어"]
      CTX["docs/context.md"]
      GLOSS["docs/glossary.md"]
      API["docs/api-spec.md"]
    end
    MP --> CM
    USERGL --> CM
    CM -->|"@import"| AM
    CM -->|"@import"| CTX
    CM -->|"@import"| GLOSS
    RS -.->|"자동 로드"| CM
    RA -.->|"자동 로드"| CM
    RX -.->|"자동 로드"| CM
    RPF -.->|"path 매칭 시"| CM
    RPB -.->|"path 매칭 시"| CM
    CMD -.->|"/커맨드"| CM
    AGT -.->|"Task"| CM
    SKL -.->|"/스킬"| CM
    LOCAL -.->|"자동 로드"| CM
    style ORG_LAYER fill:#e0e7ff,stroke:#6366f1,color:#2d2a26
    style PROJECT_LAYER fill:#dcfce7,stroke:#22c55e,color:#2d2a26
    style RULES_LAYER fill:#fef3c7,stroke:#f59e0b,color:#2d2a26
    style ACTION_LAYER fill:#fce7f3,stroke:#ec4899,color:#2d2a26
    style DETAIL_LAYER fill:#f3e8ff,stroke:#a855f7,color:#2d2a26`}
  title="프로젝트 지식 구조 전체 아키텍처"
  caption="5개 레이어: 조직 > 프로젝트 > 규칙 > 실행 > 상세 문서 | 실선: 명시적 참조 | 점선: 자동 또는 조건부 로드"
/>

---

## 다음 챕터 미리보기

Part 2의 나머지 챕터에서는 Claude Code의 프로젝트 지식 관리 기능을 상세히 다룹니다:

| 챕터 | 핵심 주제 |
|------|----------|
| **컨텍스트와 컨벤션** | CLAUDE.md 작성법, .claude/rules/ 자동 로드, YAML 프론트매터, path-scoped 규칙 |
| **아키텍처** | .claude/rules/에서 아키텍처 규칙 정의, path-scoped 레이어별 규칙, 데이터 흐름 문서화 |
| **가이드라인** | AI 사용 원칙, .claude/settings.json 권한 모델, Hooks로 자동 검증 |

<ChapterNav
  prev={{ title: 'CLAUDE.md 딥다이브', path: '/docs/part-2--프로젝트-설정-claude-md-딥다이브' }}
  next={{ title: '아키텍처', path: '/docs/part-2--프로젝트-설정-아키텍처' }}
/>
