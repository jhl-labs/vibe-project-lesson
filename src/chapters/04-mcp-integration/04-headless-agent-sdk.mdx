import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 4: MCP와 자동화/Headless 모드 & Agent SDK" />

# Headless 모드 & Agent SDK

> Claude Code를 프로그래밍 방식으로 제어하여 자동화 파이프라인을 구축하는 완전 가이드

## 개요

Claude Code는 대화형 터미널 도구로 잘 알려져 있지만, 그 진정한 힘은 **Headless 모드**와 **Agent SDK**를 통한 프로그래밍 방식의 제어에 있습니다. CI/CD 파이프라인, 자동화 스크립트, 커스텀 에이전트 시스템 등에서 Claude Code의 능력을 API처럼 활용할 수 있습니다.

<Callout type="info" title="Agent SDK가 Headless 모드를 대체합니다">
  이전에는 "headless mode"라는 용어로 비대화형 실행을 지칭했지만, 현재는 **Agent SDK**가 공식적인 프로그래밍 인터페이스로 자리잡았습니다.
  CLI의 `-p` 플래그는 여전히 가장 간편한 비대화형 실행 방법이며, Agent SDK는 더 정교한 제어가 필요할 때 사용합니다.
</Callout>

<MermaidDiagram
  chart={`flowchart TD
    USER["사용자/시스템"] --> CHOICE{"제어 방식 선택"}
    CHOICE -->|"간단한 자동화"| CLI["-p 플래그\n(CLI 비대화형 모드)"]
    CHOICE -->|"정교한 제어"| SDK["Agent SDK\n(Python/TypeScript)"]
    CHOICE -->|"CI/CD 통합"| ACTIONS["GitHub Actions\nclaude-code-action"]
    CLI --> EXEC["Claude Code 엔진"]
    SDK --> EXEC
    ACTIONS --> EXEC
    EXEC --> OUTPUT["결과 출력"]
    OUTPUT --> TEXT["텍스트"]
    OUTPUT --> JSON["구조화된 JSON"]
    OUTPUT --> STREAM["스트리밍"]
    style USER fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style CHOICE fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style CLI fill:#e8f5e9,stroke:#16a34a,color:#2d2a26
    style SDK fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26
    style ACTIONS fill:#fff3e0,stroke:#d97706,color:#2d2a26
    style EXEC fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style OUTPUT fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style TEXT fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style JSON fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style STREAM fill:#f0ece5,stroke:#8c857c,color:#2d2a26`}
  title="Claude Code 프로그래밍 제어 방식"
  caption="세 가지 방식으로 Claude Code를 프로그래밍적으로 제어할 수 있습니다"
/>

## -p 플래그 완전 가이드

`-p` (또는 `--print`) 플래그는 Claude Code를 비대화형으로 실행하는 가장 간편한 방법입니다. 프롬프트를 전달하면 결과를 출력하고 즉시 종료합니다.

### 기본 사용법

<CodeBlock
  code={`# 가장 기본적인 형태 — 프롬프트를 전달하고 결과 출력
claude -p "auth.py의 버그를 찾아서 수정해줘"

# 파이프로 입력 전달
cat error.log | claude -p "이 에러 로그를 분석해줘"

# 파일 내용을 컨텍스트로 전달
cat src/auth.py | claude -p "이 코드의 보안 취약점을 검토해줘"

# 여러 파일을 한 번에 전달
cat src/models/*.py | claude -p "이 모델들의 관계를 분석해줘"

# 명령어 결과를 컨텍스트로 전달
git diff HEAD~3 | claude -p "최근 3개 커밋의 변경사항을 요약해줘"

# git log와 함께 활용
git log --oneline -20 | claude -p "최근 커밋들의 패턴을 분석해줘"`}
  language="bash"
  filename="-p 플래그 기본 사용법"
/>

### 출력 형식 제어

`--output-format` 옵션으로 출력 형식을 제어할 수 있습니다. 자동화 스크립트에서는 `json` 또는 `stream-json` 형식이 특히 유용합니다.

<CodeBlock
  code={`# 텍스트 출력 (기본값) — 사람이 읽기 좋은 형태
claude -p "프로젝트 구조를 설명해줘" --output-format text

# JSON 출력 — 프로그래밍 처리에 적합
claude -p "package.json의 의존성을 분석해줘" --output-format json
# 출력 예시:
# {
#   "type": "result",
#   "subtype": "success",
#   "cost_usd": 0.003,
#   "is_error": false,
#   "duration_ms": 2500,
#   "duration_api_ms": 2100,
#   "num_turns": 1,
#   "result": "분석 결과 텍스트...",
#   "session_id": "abc-123-def"
# }

# 스트리밍 JSON — 실시간 진행 상황 모니터링
claude -p "전체 코드베이스를 리팩토링해줘" --output-format stream-json
# 각 줄마다 JSON 객체가 출력됨:
# {"type":"assistant","message":{"content":[{"type":"text","text":"분석을 시작합니다..."}]}}
# {"type":"tool_use","tool":{"name":"Read","input":{"file_path":"src/main.ts"}}}
# {"type":"result","subtype":"success","result":"리팩토링이 완료되었습니다."}`}
  language="bash"
  filename="출력 형식 옵션"
/>

<ComparisonTable
  title="출력 형식 비교"
  headers={['형식', 'text', 'json', 'stream-json']}
  rows={[
    { feature: '용도', values: ['사람이 읽기', '프로그래밍 처리', '실시간 모니터링'] },
    { feature: '출력 시점', values: ['완료 후 한 번', '완료 후 한 번', '실시간 스트리밍'] },
    { feature: '비용 정보', values: ['미포함', '포함', '최종 결과에 포함'] },
    { feature: '세션 ID', values: ['미포함', '포함', '최종 결과에 포함'] },
    { feature: '도구 호출 정보', values: ['미포함', '미포함', '각 단계별 포함'] },
    { feature: '파싱 난이도', values: ['어려움', '쉬움', '중간 (줄 단위 JSON)'] },
    { feature: '추천 환경', values: ['터미널 직접 확인', 'CI/CD, 스크립트', '대시보드, 실시간 UI'] },
  ]}
/>

### JSON Schema 기반 구조화된 출력

`--json-schema` 옵션을 사용하면 Claude의 응답을 미리 정의한 JSON Schema에 맞춰 구조화된 형태로 받을 수 있습니다. 자동화 파이프라인에서 결과를 프로그래밍적으로 처리할 때 매우 유용합니다.

<CodeBlock
  code={`# JSON Schema로 코드 리뷰 결과를 구조화하여 받기
claude -p "src/auth.ts 파일을 리뷰해줘" \\
  --output-format json \\
  --json-schema '{
    "type": "object",
    "properties": {
      "severity": {
        "type": "string",
        "enum": ["critical", "warning", "info"]
      },
      "issues": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "line": { "type": "number" },
            "message": { "type": "string" },
            "suggestion": { "type": "string" }
          },
          "required": ["line", "message"]
        }
      },
      "summary": { "type": "string" },
      "score": { "type": "number", "minimum": 0, "maximum": 100 }
    },
    "required": ["severity", "issues", "summary", "score"]
  }'

# 결과 예시 (result 필드에 JSON 문자열):
# {
#   "result": "{\"severity\":\"warning\",\"issues\":[{\"line\":15,...}],\"summary\":\"...\",\"score\":72}",
#   "session_id": "...",
#   "cost_usd": 0.005
# }

# jq로 파싱하여 활용
claude -p "코드를 분석해줘" \\
  --output-format json \\
  --json-schema '{"type":"object","properties":{"score":{"type":"number"},"issues":{"type":"array","items":{"type":"string"}}}}' \\
  | jq -r '.result | fromjson | .issues[]'`}
  language="bash"
  filename="JSON Schema 구조화 출력"
/>

<Callout type="tip" title="JSON Schema 활용 팁">
  구조화된 출력은 자동화 파이프라인에서 결과를 파싱할 때 가장 유용합니다.
  예를 들어, CI에서 코드 리뷰 결과의 score가 일정 기준 이하이면 빌드를 실패시키는 등의 로직을 구현할 수 있습니다.
</Callout>

### 도구 자동 승인 전략

`--allowedTools` 옵션으로 Claude가 사용할 수 있는 도구를 명시적으로 지정합니다. 비대화형 모드에서는 사용자가 승인할 수 없으므로, 허용할 도구를 미리 정의하는 것이 필수입니다.

<CodeBlock
  code={`# 읽기 전용 작업 — 안전한 도구만 허용
claude -p "프로젝트 구조를 분석해줘" \\
  --allowedTools "Read,Glob,Grep"

# 코드 수정 포함 — 편집 도구 추가 허용
claude -p "auth.py의 버그를 수정해줘" \\
  --allowedTools "Read,Edit,Bash"

# Bash 명령어 세분화 — 특정 명령어만 허용
claude -p "테스트를 실행하고 실패하면 수정해줘" \\
  --allowedTools "Read,Edit,Bash(npm test),Bash(npm run lint)"

# MCP 서버 도구 허용
claude -p "GitHub 이슈를 분석해줘" \\
  --allowedTools "Read,Grep,mcp__github__list_issues,mcp__github__get_issue"

# 모든 도구 자동 승인 (주의: 보안 위험)
# --dangerously-skip-permissions 플래그 사용
# CI/CD 환경에서만 사용하고, 신뢰할 수 있는 코드에만 적용
claude -p "프로젝트를 정리해줘" \\
  --dangerously-skip-permissions`}
  language="bash"
  filename="도구 자동 승인 전략"
/>

<Callout type="warning" title="도구 승인 보안 원칙">
  비대화형 모드에서는 최소 권한 원칙을 반드시 따르세요.
  `--dangerously-skip-permissions`는 CI/CD 환경의 격리된 컨테이너에서만 사용하고,
  `--allowedTools`로 필요한 도구만 명시적으로 허용하는 것이 안전합니다.
</Callout>

<ComparisonTable
  title="도구 승인 전략별 보안 수준"
  headers={['전략', '보안 수준', '적합한 환경']}
  rows={[
    { feature: '--allowedTools "Read,Grep"', values: ['높음 (읽기 전용)', '코드 분석, 리뷰'] },
    { feature: '--allowedTools "Read,Edit"', values: ['중간 (파일 수정)', '자동 버그 수정'] },
    { feature: '--allowedTools "Read,Edit,Bash(...)"', values: ['중간 (제한된 실행)', '테스트, 빌드'] },
    { feature: '--allowedTools "Read,Edit,Bash"', values: ['낮음 (임의 실행 가능)', '완전 신뢰 환경'] },
    { feature: '--dangerously-skip-permissions', values: ['최소 (모든 도구)', 'CI/CD 격리 컨테이너'] },
  ]}
/>

### 대화 이어서 하기

`--continue`와 `--resume` 옵션으로 이전 대화를 이어갈 수 있습니다. 이는 복잡한 작업을 여러 단계로 나누어 실행할 때 유용합니다.

<CodeBlock
  code={`# 첫 번째 실행 — 세션 ID 확보
RESULT=$(claude -p "src/auth.ts의 구조를 분석해줘" --output-format json)
SESSION_ID=$(echo "$RESULT" | jq -r '.session_id')
echo "세션 ID: $SESSION_ID"

# 가장 최근 대화 이어서 실행 (--continue)
claude -p "아까 분석한 내용을 바탕으로 리팩토링해줘" --continue

# 특정 세션 재개 (--resume)
claude -p "추가로 테스트도 작성해줘" --resume "$SESSION_ID"

# 실전 활용: 3단계 파이프라인
# 1단계: 분석
RESULT=$(claude -p "프로젝트의 아키텍처를 분석해줘" \\
  --output-format json \\
  --allowedTools "Read,Glob,Grep")
SESSION=$(echo "$RESULT" | jq -r '.session_id')

# 2단계: 리팩토링 (분석 결과를 기반으로)
claude -p "분석 결과를 바탕으로 리팩토링을 진행해줘" \\
  --resume "$SESSION" \\
  --allowedTools "Read,Edit"

# 3단계: 테스트 (리팩토링 결과를 기반으로)
claude -p "리팩토링한 코드에 대한 테스트를 작성해줘" \\
  --continue \\
  --allowedTools "Read,Edit,Bash(npm test)"`}
  language="bash"
  filename="대화 이어서 하기"
/>

### 시스템 프롬프트 커스터마이징

`--system-prompt`와 `--append-system-prompt`를 사용하여 Claude의 동작을 세밀하게 제어할 수 있습니다.

<CodeBlock
  code={`# 시스템 프롬프트 완전 교체
# 기본 시스템 프롬프트를 완전히 대체합니다
claude -p "이 코드를 리뷰해줘" \\
  --system-prompt "당신은 시니어 보안 엔지니어입니다. \
OWASP Top 10 기준으로 코드를 검토하고, \
발견된 취약점을 심각도별로 분류하세요. \
한국어로 응답하세요."

# 시스템 프롬프트 추가 (기본 프롬프트 유지 + 추가)
claude -p "이 함수를 리팩토링해줘" \\
  --append-system-prompt "응답은 반드시 한국어로 작성하세요. \
코드 변경 시 변경 이유를 주석으로 상세히 설명하세요. \
성능 최적화보다 가독성을 우선시하세요."

# CI/CD에서 역할 기반 프롬프트
claude -p "이 PR을 리뷰해줘" \\
  --append-system-prompt "다음 기준으로 리뷰하세요:
1. 보안 취약점 (CRITICAL)
2. 성능 저하 가능성 (WARNING)
3. 코딩 컨벤션 위반 (INFO)
각 이슈에 심각도 태그를 붙여주세요."`}
  language="bash"
  filename="시스템 프롬프트 커스터마이징"
/>

<ComparisonTable
  title="시스템 프롬프트 옵션 비교"
  headers={['옵션', '--system-prompt', '--append-system-prompt']}
  rows={[
    { feature: '동작', values: ['기본 프롬프트를 완전히 교체', '기본 프롬프트에 추가'] },
    { feature: 'CLAUDE.md 인식', values: ['교체됨 (미사용)', '유지됨'] },
    { feature: '기본 도구 지시', values: ['교체됨', '유지됨'] },
    { feature: '주요 용도', values: ['완전히 다른 역할 부여', '기존 동작에 조건 추가'] },
    { feature: '위험도', values: ['높음 (기본 동작 상실)', '낮음 (기본 동작 보존)'] },
    { feature: '추천 사용', values: ['특수 목적 에이전트', 'CI/CD 추가 지시사항'] },
  ]}
/>

### 최대 턴 수 제한

`--max-turns` 옵션으로 에이전트의 최대 실행 턴 수를 제한할 수 있습니다. 비용 관리와 무한 루프 방지에 중요합니다.

<CodeBlock
  code={`# 간단한 분석 작업 — 적은 턴 수
claude -p "이 함수의 시간 복잡도를 분석해줘" \\
  --max-turns 3 \\
  --allowedTools "Read"

# 복잡한 리팩토링 — 더 많은 턴 허용
claude -p "전체 인증 모듈을 리팩토링해줘" \\
  --max-turns 20 \\
  --allowedTools "Read,Edit,Bash(npm test)"

# 모델 선택과 함께 사용
claude -p "이 버그를 진단하고 수정해줘" \\
  --model claude-sonnet-4-20250514 \\
  --max-turns 10 \\
  --allowedTools "Read,Edit,Bash(npm test),Bash(npm run lint)"`}
  language="bash"
  filename="최대 턴 수 제한"
/>

## Agent SDK 심화 가이드

Agent SDK는 Python과 TypeScript 패키지로 제공되며, Claude Code를 프로그래밍 방식으로 완전히 제어할 수 있습니다. CLI `-p` 플래그보다 훨씬 정교한 제어가 가능합니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph SDK["Agent SDK"]
      INIT["SDK 초기화"] --> MSG["메시지 전송"]
      MSG --> STREAM["스트리밍 응답"]
      STREAM --> TOOL["도구 호출 콜백"]
      TOOL --> APPROVE{"승인 로직"}
      APPROVE -->|"승인"| EXEC["도구 실행"]
      APPROVE -->|"거부"| DENY["실행 차단"]
      EXEC --> RESULT["결과 수신"]
      DENY --> RESULT
      RESULT --> NEXT{"계속?"}
      NEXT -->|"예"| MSG
      NEXT -->|"아니오"| DONE["세션 종료"]
    end
    style SDK fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style INIT fill:#e8f5e9,stroke:#16a34a,color:#2d2a26
    style APPROVE fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style DONE fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26`}
  title="Agent SDK 실행 흐름"
  caption="SDK는 메시지 전송, 스트리밍 응답, 도구 승인 콜백 등을 프로그래밍적으로 제어합니다"
/>

### TypeScript Agent SDK

<CodeBlock
  code={`// TypeScript Agent SDK 설치
// npm install @anthropic-ai/claude-agent-sdk

import { query, type ToolUseBlock } from "@anthropic-ai/claude-agent-sdk";

// --- 기본 사용법 ---
async function basicUsage() {
  const response = await query({
    prompt: "src/auth.ts 파일을 분석해줘",
    options: {
      maxTurns: 5,
      allowedTools: ["Read", "Glob", "Grep"],
    },
  });

  // 결과 텍스트 추출
  const resultText = response.messages
    .filter(msg => msg.role === "assistant")
    .flatMap(msg => msg.content)
    .filter(block => block.type === "text")
    .map(block => block.text)
    .join("\\n");

  console.log("분석 결과:", resultText);
  console.log("비용:", response.costUsd, "USD");
  console.log("세션 ID:", response.sessionId);
}

// --- 구조화된 출력 ---
async function structuredOutput() {
  const response = await query({
    prompt: "src/ 디렉토리의 코드 품질을 분석해줘",
    options: {
      maxTurns: 10,
      allowedTools: ["Read", "Glob", "Grep"],
      jsonSchema: {
        type: "object",
        properties: {
          overallScore: { type: "number" },
          categories: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                score: { type: "number" },
                issues: { type: "array", items: { type: "string" } },
              },
              required: ["name", "score", "issues"],
            },
          },
          recommendations: {
            type: "array",
            items: { type: "string" },
          },
        },
        required: ["overallScore", "categories", "recommendations"],
      },
    },
  });

  // 구조화된 결과 파싱
  const lastAssistantMsg = response.messages
    .filter(msg => msg.role === "assistant")
    .pop();
  const textBlock = lastAssistantMsg?.content
    .find(block => block.type === "text");

  if (textBlock) {
    const analysis = JSON.parse(textBlock.text);
    console.log("전체 점수:", analysis.overallScore);
    analysis.categories.forEach(cat => {
      console.log(\`  \${cat.name}: \${cat.score}/100\`);
    });
  }
}

// --- 도구 승인 콜백 ---
async function toolApprovalCallback() {
  const response = await query({
    prompt: "불필요한 파일을 정리해줘",
    options: {
      maxTurns: 15,
      // 도구 호출 시마다 이 콜백이 실행됨
      toolApprovalCallback: async (toolUse: ToolUseBlock) => {
        const toolName = toolUse.name;
        const input = toolUse.input as Record<string, unknown>;

        // 읽기 전용 도구는 항상 승인
        if (["Read", "Glob", "Grep"].includes(toolName)) {
          return { approved: true };
        }

        // 파일 삭제는 특정 패턴만 허용
        if (toolName === "Bash") {
          const command = input.command as string;
          if (command.includes("rm") && !command.includes("node_modules")) {
            return {
              approved: false,
              reason: "node_modules 외 파일 삭제는 금지됩니다",
            };
          }
        }

        // Edit 도구는 테스트 파일만 허용
        if (toolName === "Edit") {
          const filePath = input.file_path as string;
          if (!filePath.includes(".test.") && !filePath.includes(".spec.")) {
            return {
              approved: false,
              reason: "테스트 파일만 수정할 수 있습니다",
            };
          }
        }

        return { approved: true };
      },
    },
  });

  return response;
}`}
  language="typescript"
  filename="TypeScript Agent SDK 사용법"
/>

### Python Agent SDK

<CodeBlock
  code={`# Python Agent SDK 설치
# pip install claude-agent-sdk

import asyncio
from claude_agent_sdk import query, ClaudeAgentOptions, Message

# --- 기본 사용법 ---
async def basic_usage():
    response = await query(
        prompt="src/auth.py 파일을 분석해줘",
        options=ClaudeAgentOptions(
            max_turns=5,
            allowed_tools=["Read", "Glob", "Grep"],
        ),
    )

    # 응답 메시지에서 텍스트 추출
    for message in response.messages:
        if message.role == "assistant":
            for block in message.content:
                if hasattr(block, "text"):
                    print("분석 결과:", block.text)

    print(f"비용: {response.cost_usd} USD")
    print(f"세션 ID: {response.session_id}")

# --- 스트리밍 응답 처리 ---
async def streaming_usage():
    """실시간으로 응답을 받아 처리합니다"""
    async for event in query(
        prompt="전체 코드베이스를 분석해줘",
        options=ClaudeAgentOptions(
            max_turns=10,
            allowed_tools=["Read", "Glob", "Grep"],
            output_format="stream-json",
        ),
    ):
        if event.type == "assistant":
            # 어시스턴트의 텍스트 응답
            for block in event.message.content:
                if hasattr(block, "text"):
                    print(f"[응답] {block.text[:100]}...")

        elif event.type == "tool_use":
            # 도구 호출 정보
            print(f"[도구 호출] {event.tool.name}")

        elif event.type == "result":
            # 최종 결과
            print(f"[완료] 비용: {event.cost_usd} USD")

# --- 구조화된 출력 ---
async def structured_analysis():
    import json

    schema = {
        "type": "object",
        "properties": {
            "bugs": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "file": {"type": "string"},
                        "line": {"type": "number"},
                        "severity": {"type": "string",
                                     "enum": ["critical", "high", "medium", "low"]},
                        "description": {"type": "string"},
                        "fix": {"type": "string"},
                    },
                    "required": ["file", "line", "severity", "description"],
                },
            },
            "total_issues": {"type": "number"},
        },
        "required": ["bugs", "total_issues"],
    }

    response = await query(
        prompt="프로젝트에서 잠재적 버그를 찾아줘",
        options=ClaudeAgentOptions(
            max_turns=15,
            allowed_tools=["Read", "Glob", "Grep"],
            json_schema=schema,
        ),
    )

    # 결과 파싱
    for message in response.messages:
        if message.role == "assistant":
            for block in message.content:
                if hasattr(block, "text"):
                    result = json.loads(block.text)
                    print(f"발견된 이슈: {result['total_issues']}개")
                    for bug in result["bugs"]:
                        print(f"  [{bug['severity']}] "
                              f"{bug['file']}:{bug['line']} - "
                              f"{bug['description']}")

# 실행
asyncio.run(basic_usage())`}
  language="python"
  filename="Python Agent SDK 사용법"
/>

<ComparisonTable
  title="CLI -p 플래그 vs Agent SDK 비교"
  headers={['특성', 'CLI -p 플래그', 'Agent SDK (Python/TS)']}
  rows={[
    { feature: '설치', values: ['Claude Code CLI만 필요', '별도 패키지 설치 필요'] },
    { feature: '실행 방식', values: ['셸 명령어', '프로그래밍 코드'] },
    { feature: '출력 형식', values: ['text, json, stream-json', '네이티브 객체'] },
    { feature: '도구 승인', values: ['--allowedTools 목록', '콜백 함수 (동적 제어)'] },
    { feature: '에러 처리', values: ['exit code, stderr', 'try/catch, 예외 처리'] },
    { feature: '대화 관리', values: ['--continue, --resume', '세션 객체 직접 관리'] },
    { feature: '스트리밍', values: ['stream-json 파싱 필요', '네이티브 async iterator'] },
    { feature: '구조화 출력', values: ['--json-schema (문자열)', 'jsonSchema (객체)'] },
    { feature: '유연성', values: ['중간', '높음'] },
    { feature: '적합한 환경', values: ['셸 스크립트, CI/CD', '복잡한 에이전트 시스템'] },
  ]}
/>

## CI/CD 파이프라인 통합

### GitHub Actions에서 -p 플래그 활용

GitHub Actions에서 `claude-code-action` 대신 직접 Claude Code CLI를 사용하는 패턴입니다. 더 세밀한 제어가 필요할 때 유용합니다.

<CodeBlock
  code={`# .github/workflows/claude-headless.yml
name: Claude Headless Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-agent-sdk

      - name: Analyze PR Changes
        env:
          ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # PR의 변경사항을 분석
          DIFF=$(git diff origin/main...HEAD)

          # 구조화된 리뷰 결과 생성
          REVIEW=$(echo "$DIFF" | claude -p "이 diff를 리뷰해줘. \
            보안, 성능, 코드 품질을 분석하고 점수를 매겨줘." \\
            --output-format json \\
            --json-schema '{
              "type": "object",
              "properties": {
                "score": {"type": "number"},
                "critical_issues": {"type": "array", "items": {"type": "string"}},
                "warnings": {"type": "array", "items": {"type": "string"}},
                "suggestions": {"type": "array", "items": {"type": "string"}}
              },
              "required": ["score", "critical_issues", "warnings", "suggestions"]
            }' \\
            --allowedTools "Read,Glob,Grep" \\
            --max-turns 5)

          # 결과 파싱
          SCORE=$(echo "$REVIEW" | jq -r '.result | fromjson | .score')
          CRITICALS=$(echo "$REVIEW" | jq -r '.result | fromjson | .critical_issues | length')

          echo "리뷰 점수: $SCORE"
          echo "심각한 이슈: $CRITICALS개"

          # 심각한 이슈가 있으면 실패
          if [ "$CRITICALS" -gt 0 ]; then
            echo "::error::심각한 이슈가 발견되었습니다"
            echo "$REVIEW" | jq -r '.result | fromjson | .critical_issues[]'
            exit 1
          fi

      - name: Post Review Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            // 리뷰 결과를 PR 코멘트로 게시
            // ...`}
  language="yaml"
  filename="GitHub Actions + Claude Headless"
/>

### GitLab CI에서 활용

<CodeBlock
  code={`# .gitlab-ci.yml
stages:
  - review
  - test

claude-review:
  stage: review
  image: node:20
  before_script:
    - npm install -g @anthropic-ai/claude-agent-sdk
  script:
    # 변경사항 분석
    - |
      REVIEW_RESULT=$(git diff $CI_MERGE_REQUEST_DIFF_BASE_SHA...HEAD | \\
        claude -p "이 MR의 변경사항을 리뷰해주세요. 한국어로 응답해주세요." \\
        --output-format json \\
        --allowedTools "Read,Glob,Grep" \\
        --max-turns 5 \\
        --append-system-prompt "GitLab MR 리뷰어 역할입니다. \
          보안, 성능, 코드 품질을 분석하세요.")

      echo "$REVIEW_RESULT" | jq -r '.result' > review.md

    # GitLab MR에 코멘트 추가
    - |
      curl --request POST \\
        --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \\
        --header "Content-Type: application/json" \\
        --data "{\\"body\\": $(cat review.md | jq -R -s .)}" \\
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$CI_MERGE_REQUEST_IID/notes"
  rules:
    - if: $CI_MERGE_REQUEST_IID
  variables:
    ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY

claude-test-fix:
  stage: test
  image: node:20
  before_script:
    - npm install -g @anthropic-ai/claude-agent-sdk
    - npm ci
  script:
    # 테스트 실행 후 실패 시 자동 수정 시도
    - |
      npm test 2>&1 | tee test-output.log || true

      if grep -q "FAIL" test-output.log; then
        echo "테스트 실패 감지 — Claude로 수정 시도"
        cat test-output.log | claude -p "이 테스트 실패를 분석하고 수정해줘" \\
          --allowedTools "Read,Edit,Bash(npm test)" \\
          --max-turns 10

        # 수정 후 재실행
        npm test
      fi
  rules:
    - if: $CI_MERGE_REQUEST_IID
  variables:
    ANTHROPIC_API_KEY: $ANTHROPIC_API_KEY`}
  language="yaml"
  filename="GitLab CI 통합"
/>

<MermaidDiagram
  chart={`flowchart TB
    subgraph TRIGGER["트리거"]
      PR["PR/MR 생성"]
      PUSH["코드 푸시"]
      SCHED["스케줄"]
      MANUAL["수동 실행"]
    end
    subgraph PIPELINE["CI/CD 파이프라인"]
      CHECKOUT["코드 체크아웃"]
      INSTALL["Claude Code 설치"]
      ANALYZE["코드 분석\nclaude -p ... --output-format json"]
      PARSE["결과 파싱\njq로 JSON 처리"]
      DECIDE{"기준 통과?"}
      PASS["성공"]
      FAIL["실패 + 알림"]
      FIX["자동 수정 시도"]
    end
    subgraph OUTPUT["산출물"]
      COMMENT["PR/MR 코멘트"]
      REPORT["분석 리포트"]
      COMMIT["수정 커밋"]
    end
    PR --> CHECKOUT
    PUSH --> CHECKOUT
    SCHED --> CHECKOUT
    MANUAL --> CHECKOUT
    CHECKOUT --> INSTALL --> ANALYZE --> PARSE --> DECIDE
    DECIDE -->|"통과"| PASS --> COMMENT
    DECIDE -->|"실패"| FAIL --> FIX
    FIX --> COMMIT
    ANALYZE --> REPORT
    style TRIGGER fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style PIPELINE fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style OUTPUT fill:#f0ece5,stroke:#16a34a,color:#2d2a26
    style DECIDE fill:#fff3e0,stroke:#d97706,color:#2d2a26`}
  title="CI/CD 파이프라인에서의 Claude Code 활용 흐름"
  caption="분석, 판단, 자동 수정까지 전체 파이프라인을 자동화할 수 있습니다"
/>

## 실전 자동화 스크립트 모음

### 1. 자동 코드 리뷰 스크립트

<CodeBlock
  code={`#!/bin/bash
# scripts/auto-review.sh — PR 변경사항 자동 리뷰

set -euo pipefail

# 변경된 파일 목록 가져오기
CHANGED_FILES=$(git diff --name-only origin/main...HEAD | grep -E '\\.(ts|js|py)$' || true)

if [ -z "$CHANGED_FILES" ]; then
  echo "리뷰할 코드 파일이 없습니다."
  exit 0
fi

echo "리뷰 대상 파일: $CHANGED_FILES"

# 변경사항과 함께 리뷰 요청
DIFF=$(git diff origin/main...HEAD -- $CHANGED_FILES)

RESULT=$(echo "$DIFF" | claude -p "다음 코드 변경사항을 리뷰해주세요.
보안 취약점, 성능 이슈, 코드 품질을 중점적으로 확인하세요.
각 이슈에 심각도(critical/warning/info)를 태그하세요." \\
  --output-format json \\
  --json-schema '{
    "type": "object",
    "properties": {
      "score": {"type": "number", "minimum": 0, "maximum": 100},
      "issues": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "severity": {"type": "string", "enum": ["critical", "warning", "info"]},
            "file": {"type": "string"},
            "description": {"type": "string"},
            "suggestion": {"type": "string"}
          },
          "required": ["severity", "file", "description"]
        }
      },
      "summary": {"type": "string"}
    },
    "required": ["score", "issues", "summary"]
  }' \\
  --allowedTools "Read,Glob,Grep" \\
  --max-turns 5)

# 결과 출력
PARSED=$(echo "$RESULT" | jq -r '.result | fromjson')
SCORE=$(echo "$PARSED" | jq '.score')
CRITICAL_COUNT=$(echo "$PARSED" | jq '[.issues[] | select(.severity == "critical")] | length')

echo "=== 코드 리뷰 결과 ==="
echo "점수: $SCORE/100"
echo "심각한 이슈: $CRITICAL_COUNT개"
echo "$PARSED" | jq -r '.summary'
echo ""
echo "$PARSED" | jq -r '.issues[] | "[\(.severity)] \(.file): \(.description)"'

# 심각한 이슈가 있으면 종료 코드 1
if [ "$CRITICAL_COUNT" -gt 0 ]; then
  exit 1
fi`}
  language="bash"
  filename="scripts/auto-review.sh"
/>

### 2. 자동 커밋 메시지 생성

<CodeBlock
  code={`#!/bin/bash
# scripts/auto-commit.sh — AI 기반 커밋 메시지 자동 생성

set -euo pipefail

# 스테이징된 변경사항 확인
STAGED=$(git diff --cached)

if [ -z "$STAGED" ]; then
  echo "스테이징된 변경사항이 없습니다."
  echo "git add로 파일을 먼저 스테이징하세요."
  exit 1
fi

# 커밋 메시지 생성
COMMIT_MSG=$(echo "$STAGED" | claude -p "이 git diff를 분석하고 \
Conventional Commits 형식의 커밋 메시지를 생성해주세요.
형식: <type>(<scope>): <subject>
type: feat, fix, docs, style, refactor, test, chore 중 선택
scope: 변경 범위 (선택사항)
subject: 변경 요약 (50자 이내)
본문에 상세 설명을 추가하세요.
한국어로 작성하세요." \\
  --output-format json \\
  --json-schema '{
    "type": "object",
    "properties": {
      "title": {"type": "string"},
      "body": {"type": "string"}
    },
    "required": ["title", "body"]
  }' \\
  --allowedTools "Read" \\
  --max-turns 2)

TITLE=$(echo "$COMMIT_MSG" | jq -r '.result | fromjson | .title')
BODY=$(echo "$COMMIT_MSG" | jq -r '.result | fromjson | .body')

echo "=== 생성된 커밋 메시지 ==="
echo "$TITLE"
echo ""
echo "$BODY"
echo ""

# 사용자 확인
read -p "이 메시지로 커밋하시겠습니까? (y/n): " CONFIRM
if [ "$CONFIRM" = "y" ]; then
  git commit -m "$TITLE" -m "$BODY"
  echo "커밋이 완료되었습니다."
else
  echo "커밋이 취소되었습니다."
fi`}
  language="bash"
  filename="scripts/auto-commit.sh"
/>

### 3. 에러 로그 모니터링 및 자동 알림

<CodeBlock
  code={`#!/bin/bash
# scripts/log-monitor.sh — 에러 로그 실시간 모니터링 + AI 분석

set -euo pipefail

LOG_FILE="\${1:-/var/log/app/error.log}"
SLACK_WEBHOOK="\${SLACK_WEBHOOK_URL}"
CHECK_INTERVAL=300  # 5분 간격

echo "로그 모니터링 시작: $LOG_FILE"

while true; do
  # 최근 5분간의 에러 로그 수집
  RECENT_ERRORS=$(find "$LOG_FILE" -newermt "5 minutes ago" -exec tail -100 {} \\; 2>/dev/null || true)

  if [ -n "$RECENT_ERRORS" ]; then
    echo "[$(date)] 새로운 에러 감지 — AI 분석 시작"

    # Claude로 에러 분석
    ANALYSIS=$(echo "$RECENT_ERRORS" | claude -p "이 에러 로그를 분석해주세요.
1. 에러 유형별 분류
2. 근본 원인 추정
3. 영향 범위 판단
4. 즉시 조치 사항 제안" \\
      --output-format json \\
      --json-schema '{
        "type": "object",
        "properties": {
          "severity": {"type": "string", "enum": ["critical", "high", "medium", "low"]},
          "error_types": {"type": "array", "items": {"type": "string"}},
          "root_cause": {"type": "string"},
          "impact": {"type": "string"},
          "action_items": {"type": "array", "items": {"type": "string"}}
        },
        "required": ["severity", "error_types", "root_cause", "impact", "action_items"]
      }' \\
      --allowedTools "Read" \\
      --max-turns 3)

    PARSED=$(echo "$ANALYSIS" | jq -r '.result | fromjson')
    SEVERITY=$(echo "$PARSED" | jq -r '.severity')

    # critical 또는 high 심각도일 때만 Slack 알림
    if [ "$SEVERITY" = "critical" ] || [ "$SEVERITY" = "high" ]; then
      SLACK_MSG=$(echo "$PARSED" | jq -r '"*['+.severity+'] 에러 감지*\n근본 원인: "+.root_cause+"\n영향: "+.impact+"\n조치사항:\n"+([.action_items[] | "• "+.] | join("\n"))')

      curl -s -X POST "$SLACK_WEBHOOK" \\
        -H 'Content-type: application/json' \\
        -d "{\\"text\\": $(echo "$SLACK_MSG" | jq -R -s .)}"

      echo "[$(date)] Slack 알림 전송 완료 (심각도: $SEVERITY)"
    fi
  fi

  sleep $CHECK_INTERVAL
done`}
  language="bash"
  filename="scripts/log-monitor.sh"
/>

### 4. PR 리뷰 자동화 (Agent SDK)

<CodeBlock
  code={`// scripts/pr-reviewer.ts — Agent SDK 기반 PR 리뷰 자동화
import { query } from "@anthropic-ai/claude-agent-sdk";
import { Octokit } from "@octokit/rest";

interface ReviewResult {
  score: number;
  issues: Array<{
    severity: "critical" | "warning" | "info";
    file: string;
    line?: number;
    description: string;
    suggestion?: string;
  }>;
  summary: string;
  approved: boolean;
}

async function reviewPR(owner: string, repo: string, prNumber: number) {
  const octokit = new Octokit({
    auth: process.env.GITHUB_TOKEN
  });

  // PR 정보 가져오기
  const { data: pr } = await octokit.pulls.get({
    owner, repo, pull_number: prNumber,
  });
  const { data: files } = await octokit.pulls.listFiles({
    owner, repo, pull_number: prNumber,
  });

  // 변경된 파일 내용 수집
  const changedFiles = files.map(f =>
    \`--- \${f.filename} ---\\n\${f.patch || "(binary)"}\`
  ).join("\\n\\n");

  // Claude로 리뷰
  const response = await query({
    prompt: \`다음 PR을 리뷰해주세요.

PR 제목: \${pr.title}
PR 설명: \${pr.body || "없음"}

변경 파일:
\${changedFiles}

보안, 성능, 코드 품질을 중점 검토하세요.\`,
    options: {
      maxTurns: 10,
      allowedTools: ["Read", "Glob", "Grep"],
      jsonSchema: {
        type: "object",
        properties: {
          score: { type: "number", minimum: 0, maximum: 100 },
          issues: {
            type: "array",
            items: {
              type: "object",
              properties: {
                severity: { type: "string",
                            enum: ["critical", "warning", "info"] },
                file: { type: "string" },
                line: { type: "number" },
                description: { type: "string" },
                suggestion: { type: "string" },
              },
              required: ["severity", "file", "description"],
            },
          },
          summary: { type: "string" },
          approved: { type: "boolean" },
        },
        required: ["score", "issues", "summary", "approved"],
      },
    },
  });

  // 결과 파싱
  const lastMsg = response.messages
    .filter(m => m.role === "assistant").pop();
  const textBlock = lastMsg?.content.find(b => b.type === "text");
  const review: ReviewResult = JSON.parse(textBlock?.text || "{}");

  // PR에 리뷰 코멘트 작성
  const reviewBody = \`## AI 코드 리뷰 결과

**점수**: \${review.score}/100
**승인**: \${review.approved ? "승인" : "변경 요청"}

### 요약
\${review.summary}

### 발견된 이슈
\${review.issues.map(i =>
  \`- **[\${i.severity.toUpperCase()}]** \${i.file}\${i.line ? \`:\${i.line}\` : ""}: \${i.description}\${i.suggestion ? \`\\n  > 제안: \${i.suggestion}\` : ""}\`
).join("\\n")}

---
*비용: \${response.costUsd} USD*\`;

  await octokit.pulls.createReview({
    owner, repo, pull_number: prNumber,
    body: reviewBody,
    event: review.approved ? "APPROVE" : "REQUEST_CHANGES",
  });

  console.log(\`PR #\${prNumber} 리뷰 완료 (점수: \${review.score})\`);
  return review;
}

// 실행
const [owner, repo, prNum] = process.argv.slice(2);
reviewPR(owner, repo, parseInt(prNum));`}
  language="typescript"
  filename="scripts/pr-reviewer.ts"
/>

### 5. 번역 자동화

<CodeBlock
  code={`#!/bin/bash
# scripts/auto-translate.sh — i18n 번역 파일 자동 생성

set -euo pipefail

SOURCE_LANG="ko"
SOURCE_FILE="locales/$SOURCE_LANG/messages.json"
TARGET_LANGS=("en" "ja" "zh")

for LANG in "\${TARGET_LANGS[@]}"; do
  TARGET_FILE="locales/$LANG/messages.json"
  echo "번역 중: $SOURCE_LANG -> $LANG"

  RESULT=$(cat "$SOURCE_FILE" | claude -p "이 JSON 파일의 값을 \
$SOURCE_LANG에서 $LANG으로 번역해주세요.
키는 변경하지 말고 값만 번역하세요.
기술 용어는 적절히 로컬라이징하세요.
플레이스홀더({name}, {count} 등)는 그대로 유지하세요." \\
    --output-format json \\
    --json-schema '{
      "type": "object",
      "additionalProperties": {"type": "string"}
    }' \\
    --allowedTools "Read" \\
    --max-turns 2)

  # 번역 결과를 파일로 저장
  echo "$RESULT" | jq -r '.result | fromjson' > "$TARGET_FILE"
  echo "완료: $TARGET_FILE"
done

echo "=== 모든 번역 완료 ==="
echo "번역된 파일:"
for LANG in "\${TARGET_LANGS[@]}"; do
  echo "  - locales/$LANG/messages.json"
done`}
  language="bash"
  filename="scripts/auto-translate.sh"
/>

### 6. 테스트 자동 생성 및 수정

<CodeBlock
  code={`#!/bin/bash
# scripts/auto-test.sh — 테스트 자동 생성 + 실패 시 자동 수정

set -euo pipefail

TARGET_FILE="\${1:?사용법: ./auto-test.sh <파일경로>}"
TEST_FILE="\${TARGET_FILE%.ts}.test.ts"

echo "=== 테스트 자동 생성 ==="
echo "대상: $TARGET_FILE"
echo "테스트: $TEST_FILE"

# 1단계: 테스트 생성
claude -p "$TARGET_FILE 파일에 대한 단위 테스트를 작성해주세요.
Jest를 사용하고, 정상 케이스와 엣지 케이스를 모두 포함하세요.
테스트 파일을 $TEST_FILE에 저장하세요." \\
  --allowedTools "Read,Edit,Glob" \\
  --max-turns 10 \\
  --output-format json > /tmp/test-gen-result.json

SESSION_ID=$(jq -r '.session_id' /tmp/test-gen-result.json)
echo "세션 ID: $SESSION_ID"

# 2단계: 테스트 실행
echo "=== 테스트 실행 ==="
MAX_RETRIES=3
RETRY=0

while [ $RETRY -lt $MAX_RETRIES ]; do
  if npx jest "$TEST_FILE" --no-coverage 2>&1 | tee /tmp/test-output.log; then
    echo "모든 테스트 통과!"
    exit 0
  fi

  RETRY=$((RETRY + 1))
  echo "테스트 실패 (시도 $RETRY/$MAX_RETRIES) — 자동 수정 중..."

  # 실패한 테스트를 Claude에게 수정 요청 (이전 세션 이어서)
  cat /tmp/test-output.log | claude -p "이 테스트 실패를 분석하고 수정해주세요.
테스트 코드나 소스 코드 중 적절한 쪽을 수정하세요." \\
    --resume "$SESSION_ID" \\
    --allowedTools "Read,Edit" \\
    --max-turns 5
done

echo "최대 재시도 횟수 초과 — 수동 확인이 필요합니다."
exit 1`}
  language="bash"
  filename="scripts/auto-test.sh"
/>

### 7. 문서 자동 생성

<CodeBlock
  code={`#!/bin/bash
# scripts/auto-docs.sh — API 문서 자동 생성/갱신

set -euo pipefail

API_DIR="\${1:-src/api}"
DOCS_DIR="docs/api"

echo "=== API 문서 자동 생성 ==="
echo "API 소스: $API_DIR"
echo "문서 출력: $DOCS_DIR"

mkdir -p "$DOCS_DIR"

# API 파일 목록
API_FILES=$(find "$API_DIR" -name "*.ts" -o -name "*.py" | sort)

for FILE in $API_FILES; do
  BASENAME=$(basename "$FILE" | sed 's/\\.[^.]*$//')
  DOC_FILE="$DOCS_DIR/$BASENAME.md"

  echo "문서 생성: $FILE -> $DOC_FILE"

  cat "$FILE" | claude -p "이 API 소스 코드를 분석하고 \
API 문서를 Markdown 형식으로 생성해주세요.
포함 내용:
- 엔드포인트 URL과 메서드
- 요청 파라미터 (타입, 필수 여부, 설명)
- 응답 형식 (상태 코드별)
- 사용 예시 (curl 명령어)
- 에러 케이스
한국어로 작성하세요." \\
    --output-format text \\
    --allowedTools "Read" \\
    --max-turns 3 > "$DOC_FILE"
done

echo "=== 문서 생성 완료 ==="
echo "생성된 문서 파일:"
ls -la "$DOCS_DIR"/*.md`}
  language="bash"
  filename="scripts/auto-docs.sh"
/>

### 8. 의존성 취약점 분석

<CodeBlock
  code={`#!/bin/bash
# scripts/dependency-audit.sh — 의존성 보안 감사 + AI 분석

set -euo pipefail

echo "=== 의존성 보안 감사 ==="

# npm audit 실행
npm audit --json > /tmp/audit-result.json 2>/dev/null || true

VULN_COUNT=$(jq '.metadata.vulnerabilities | to_entries | map(.value) | add' /tmp/audit-result.json)

if [ "$VULN_COUNT" = "0" ] || [ "$VULN_COUNT" = "null" ]; then
  echo "취약점이 발견되지 않았습니다."
  exit 0
fi

echo "발견된 취약점: $VULN_COUNT개"

# Claude로 취약점 분석 및 수정 가이드 생성
ANALYSIS=$(cat /tmp/audit-result.json | claude -p "이 npm audit 결과를 분석해주세요.
1. 각 취약점의 위험도와 영향 범위
2. 우선 수정 순서 (비즈니스 영향 기준)
3. 각 취약점의 구체적 수정 방법
4. 수정 시 호환성 주의사항" \\
  --output-format json \\
  --json-schema '{
    "type": "object",
    "properties": {
      "total_vulnerabilities": {"type": "number"},
      "risk_level": {"type": "string", "enum": ["critical", "high", "medium", "low"]},
      "vulnerabilities": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "package": {"type": "string"},
            "severity": {"type": "string"},
            "fix_command": {"type": "string"},
            "breaking_changes": {"type": "boolean"},
            "notes": {"type": "string"}
          },
          "required": ["package", "severity", "fix_command"]
        }
      },
      "recommended_action": {"type": "string"}
    },
    "required": ["total_vulnerabilities", "risk_level", "vulnerabilities", "recommended_action"]
  }' \\
  --allowedTools "Read" \\
  --max-turns 3)

PARSED=$(echo "$ANALYSIS" | jq -r '.result | fromjson')
RISK=$(echo "$PARSED" | jq -r '.risk_level')

echo "=== 분석 결과 ==="
echo "전체 위험도: $RISK"
echo ""
echo "$PARSED" | jq -r '.vulnerabilities[] | "[\(.severity)] \(.package): \(.fix_command)\(.notes // "" | if . != "" then " (\(.))" else "" end)"'
echo ""
echo "권장 조치: $(echo "$PARSED" | jq -r '.recommended_action')"

# critical 취약점이 있으면 종료 코드 1
if [ "$RISK" = "critical" ]; then
  exit 1
fi`}
  language="bash"
  filename="scripts/dependency-audit.sh"
/>

### 9. 데이터베이스 마이그레이션 검증

<CodeBlock
  code={`#!/bin/bash
# scripts/migration-check.sh — DB 마이그레이션 파일 안전성 검증

set -euo pipefail

MIGRATION_DIR="\${1:-migrations}"

echo "=== 마이그레이션 검증 ==="

# 새로운 마이그레이션 파일 찾기
NEW_MIGRATIONS=$(git diff --name-only origin/main...HEAD -- "$MIGRATION_DIR" || true)

if [ -z "$NEW_MIGRATIONS" ]; then
  echo "새로운 마이그레이션이 없습니다."
  exit 0
fi

echo "검증 대상:"
echo "$NEW_MIGRATIONS"

# 각 마이그레이션 파일 검증
for FILE in $NEW_MIGRATIONS; do
  echo ""
  echo "--- 검증 중: $FILE ---"

  RESULT=$(cat "$FILE" | claude -p "이 데이터베이스 마이그레이션을 검증해주세요.
확인 항목:
1. 되돌리기(rollback) 가능 여부
2. 데이터 손실 위험
3. 잠금(lock) 발생 가능성
4. 대용량 테이블에 대한 성능 영향
5. 프로덕션 안전성" \\
    --output-format json \\
    --json-schema '{
      "type": "object",
      "properties": {
        "safe": {"type": "boolean"},
        "rollback_possible": {"type": "boolean"},
        "data_loss_risk": {"type": "boolean"},
        "lock_risk": {"type": "string", "enum": ["none", "low", "medium", "high"]},
        "warnings": {"type": "array", "items": {"type": "string"}},
        "suggestions": {"type": "array", "items": {"type": "string"}}
      },
      "required": ["safe", "rollback_possible", "data_loss_risk", "lock_risk", "warnings"]
    }' \\
    --allowedTools "Read" \\
    --max-turns 3)

  PARSED=$(echo "$RESULT" | jq -r '.result | fromjson')
  SAFE=$(echo "$PARSED" | jq -r '.safe')
  LOCK_RISK=$(echo "$PARSED" | jq -r '.lock_risk')

  if [ "$SAFE" = "false" ]; then
    echo "** 위험: 이 마이그레이션은 안전하지 않습니다 **"
    echo "$PARSED" | jq -r '.warnings[] | "  - " + .'
    echo ""
    echo "제안:"
    echo "$PARSED" | jq -r '.suggestions[] | "  - " + .'
    exit 1
  fi

  echo "안전성: 통과 (잠금 위험: $LOCK_RISK)"
done

echo ""
echo "=== 모든 마이그레이션 검증 통과 ==="
`}
  language="bash"
  filename="scripts/migration-check.sh"
/>

### 10. 코드베이스 건강도 리포트

<CodeBlock
  code={`// scripts/health-report.ts — Agent SDK 기반 코드 건강도 리포트
import { query } from "@anthropic-ai/claude-agent-sdk";
import * as fs from "fs";

interface HealthReport {
  overallScore: number;
  categories: {
    security: { score: number; issues: string[] };
    performance: { score: number; issues: string[] };
    maintainability: { score: number; issues: string[] };
    testCoverage: { score: number; issues: string[] };
    documentation: { score: number; issues: string[] };
  };
  recommendations: string[];
  trend: "improving" | "stable" | "declining";
}

async function generateHealthReport(): Promise<HealthReport> {
  const response = await query({
    prompt: \`프로젝트 전체의 코드 건강도를 분석해주세요.

다음 영역을 평가하세요:
1. 보안 (security): 취약점, 안전하지 않은 패턴
2. 성능 (performance): 비효율적 코드, N+1 쿼리 등
3. 유지보수성 (maintainability): 복잡도, 중복, 결합도
4. 테스트 커버리지 (testCoverage): 테스트 파일 유무, 커버리지
5. 문서화 (documentation): JSDoc, README 등

src/ 디렉토리를 분석하세요.\`,
    options: {
      maxTurns: 20,
      allowedTools: ["Read", "Glob", "Grep", "Bash(wc -l)"],
      jsonSchema: {
        type: "object",
        properties: {
          overallScore: { type: "number" },
          categories: {
            type: "object",
            properties: {
              security: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  issues: { type: "array", items: { type: "string" } },
                },
                required: ["score", "issues"],
              },
              performance: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  issues: { type: "array", items: { type: "string" } },
                },
                required: ["score", "issues"],
              },
              maintainability: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  issues: { type: "array", items: { type: "string" } },
                },
                required: ["score", "issues"],
              },
              testCoverage: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  issues: { type: "array", items: { type: "string" } },
                },
                required: ["score", "issues"],
              },
              documentation: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  issues: { type: "array", items: { type: "string" } },
                },
                required: ["score", "issues"],
              },
            },
            required: ["security", "performance",
                        "maintainability", "testCoverage",
                        "documentation"],
          },
          recommendations: { type: "array", items: { type: "string" } },
          trend: { type: "string",
                   enum: ["improving", "stable", "declining"] },
        },
        required: ["overallScore", "categories",
                    "recommendations", "trend"],
      },
    },
  });

  const lastMsg = response.messages
    .filter(m => m.role === "assistant").pop();
  const text = lastMsg?.content.find(b => b.type === "text")?.text;
  const report: HealthReport = JSON.parse(text || "{}");

  // 리포트 저장
  const reportDate = new Date().toISOString().split("T")[0];
  const reportPath = \`reports/health-\${reportDate}.json\`;
  fs.mkdirSync("reports", { recursive: true });
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

  // 콘솔 출력
  console.log("=== 코드 건강도 리포트 ===");
  console.log(\`전체 점수: \${report.overallScore}/100\`);
  console.log(\`추세: \${report.trend}\`);
  console.log("");

  const cats = report.categories;
  for (const [name, data] of Object.entries(cats)) {
    console.log(\`\${name}: \${data.score}/100\`);
    data.issues.forEach(issue =>
      console.log(\`  - \${issue}\`)
    );
  }

  console.log("\\n권장 사항:");
  report.recommendations.forEach((rec, i) =>
    console.log(\`\${i + 1}. \${rec}\`)
  );

  console.log(\`\\n비용: \${response.costUsd} USD\`);
  console.log(\`리포트 저장: \${reportPath}\`);

  return report;
}

generateHealthReport();`}
  language="typescript"
  filename="scripts/health-report.ts"
/>

## 고급 패턴

### 멀티 에이전트 파이프라인

여러 Claude 인스턴스를 체이닝하여 복잡한 작업을 분담하는 패턴입니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph STAGE1["1단계: 분석"]
      A1["분석 에이전트\n(Sonnet)"]
    end
    subgraph STAGE2["2단계: 실행"]
      A2["코딩 에이전트\n(Sonnet)"]
      A3["테스트 에이전트\n(Sonnet)"]
    end
    subgraph STAGE3["3단계: 검증"]
      A4["리뷰 에이전트\n(Opus)"]
    end
    INPUT["작업 요청"] --> A1
    A1 -->|"분석 결과"| A2
    A1 -->|"분석 결과"| A3
    A2 -->|"코드 변경"| A4
    A3 -->|"테스트 결과"| A4
    A4 --> OUTPUT["최종 결과"]
    style STAGE1 fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style STAGE2 fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style STAGE3 fill:#e8f5e9,stroke:#16a34a,color:#2d2a26
    style INPUT fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style OUTPUT fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26`}
  title="멀티 에이전트 파이프라인"
  caption="분석, 실행, 검증 단계를 서로 다른 에이전트가 담당합니다"
/>

<CodeBlock
  code={`// scripts/multi-agent-pipeline.ts — 멀티 에이전트 파이프라인
import { query } from "@anthropic-ai/claude-agent-sdk";

async function multiAgentPipeline(task: string) {
  console.log("=== 멀티 에이전트 파이프라인 시작 ===");

  // 1단계: 분석 에이전트 — 작업 분해
  console.log("[1/3] 분석 에이전트 실행...");
  const analysisResult = await query({
    prompt: \`다음 작업을 분석하고 세부 실행 계획을 수립해주세요.
작업: \${task}

코드베이스를 분석하여:
1. 변경이 필요한 파일 목록
2. 각 파일의 변경 내용
3. 예상 테스트 범위
를 JSON으로 반환하세요.\`,
    options: {
      model: "claude-sonnet-4-20250514",
      maxTurns: 10,
      allowedTools: ["Read", "Glob", "Grep"],
      jsonSchema: {
        type: "object",
        properties: {
          files_to_change: {
            type: "array",
            items: {
              type: "object",
              properties: {
                path: { type: "string" },
                changes: { type: "string" },
              },
              required: ["path", "changes"],
            },
          },
          test_scope: { type: "array", items: { type: "string" } },
          risk_assessment: { type: "string" },
        },
        required: ["files_to_change", "test_scope", "risk_assessment"],
      },
    },
  });

  const analysis = JSON.parse(
    analysisResult.messages
      .filter(m => m.role === "assistant").pop()
      ?.content.find(b => b.type === "text")?.text || "{}"
  );

  console.log(\`  변경 파일: \${analysis.files_to_change.length}개\`);
  console.log(\`  위험도: \${analysis.risk_assessment}\`);

  // 2단계: 코딩 에이전트 — 코드 변경 실행
  console.log("[2/3] 코딩 에이전트 실행...");
  const codingResult = await query({
    prompt: \`다음 분석 결과를 바탕으로 코드를 수정해주세요.

변경 계획:
\${JSON.stringify(analysis.files_to_change, null, 2)}

각 파일을 계획대로 수정하고, 테스트도 함께 작성하세요.\`,
    options: {
      model: "claude-sonnet-4-20250514",
      maxTurns: 20,
      allowedTools: ["Read", "Edit", "Glob", "Bash(npm test)"],
    },
  });

  // 3단계: 리뷰 에이전트 — 변경 검증
  console.log("[3/3] 리뷰 에이전트 실행...");
  const reviewResult = await query({
    prompt: \`방금 수행된 코드 변경사항을 검증해주세요.

원래 작업: \${task}
변경 계획: \${JSON.stringify(analysis.files_to_change, null, 2)}

실제 변경된 파일을 확인하고:
1. 계획대로 구현되었는지 검증
2. 보안 취약점이 없는지 확인
3. 테스트가 충분한지 평가
4. 최종 승인 여부를 판단해주세요.\`,
    options: {
      model: "claude-opus-4-20250918",
      maxTurns: 10,
      allowedTools: ["Read", "Glob", "Grep", "Bash(npm test)"],
      jsonSchema: {
        type: "object",
        properties: {
          approved: { type: "boolean" },
          issues: { type: "array", items: { type: "string" } },
          summary: { type: "string" },
        },
        required: ["approved", "issues", "summary"],
      },
    },
  });

  const review = JSON.parse(
    reviewResult.messages
      .filter(m => m.role === "assistant").pop()
      ?.content.find(b => b.type === "text")?.text || "{}"
  );

  // 총 비용 계산
  const totalCost = analysisResult.costUsd
    + codingResult.costUsd
    + reviewResult.costUsd;

  console.log("\\n=== 파이프라인 완료 ===");
  console.log(\`승인: \${review.approved ? "통과" : "거부"}\`);
  console.log(\`요약: \${review.summary}\`);
  console.log(\`총 비용: \${totalCost.toFixed(4)} USD\`);

  return review;
}

// 실행
const task = process.argv[2] || "인증 모듈에 refresh token 지원을 추가해주세요";
multiAgentPipeline(task);`}
  language="typescript"
  filename="scripts/multi-agent-pipeline.ts"
/>

### 조건부 도구 승인 패턴

Agent SDK의 도구 승인 콜백을 활용하여 상황에 따라 동적으로 도구 사용을 제어하는 패턴입니다.

<CodeBlock
  code={`// scripts/conditional-approval.ts
import { query, type ToolUseBlock } from "@anthropic-ai/claude-agent-sdk";

// 프로덕션 안전 모드 — 위험한 작업을 점진적으로 제어
async function productionSafeMode() {
  let editCount = 0;
  const MAX_EDITS = 5;

  const response = await query({
    prompt: "프로젝트의 코드 품질을 개선해줘",
    options: {
      maxTurns: 20,
      toolApprovalCallback: async (toolUse: ToolUseBlock) => {
        const input = toolUse.input as Record<string, unknown>;

        // 1. 읽기 전용 도구 — 항상 승인
        if (["Read", "Glob", "Grep"].includes(toolUse.name)) {
          return { approved: true };
        }

        // 2. Edit 도구 — 횟수 제한
        if (toolUse.name === "Edit") {
          editCount++;
          if (editCount > MAX_EDITS) {
            return {
              approved: false,
              reason: \`최대 편집 횟수(\${MAX_EDITS})에 도달했습니다\`,
            };
          }

          // 핵심 파일 수정 차단
          const filePath = input.file_path as string;
          const protectedPaths = [
            "package.json",
            "tsconfig.json",
            ".env",
            "docker-compose.yml",
          ];
          if (protectedPaths.some(p => filePath.endsWith(p))) {
            return {
              approved: false,
              reason: \`설정 파일(\${filePath})은 수정할 수 없습니다\`,
            };
          }

          return { approved: true };
        }

        // 3. Bash 도구 — 화이트리스트 기반
        if (toolUse.name === "Bash") {
          const command = input.command as string;
          const allowedCommands = [
            /^npm test/,
            /^npm run lint/,
            /^npx jest/,
            /^git diff/,
            /^git status/,
            /^wc -l/,
          ];

          const isAllowed = allowedCommands
            .some(pattern => pattern.test(command));

          if (!isAllowed) {
            return {
              approved: false,
              reason: \`허용되지 않은 명령어: \${command}\`,
            };
          }
          return { approved: true };
        }

        // 4. 기타 도구 — 기본 거부
        return {
          approved: false,
          reason: \`알 수 없는 도구: \${toolUse.name}\`,
        };
      },
    },
  });

  console.log(\`편집 횟수: \${editCount}/\${MAX_EDITS}\`);
  return response;
}`}
  language="typescript"
  filename="scripts/conditional-approval.ts"
/>

## 보안 고려사항

<Callout type="warning" title="비대화형 모드 보안 체크리스트">
  Headless 모드와 Agent SDK를 사용할 때는 대화형 모드보다 더 엄격한 보안 관리가 필요합니다.
  사람의 실시간 감독 없이 실행되므로, 사전에 안전장치를 철저히 구성해야 합니다.
</Callout>

### API 키 관리

<CodeBlock
  code={`# 절대 금지 — 코드에 API 키 하드코딩
# claude -p "..." --api-key "sk-ant-api03-..."  # NEVER!

# 올바른 방법 1: 환경 변수
export ANTHROPIC_API_KEY="sk-ant-api03-..."
claude -p "분석해줘"

# 올바른 방법 2: .env 파일 (gitignore에 추가)
# .env 파일에서 로드
source .env
claude -p "분석해줘"

# 올바른 방법 3: CI/CD 시크릿 매니저
# GitHub Actions: secrets.ANTHROPIC_API_KEY
# GitLab CI: $ANTHROPIC_API_KEY (변수 설정)
# AWS: SSM Parameter Store / Secrets Manager

# 올바른 방법 4: 1Password CLI 등 시크릿 매니저
ANTHROPIC_API_KEY=$(op read "op://Development/Anthropic/API_KEY")
claude -p "분석해줘"`}
  language="bash"
  filename="API 키 안전한 관리"
/>

### 실행 환경 격리

<CodeBlock
  code={`# Docker로 격리된 환경에서 실행
docker run --rm \\
  -v "$(pwd):/workspace" \\
  -w /workspace \\
  -e ANTHROPIC_API_KEY \\
  --network=none \\
  --read-only \\
  --tmpfs /tmp \\
  node:20 bash -c "
    npm install -g @anthropic-ai/claude-agent-sdk &&
    claude -p '코드를 분석해줘' \\
      --allowedTools 'Read,Glob,Grep' \\
      --max-turns 5
  "

# 보안 강화 옵션:
# --network=none     : 네트워크 접근 차단
# --read-only        : 파일시스템 읽기 전용
# --tmpfs /tmp       : 임시 파일만 쓰기 허용
# -v "$(pwd):/workspace" : 작업 디렉토리만 마운트`}
  language="bash"
  filename="Docker 격리 실행"
/>

### 비용 제어 전략

<CodeBlock
  code={`#!/bin/bash
# scripts/cost-controlled-run.sh — 비용 제한이 있는 실행

set -euo pipefail

MAX_COST_USD="\${MAX_COST_USD:-1.00}"
TASK="\$1"

echo "작업: $TASK"
echo "비용 한도: \$$MAX_COST_USD"

# 1단계: 비용 추정 (짧은 분석)
ESTIMATE=$(claude -p "다음 작업의 예상 복잡도를 판단해주세요: $TASK" \\
  --output-format json \\
  --json-schema '{
    "type": "object",
    "properties": {
      "complexity": {"type": "string", "enum": ["low", "medium", "high"]},
      "estimated_turns": {"type": "number"},
      "recommended_model": {"type": "string"}
    },
    "required": ["complexity", "estimated_turns", "recommended_model"]
  }' \\
  --allowedTools "Read,Glob" \\
  --max-turns 2)

COMPLEXITY=$(echo "$ESTIMATE" | jq -r '.result | fromjson | .complexity')
EST_TURNS=$(echo "$ESTIMATE" | jq -r '.result | fromjson | .estimated_turns')
ESTIMATE_COST=$(echo "$ESTIMATE" | jq -r '.cost_usd')

echo "복잡도: $COMPLEXITY"
echo "예상 턴 수: $EST_TURNS"
echo "추정 단계 비용: \$$ESTIMATE_COST"

# 복잡도에 따라 모델과 턴 수 조정
case "$COMPLEXITY" in
  "low")
    MODEL="claude-sonnet-4-20250514"
    MAX_TURNS=$((EST_TURNS + 2))
    ;;
  "medium")
    MODEL="claude-sonnet-4-20250514"
    MAX_TURNS=$((EST_TURNS + 5))
    ;;
  "high")
    MODEL="claude-opus-4-20250918"
    MAX_TURNS=$((EST_TURNS + 10))
    ;;
esac

echo "선택 모델: $MODEL"
echo "최대 턴: $MAX_TURNS"

# 2단계: 실제 실행
RESULT=$(claude -p "$TASK" \\
  --model "$MODEL" \\
  --max-turns "$MAX_TURNS" \\
  --output-format json \\
  --allowedTools "Read,Edit,Bash(npm test)")

ACTUAL_COST=$(echo "$RESULT" | jq -r '.cost_usd')
echo ""
echo "=== 실행 완료 ==="
echo "실제 비용: \$$ACTUAL_COST"`}
  language="bash"
  filename="scripts/cost-controlled-run.sh"
/>

<ComparisonTable
  title="보안 체크리스트"
  headers={['항목', '필수 조치', '위험 시 영향']}
  rows={[
    { feature: 'API 키', values: ['환경 변수 또는 시크릿 매니저 사용', 'API 키 유출, 비용 폭발'] },
    { feature: '도구 제한', values: ['--allowedTools로 최소 권한 부여', '임의 파일 삭제, 코드 실행'] },
    { feature: '네트워크', values: ['CI에서 네트워크 접근 제한', '데이터 유출, 외부 공격'] },
    { feature: '턴 수 제한', values: ['--max-turns로 무한 루프 방지', '비용 폭발, 리소스 고갈'] },
    { feature: '실행 환경', values: ['Docker 컨테이너 격리', '호스트 시스템 침해'] },
    { feature: '입력 검증', values: ['프롬프트에 사용자 입력 직접 삽입 금지', '프롬프트 인젝션'] },
    { feature: '출력 검증', values: ['JSON Schema로 출력 형식 강제', '예기치 않은 동작'] },
    { feature: '로깅', values: ['모든 실행 로그 저장', '감사 추적 불가'] },
  ]}
/>

## 실전 아키텍처 패턴

### 이벤트 기반 자동화 아키텍처

<MermaidDiagram
  chart={`flowchart TB
    subgraph EVENTS["이벤트 소스"]
      GH_EVENT["GitHub Webhook"]
      SLACK_EVENT["Slack 이벤트"]
      CRON["크론 스케줄"]
      ALERT["모니터링 알림"]
    end
    subgraph ROUTER["이벤트 라우터"]
      QUEUE["메시지 큐\n(SQS / RabbitMQ)"]
      DISPATCHER["디스패처"]
    end
    subgraph AGENTS["Claude 에이전트 풀"]
      REVIEW_AGENT["리뷰 에이전트"]
      FIX_AGENT["수정 에이전트"]
      REPORT_AGENT["리포트 에이전트"]
      TRIAGE_AGENT["분류 에이전트"]
    end
    subgraph ACTIONS["후속 조치"]
      GH_COMMENT["GitHub 코멘트"]
      SLACK_MSG["Slack 메시지"]
      JIRA_TICKET["Jira 티켓"]
      EMAIL["이메일 알림"]
    end
    GH_EVENT --> QUEUE
    SLACK_EVENT --> QUEUE
    CRON --> QUEUE
    ALERT --> QUEUE
    QUEUE --> DISPATCHER
    DISPATCHER --> REVIEW_AGENT
    DISPATCHER --> FIX_AGENT
    DISPATCHER --> REPORT_AGENT
    DISPATCHER --> TRIAGE_AGENT
    REVIEW_AGENT --> GH_COMMENT
    FIX_AGENT --> GH_COMMENT
    REPORT_AGENT --> SLACK_MSG
    TRIAGE_AGENT --> JIRA_TICKET
    REPORT_AGENT --> EMAIL
    style EVENTS fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style ROUTER fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style AGENTS fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26
    style ACTIONS fill:#e8f5e9,stroke:#16a34a,color:#2d2a26`}
  title="이벤트 기반 자동화 아키텍처"
  caption="다양한 이벤트를 수신하여 적절한 Claude 에이전트에게 라우팅하고 후속 조치를 수행합니다"
/>

### 비용 대비 효과 분석

<ComparisonTable
  title="자동화 대상별 ROI 분석"
  headers={['자동화 대상', '수동 작업 시간', 'Claude 비용 (1회)', '월간 절감 효과']}
  rows={[
    { feature: 'PR 코드 리뷰', values: ['30분/건', '~$0.05', '40시간 절감 (80건 기준)'] },
    { feature: '커밋 메시지 생성', values: ['5분/건', '~$0.01', '8시간 절감 (100건 기준)'] },
    { feature: '이슈 분류', values: ['10분/건', '~$0.02', '5시간 절감 (30건 기준)'] },
    { feature: '테스트 생성', values: ['1시간/파일', '~$0.10', '20시간 절감 (20파일 기준)'] },
    { feature: '버그 수정 (단순)', values: ['2시간/건', '~$0.15', '16시간 절감 (8건 기준)'] },
    { feature: '문서 갱신', values: ['30분/건', '~$0.05', '10시간 절감 (20건 기준)'] },
    { feature: '의존성 감사', values: ['1시간/주', '~$0.10', '4시간 절감'] },
    { feature: '마이그레이션 검증', values: ['45분/건', '~$0.08', '6시간 절감 (8건 기준)'] },
  ]}
/>

## 트러블슈팅

### 자주 발생하는 문제와 해결

<CodeBlock
  code={`# 문제 1: "Permission denied" 에러
# 원인: --allowedTools에 필요한 도구가 빠짐
# 해결:
claude -p "파일을 수정해줘" --allowedTools "Read,Edit,Glob"
#                                          ^^^^^ Edit 추가

# 문제 2: JSON 파싱 에러
# 원인: --json-schema와 --output-format json 둘 다 필요
# 해결:
claude -p "분석해줘" \\
  --output-format json \\
  --json-schema '{"type":"object","properties":{"score":{"type":"number"}}}'

# 문제 3: 세션 재개 실패
# 원인: 세션 ID가 만료되었거나 잘못됨
# 해결: --output-format json에서 session_id를 확인
RESULT=$(claude -p "분석해줘" --output-format json)
echo "$RESULT" | jq '.session_id'

# 문제 4: 비용 초과
# 원인: max-turns 미설정, 복잡한 작업
# 해결:
claude -p "작업해줘" --max-turns 10 --model claude-sonnet-4-20250514

# 문제 5: 타임아웃
# 원인: 작업이 너무 오래 걸림
# 해결: 작업을 분할하거나 timeout 설정
timeout 300 claude -p "간단한 분석해줘" --max-turns 5

# 문제 6: stdin 파이프 문제
# 원인: 바이너리 데이터 또는 너무 큰 입력
# 해결: 텍스트만 전달, 크기 제한
head -1000 large-file.log | claude -p "최근 에러를 분석해줘"`}
  language="bash"
  filename="트러블슈팅 가이드"
/>

## CLI 옵션 전체 레퍼런스

<ComparisonTable
  title="Headless 모드 주요 CLI 옵션"
  headers={['옵션', '설명', '예시']}
  rows={[
    { feature: '-p, --print', values: ['비대화형 모드로 실행', 'claude -p "분석해줘"'] },
    { feature: '--output-format', values: ['출력 형식 (text/json/stream-json)', '--output-format json'] },
    { feature: '--json-schema', values: ['JSON Schema로 구조화 출력', '--json-schema \'{"type":"object"}\''] },
    { feature: '--allowedTools', values: ['자동 승인할 도구 목록', '--allowedTools "Read,Edit"'] },
    { feature: '--disallowedTools', values: ['차단할 도구 목록', '--disallowedTools "Bash"'] },
    { feature: '--max-turns', values: ['최대 에이전트 턴 수', '--max-turns 10'] },
    { feature: '--model', values: ['사용할 모델 지정', '--model claude-sonnet-4-20250514'] },
    { feature: '--continue', values: ['가장 최근 대화 이어서', '--continue'] },
    { feature: '--resume', values: ['특정 세션 재개', '--resume "session-id"'] },
    { feature: '--system-prompt', values: ['시스템 프롬프트 교체', '--system-prompt "역할 설명"'] },
    { feature: '--append-system-prompt', values: ['시스템 프롬프트 추가', '--append-system-prompt "추가 지시"'] },
    { feature: '--dangerously-skip-permissions', values: ['모든 도구 자동 승인', '(CI/CD 전용)'] },
  ]}
/>

## 요약

<Callout type="tip" title="핵심 정리">
  **-p 플래그**는 가장 간편한 비대화형 실행 방법으로, 셸 스크립트와 CI/CD에 이상적입니다.
  **Agent SDK**는 Python/TypeScript에서 더 정교한 제어 (도구 승인 콜백, 스트리밍, 멀티 에이전트)가 필요할 때 사용합니다.
  두 방식 모두 JSON Schema 기반 구조화 출력을 지원하여, 자동화 파이프라인에서 결과를 프로그래밍적으로 처리할 수 있습니다.
</Callout>

<ChapterNav
  prev={{ title: 'MCP 서버 활용', path: '/docs/part-4--mcp와-자동화-mcp-서버-활용' }}
/>
