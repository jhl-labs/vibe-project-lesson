import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 1: 기초/Claude Code란?" />

# Claude Code란?

> Anthropic이 만든 터미널 기반 AI 코딩 에이전트

## 개요

**Claude Code**는 Anthropic이 개발한 **CLI(Command Line Interface) 기반의 AI 코딩 에이전트**입니다. 2025년 2월 리서치 프리뷰로 공개된 뒤 **2025년 5월 22일 GA(1.0.0)로 출시**되었고, 2025년 10월 20일 웹 버전이 추가되었습니다. 터미널에서 직접 실행하여 파일 시스템 접근, 코드 생성/수정, Git 작업, 테스트 실행 등 개발 워크플로우 전반을 자율적으로 수행합니다.

<Callout type="info" title="핵심 포인트">
  Claude Code는 단순한 코드 자동완성 도구가 아닙니다.
  프로젝트의 전체 컨텍스트를 이해하고, 자율적으로 작업을 수행할 수 있는 **AI 에이전트**입니다.
  2025년 한 해 동안 **150개 이상의 버전 업데이트**가 배포되었습니다(1.0.0~1.153.0, 7월 29일 기준).
</Callout>

---

## Claude Code 아키텍처 상세

Claude Code는 단순히 LLM API를 호출하는 래퍼가 아닙니다. 내부적으로 **Tool Loop 패턴**, **컨텍스트 윈도우 관리**, **자동 컴팩션** 등 정교한 에이전트 아키텍처를 갖추고 있습니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph User["사용자 인터페이스"]
      A[터미널 입력] --> B[CLI 파서]
      B --> C[프롬프트 구성]
    end

    subgraph Context["컨텍스트 윈도우 관리"]
      C --> D[CLAUDE.md 로딩]
      D --> E[시스템 프롬프트 조합]
      E --> F[대화 이력 관리]
      F --> G{컨텍스트 초과?}
      G -->|Yes| H[자동 컴팩션]
      H --> F
      G -->|No| I[API 호출]
    end

    subgraph ToolLoop["Tool Loop 패턴"]
      I --> J[Claude API 응답]
      J --> K{Tool 호출?}
      K -->|Yes| L[Tool 실행]
      L --> M[결과를 컨텍스트에 추가]
      M --> I
      K -->|No| N[최종 응답 출력]
    end

    subgraph Tools["내장 도구"]
      L --> O[Read / Write 파일]
      L --> P[Bash 명령 실행]
      L --> Q[Glob / Grep 검색]
      L --> R[서브에이전트 생성]
      L --> S[MCP 도구 호출]
    end

    N --> T[사용자에게 출력]
  `}
  title="Claude Code 내부 아키텍처"
  caption="사용자 입력부터 최종 출력까지의 에이전트 실행 흐름"
/>

### Tool Loop 패턴

Claude Code의 핵심은 **Tool Loop(도구 루프)** 입니다. 사용자의 요청을 받으면 Claude 모델이 응답을 생성하는데, 응답에 도구 호출이 포함되어 있으면 해당 도구를 실행하고 그 결과를 다시 모델에 전달합니다. 이 과정을 모델이 더 이상 도구를 호출하지 않을 때까지 반복합니다.

예를 들어 "이 프로젝트의 테스트를 실행해줘"라는 요청에 Claude Code는 다음과 같이 동작합니다:

1. **Glob**: `**/*.test.*` 패턴으로 테스트 파일 탐색
2. **Read**: `package.json`에서 테스트 스크립트 확인
3. **Bash**: `npm test` 실행
4. **Read**: 실패한 테스트가 있으면 관련 소스 코드 확인
5. **Write**: 버그를 수정하고 파일 저장
6. **Bash**: 다시 `npm test` 실행하여 통과 확인

이 전체 과정이 하나의 Tool Loop 안에서 자율적으로 이루어집니다.

### 컨텍스트 윈도우와 자동 컴팩션

Claude Code는 Claude 모델의 **컨텍스트 윈도우** 한도 내에서 작업합니다. 대화가 길어지면 컨텍스트가 가득 차는데, 이때 **자동 컴팩션(Auto-compaction)** 이 작동합니다.

- **컴팩션 트리거**: 컨텍스트 사용량이 약 95%에 도달하면 자동 발동
- **수동 트리거**: `/compact` 슬래시 커맨드로 수동 실행 가능
- **동작 방식**: 이전 대화 내용을 요약하여 압축하고, 핵심 정보만 유지
- **커스텀 프롬프트**: `/compact [지시사항]`으로 컴팩션 시 보존할 내용을 지정 가능

<Callout type="tip" title="컴팩션 최적화 팁">
  대화가 길어지면 중요한 맥락이 손실될 수 있습니다. 복잡한 작업 중간에 `/compact 현재 진행 중인 리팩토링 작업의 목표와 변경된 파일 목록을 유지해줘`처럼 명시적으로 보존할 내용을 지정하면 효과적입니다.
</Callout>

### 내장 도구 목록

Claude Code가 내부적으로 사용하는 도구들은 다음과 같습니다:

| 도구 이름 | 기능 | 설명 |
|-----------|------|------|
| **Read** | 파일 읽기 | 지정 파일의 내용을 읽어 컨텍스트에 추가 |
| **Write** | 파일 쓰기 | 새 파일 생성 또는 기존 파일 전체 교체 |
| **Edit** | 파일 편집 | 기존 파일의 특정 부분만 정밀하게 수정 |
| **Bash** | 명령 실행 | 셸 명령 실행 (빌드, 테스트, Git 등) |
| **Glob** | 파일 검색 | 패턴 기반 파일 탐색 |
| **Grep** | 내용 검색 | 정규식 기반 코드 내용 검색 |
| **WebFetch** | 웹 콘텐츠 조회 | URL에서 콘텐츠 가져오기 |
| **WebSearch** | 웹 검색 | 인터넷 검색 수행 |
| **Subagent** | 서브에이전트 | 독립 컨텍스트에서 하위 작업 수행 |
| **MCP Tools** | 외부 도구 | MCP 서버로 연결된 외부 도구 호출 |

---

## 설치와 초기 설정 가이드

2025년 10월부터 **네이티브 설치**가 기본 권장 방식입니다 (10월 31일 GA). Node.js가 필요 없으며, 자동 업데이트를 지원합니다.

### 네이티브 설치

<CodeBlock
  code={`# macOS / Linux
curl -fsSL https://claude.ai/install.sh | bash

# Windows (PowerShell)
irm https://claude.ai/install.ps1 | iex

# 설치 확인
claude --version

# 실행
claude

# 기존 npm 설치에서 마이그레이션
claude install`}
  language="bash"
  filename="네이티브 설치 (권장)"
/>

<Callout type="warning" title="npm 설치는 deprecated">
  `npm install -g @anthropic-ai/claude-code`는 더 이상 권장되지 않습니다.
  PATH 이슈, 플랫폼 호환성 문제가 있으며, 네이티브 설치로 마이그레이션하면 기존 설정이 그대로 유지됩니다.
</Callout>

### 인증 설정

Claude Code를 처음 실행하면 인증 과정을 거쳐야 합니다. 두 가지 인증 방식이 있습니다:

<CodeBlock
  code={`# 방법 1: Claude 구독 (Pro/Max) - OAuth 브라우저 인증
claude
# → 브라우저가 열리고 claude.ai 로그인 후 자동 인증

# 방법 2: API 키 직접 설정
export ANTHROPIC_API_KEY="sk-ant-..."
claude

# API 키를 영구 설정하려면
claude config set apiKey sk-ant-...

# 인증 상태 확인
claude config list`}
  language="bash"
  filename="인증 설정"
/>

### 초기 설정 (/init)

프로젝트 디렉토리에서 `/init` 커맨드를 실행하면 `CLAUDE.md` 파일을 자동 생성합니다:

<CodeBlock
  code={`# 프로젝트 디렉토리로 이동
cd my-project

# Claude Code 실행
claude

# 대화 내에서 /init 실행
> /init

# Claude가 프로젝트를 분석하여 CLAUDE.md 초안을 생성합니다:
# - package.json, pyproject.toml 등에서 기술 스택 파악
# - 디렉토리 구조 분석
# - 기존 린트/빌드 설정 확인
# - README.md에서 프로젝트 설명 추출`}
  language="bash"
  filename="프로젝트 초기 설정"
/>

### 첫 실행 시나리오

<CodeBlock
  code={`# 1. 프로젝트 디렉토리에서 Claude Code 시작
cd my-express-app
claude

# 2. Claude Code가 자동으로 수행하는 것들:
#    - CLAUDE.md 파일 로딩 (존재 시)
#    - ~/.claude/CLAUDE.md 글로벌 설정 로딩
#    - MCP 서버 연결 (설정된 경우)
#    - 대화 컨텍스트 초기화

# 3. 첫 번째 요청 예시
> 이 프로젝트의 구조를 파악하고 개선할 점을 알려줘

# 4. Claude가 프로젝트를 분석합니다:
#    - 디렉토리 구조 탐색 (Glob)
#    - 주요 설정 파일 읽기 (Read: package.json 등)
#    - 소스 코드 구조 파악
#    - 분석 결과와 개선 제안을 출력`}
  language="bash"
  filename="첫 실행 시나리오"
/>

### 권한 모델

Claude Code는 안전을 위해 **계층적 권한 모델**을 사용합니다:

| 동작 유형 | 권한 | 설명 |
|-----------|------|------|
| 파일 읽기 | 자동 허용 | 프로젝트 내 파일 읽기는 승인 불필요 |
| 파일 쓰기/수정 | 승인 필요 | diff를 보여주고 사용자 확인 후 적용 |
| Bash 명령 실행 | 승인 필요 | 실행할 명령어를 보여주고 확인 요청 |
| 외부 네트워크 | 승인 필요 | WebFetch, API 호출 등 |

<Callout type="tip" title="자동 승인 설정">
  매번 승인하는 것이 번거롭다면 `--dangerously-skip-permissions` 플래그(비권장) 또는 `settings.json`의 `allowedTools` 설정으로 특정 도구를 자동 승인할 수 있습니다. 다만 보안 리스크를 충분히 이해한 후 사용하세요.
</Callout>

---

## 구독 플랜

Claude Code는 Claude Pro/Max 구독 또는 Anthropic API 키로 사용할 수 있습니다.

| 플랜 | 가격 | Claude Code 사용량 | 주요 모델 |
|------|------|-------------------|-----------|
| **Pro** | $20/월 | 기본 (45 메시지/5시간) | Sonnet 4.5 |
| **Max 5x** | $100/월 | Pro의 5배 | Sonnet 4.5 + Opus 4.6 |
| **Max 20x** | $200/월 | Pro의 20배 | Sonnet 4.5 + Opus 4.6 |
| **Teams Standard** | $20/월/석 (연간) | 팀 관리 + Claude Code 포함 | Sonnet 4.5 |
| **Teams Premium** | $100/월/석 (연간) | 팀 관리 + 대량 사용 | 전체 모델 |
| **API** | 종량제 | 무제한 (비용 비례) | 전체 모델 |

<Callout type="tip" title="비용 참고">
  [Anthropic 공식 문서](https://docs.anthropic.com/en/docs/claude-code/costs)에 따르면 Claude Code 사용자의 평균 비용은 **하루 $6**, 90%의 개발자가 **하루 $12 이하**입니다.
  Max 구독은 API 직접 사용 대비 약 **18배 저렴**하다는 분석도 있습니다.
</Callout>

---

## 핵심 기능

### 1. 파일 시스템 직접 접근

Claude Code는 프로젝트 디렉토리 내의 파일을 직접 읽고 쓸 수 있습니다:

- 프로젝트 구조 자동 파악
- 기존 코드 분석 및 이해
- 새 파일 생성, 기존 파일 수정
- 명령어 실행 (빌드, 테스트, 린트 등)

### 2. CLAUDE.md 기반 프로젝트 컨텍스트

프로젝트 루트의 `CLAUDE.md` 파일을 자동으로 읽어 프로젝트 규칙과 컨벤션을 이해합니다. 프로젝트별, 사용자별, 글로벌 수준의 계층적 설정을 지원합니다.

### 3. MCP (Model Context Protocol)

Anthropic이 2024년 11월 공개한 오픈 표준으로, 외부 도구와의 양방향 통신을 지원합니다:
- **파일 시스템 / Git / GitHub API** 연동
- **데이터베이스** (PostgreSQL, SQLite 등)
- **브라우저 자동화** (Puppeteer)
- **외부 API / SaaS** 연동 (Notion, Slack 등)
- 프로젝트/사용자/글로벌 3단계 스코프로 관리

### 4. Skills & 슬래시 커맨드

Claude Code v2.1부터 슬래시 커맨드와 스킬이 **통합**되었습니다. `.claude/commands/` 또는 `.claude/skills/` 디렉토리에 마크다운 파일을 작성하면 `/명령어`로 호출할 수 있습니다.

| 유형 | 설명 | 예시 |
|------|------|------|
| **내장 커맨드** | Claude Code 기본 제공 | `/init`, `/clear`, `/compact`, `/cost`, `/hooks`, `/config` |
| **커스텀 스킬** | 프로젝트별 워크플로우 정의 | `/review`, `/test`, `/deploy` |
| **포크 컨텍스트** | 독립된 서브에이전트로 실행 | `context: fork` 프론트매터 사용 |

### 5. Subagent (서브에이전트)

복잡한 작업을 여러 전문 에이전트에게 위임할 수 있습니다. Anthropic은 특히 대화 초반에 서브에이전트를 적극 활용할 것을 권장합니다 — 컨텍스트를 보존하면서 세부 작업을 병렬 처리할 수 있기 때문입니다.

### 6. Hooks

특정 이벤트에 반응하는 자동화 스크립트입니다. 12개 이벤트 타입과 3가지 핸들러(command, prompt, agent)를 지원합니다:
- **PreToolUse**: 도구 호출 전 실행 (예: 위험한 명령어 차단)
- **PostToolUse**: 도구 호출 후 실행 (예: 자동 포맷팅)
- **Stop**: 응답 완료 시 실행 (예: 자동 테스트 검증)
- `/hooks` 커맨드로 인터랙티브하게 설정 가능

### 7. Claude Code 웹 버전 & Agent SDK

- **웹 버전** (claude.ai/code): 2025년 10월 베타 출시. 브라우저에서 GitHub 연동, 코드 편집, PR 생성 가능
- **Claude Agent SDK** (구 Claude Code SDK): Claude Code의 에이전트 인프라를 외부 애플리케이션에서 사용할 수 있는 SDK. TypeScript/Python 지원. 코딩 외에도 금융 분석, 고객 지원, 데이터 처리 등 다양한 작업에 활용 가능

### 8. Agent Teams (2026년 2월~)

2026년 2월 Opus 4.6과 함께 출시된 **네이티브 멀티 에이전트 협업** 기능입니다. 여러 Claude Code 인스턴스가 팀으로 협력하여 복잡한 작업을 병렬 수행합니다.

- **팀 리더**: 하나의 세션이 작업을 조율하고 할당
- **독립 작업**: 각 팀원은 자체 컨텍스트 윈도우에서 독립적으로 작업
- **직접 통신**: 팀원들끼리 직접 메시지를 주고받으며 협업
- **실증 사례**: 16개 Opus 4.6 인스턴스가 **Rust 기반 C 컴파일러**를 자율 개발 — 100,000줄 코드로 Linux 6.9 컴파일 성공 ([Anthropic 엔지니어링 블로그](https://www.anthropic.com/engineering/building-c-compiler))

<Callout type="info" title="Agent Teams 활성화">
  현재 Research Preview 단계입니다. `settings.json`에서 `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS`를 활성화하거나 환경 변수로 설정할 수 있습니다.
</Callout>

### 9. Cowork (2026년 1월~)

**Claude Cowork**는 Claude Code의 비개발자용 버전입니다. Claude Desktop 앱에서 코딩 없이 파일 읽기/편집/생성이 가능하며, Claude Code와 동일한 에이전트 아키텍처를 사용합니다.

- **파일 관리**: 다운로드 폴더 파일 자동 분류, 이름 변경
- **문서 작성**: 흩어진 메모에서 보고서 초안 작성
- **데이터 처리**: 스크린샷에서 지출 내역 추출하여 스프레드시트 생성
- **플러그인 시스템**: 법률 계약서 검토, CRM 데이터 입력, 재무 감사 등 전문 워크플로우 지원
- 현재 macOS에서 Pro, Max, Team, Enterprise 플랜으로 사용 가능

---

## 핵심 명령어 완전 가이드

Claude Code 대화 안에서 사용할 수 있는 슬래시 커맨드를 체계적으로 정리합니다.

### 세션 관리 명령어

<ComparisonTable
  title="세션 관리 슬래시 커맨드"
  headers={['커맨드', '기능', '주요 사용 사례']}
  rows={[
    { feature: '/init', values: ['CLAUDE.md 자동 생성', '새 프로젝트 설정 시'] },
    { feature: '/clear', values: ['대화 이력 초기화', '새 주제로 전환 시'] },
    { feature: '/compact', values: ['컨텍스트 압축', '대화가 길어져 컨텍스트 부족 시'] },
    { feature: '/cost', values: ['토큰 사용량 표시', '비용 모니터링'] },
    { feature: '/config', values: ['설정 관리', '환경 설정 변경'] },
    { feature: '/login', values: ['계정 인증', '인증 만료 시 재로그인'] },
    { feature: '/logout', values: ['계정 로그아웃', '계정 전환 시'] },
    { feature: '/help', values: ['도움말 표시', '명령어 확인'] },
  ]}
/>

### 작업 관리 명령어

<ComparisonTable
  title="작업 관련 슬래시 커맨드"
  headers={['커맨드', '기능', '주요 사용 사례']}
  rows={[
    { feature: '/hooks', values: ['Hooks 설정', '자동화 규칙 추가/수정'] },
    { feature: '/model', values: ['모델 전환', 'Sonnet↔Opus 전환'] },
    { feature: '/permissions', values: ['권한 관리', '자동 승인 도구 설정'] },
    { feature: '/memory', values: ['메모리 편집', 'CLAUDE.md 직접 수정'] },
    { feature: '/review', values: ['코드 리뷰 (커스텀)', 'PR 전 코드 검토'] },
    { feature: '/bug', values: ['버그 리포트', 'Claude Code 자체 버그 신고'] },
  ]}
/>

### CLI 실행 옵션

Claude Code는 터미널에서 다양한 플래그와 함께 실행할 수 있습니다:

<CodeBlock
  code={`# 기본 실행 (대화형 모드)
claude

# 한 줄 명령 실행 후 종료 (non-interactive)
claude -p "package.json의 의존성을 분석해줘"

# 파이프 입력 처리
cat error.log | claude -p "이 에러 로그를 분석해줘"

# 모델 지정
claude --model opus

# 출력 형식 지정 (JSON, 스트리밍 JSON, 텍스트)
claude -p "프로젝트 구조 요약" --output-format json

# 이전 대화 이어서 작업
claude --continue
claude --resume  # 특정 세션 선택

# 허용 도구 지정 (비대화형 모드에서)
claude -p "테스트 실행" --allowedTools "Bash(npm test)" "Read"

# 시스템 프롬프트 추가
claude -p "코드 리뷰해줘" --append-system-prompt "한국어로 답변하세요"

# MCP 서버 동적 추가
claude --mcp-server "github: npx -y @anthropic-ai/mcp-server-github"

# 최대 턴 제한 (비대화형)
claude -p "리팩토링해줘" --max-turns 10`}
  language="bash"
  filename="CLI 실행 옵션"
/>

<Callout type="info" title="대화형 vs 비대화형">
  `-p` 플래그 없이 실행하면 **대화형 모드**로 진입하여 여러 번 대화할 수 있습니다. `-p`를 사용하면 **비대화형 모드**로, 하나의 요청을 처리하고 종료합니다. CI/CD 파이프라인이나 스크립트에서는 비대화형 모드가 유용합니다.
</Callout>

### 키보드 단축키

대화형 모드에서 사용할 수 있는 단축키입니다:

| 단축키 | 동작 |
|--------|------|
| `Tab` | 자동완성 (파일 경로, 슬래시 커맨드) |
| `Esc` | 진행 중인 응답 중단 |
| `Esc Esc` | (더블 ESC) 전체 작업 취소 |
| `Ctrl+C` | 현재 입력 취소 |
| `#` | 대화 중 메모 추가 (CLAUDE.md에 저장) |

---

## IDE 통합

Claude Code는 터미널 기반이지만, 주요 IDE/에디터와 깊이 통합되어 있습니다.

### VS Code 통합

VS Code에서 Claude Code를 사용하는 두 가지 방식이 있습니다:

<CodeBlock
  code={`# 방법 1: VS Code 내장 터미널에서 직접 실행
# VS Code 터미널 패널에서:
claude

# 방법 2: Claude Code VS Code 확장 설치
# Extensions 마켓플레이스에서 "Claude Code" 검색 후 설치
# 또는 명령어로 설치:
code --install-extension anthropic.claude-code`}
  language="bash"
  filename="VS Code 통합"
/>

VS Code 확장의 주요 기능:

- **인라인 diff 표시**: Claude가 파일을 수정할 때 VS Code의 네이티브 diff 뷰로 변경사항 확인
- **에디터 컨텍스트 연동**: 현재 열려 있는 파일, 선택 영역을 Claude에게 자동 전달
- **사이드바 패널**: 별도 패널에서 Claude와 대화
- **문제(Problems) 패널 연동**: 린트 에러, 타입 에러를 Claude에게 바로 전달

### JetBrains IDE 통합

IntelliJ IDEA, WebStorm, PyCharm 등 JetBrains IDE에서도 Claude Code를 사용할 수 있습니다:

<CodeBlock
  code={`# JetBrains 플러그인 설치
# Settings → Plugins → Marketplace에서 "Claude Code" 검색

# 또는 JetBrains 내장 터미널에서 직접 실행
claude`}
  language="bash"
  filename="JetBrains 통합"
/>

### Vim / Neovim 통합

터미널 에디터 사용자를 위한 통합 방법입니다:

<CodeBlock
  code={`# Neovim에서 Claude Code를 분할 창으로 실행
# .vimrc 또는 init.lua에 키바인딩 추가:

# init.lua (Neovim)
vim.keymap.set('n', '<leader>cc', function()
  vim.cmd('vsplit | terminal claude')
end, { desc = 'Open Claude Code' })

# tmux를 활용한 병렬 작업
# 왼쪽 패인: Neovim, 오른쪽 패인: Claude Code
tmux split-window -h "claude"`}
  language="bash"
  filename="Vim/Neovim 통합"
/>

### IDE 통합 비교

<ComparisonTable
  title="IDE별 Claude Code 통합 비교"
  headers={['기능', 'VS Code', 'JetBrains', 'Vim/Neovim']}
  rows={[
    { feature: '공식 확장/플러그인', values: ['yes', 'yes', 'no'] },
    { feature: '인라인 diff', values: ['yes', 'yes', 'no'] },
    { feature: '에디터 컨텍스트 연동', values: ['yes', 'yes', 'no'] },
    { feature: '터미널 직접 실행', values: ['yes', 'yes', 'yes'] },
    { feature: '설치 편의성', values: ['매우 쉬움', '쉬움', '수동 설정'] },
    { feature: '리소스 사용량', values: ['보통', '높음', '낮음'] },
  ]}
/>

<Callout type="tip" title="IDE 선택 가이드">
  Claude Code는 **IDE에 독립적인 터미널 도구**입니다. 어떤 에디터를 쓰든 터미널에서 `claude`만 실행하면 됩니다. 공식 확장은 편의 기능을 추가하지만, Claude Code의 핵심 기능은 터미널만으로 완전히 사용할 수 있습니다.
</Callout>

---

## Claude Code Web

### 개요

2025년 10월 베타로 출시된 **Claude Code Web** (claude.ai/code)은 브라우저에서 Claude Code의 에이전트 기능을 사용할 수 있는 서비스입니다. 로컬 설치 없이 GitHub 저장소에 직접 연결하여 코드 작업을 수행합니다.

### 주요 특징

<MermaidDiagram
  chart={`flowchart LR
    A[사용자] --> B[claude.ai/code]
    B --> C[GitHub 연동]
    C --> D[저장소 클론]
    D --> E[가상 환경에서 작업]
    E --> F[코드 수정]
    E --> G[테스트 실행]
    E --> H[빌드 검증]
    F --> I[PR 자동 생성]
    G --> I
    H --> I
    I --> J[GitHub에 PR 등록]
  `}
  title="Claude Code Web 작업 흐름"
  caption="브라우저에서 GitHub까지 이어지는 자동화된 워크플로우"
/>

- **GitHub 원클릭 연동**: OAuth로 GitHub 저장소에 접근, 브랜치 생성, PR 제출까지 자동화
- **가상 실행 환경**: 클라우드 VM에서 코드 실행, 테스트, 빌드 가능
- **멀티 세션**: 여러 작업을 동시에 병렬 실행
- **팀 공유**: 작업 세션을 팀원과 공유 가능

### 사용 사례

| 사용 사례 | 설명 | 장점 |
|-----------|------|------|
| **이슈 해결** | GitHub 이슈를 링크하면 분석 후 수정 PR 생성 | 이슈→PR 자동화 |
| **코드 리뷰** | PR의 코드를 분석하고 개선 사항 제안 | 리뷰어 부담 감소 |
| **모바일 작업** | 태블릿/스마트폰에서 긴급 수정 | 로컬 환경 불필요 |
| **온보딩** | 새 팀원이 코드베이스를 탐색하고 이해 | 설치 과정 제로 |
| **프로토타이핑** | 아이디어를 빠르게 코드로 검증 | 즉시 실행 가능 |

<Callout type="info" title="CLI vs Web 선택 기준">
  **CLI 버전**은 로컬 파일 시스템에 직접 접근하므로 대규모 프로젝트, 복잡한 디버깅, 로컬 서버 실행이 필요한 작업에 적합합니다. **Web 버전**은 빠른 수정, 이슈 기반 작업, 설치가 어려운 환경에서 유용합니다.
</Callout>

---

## Claude Code vs 경쟁 도구 상세 비교

AI 코딩 도구 시장은 빠르게 성장하고 있습니다. 각 도구의 특성을 깊이 비교합니다.

<ComparisonTable
  title="AI 코딩 도구 상세 비교 (2026년 기준)"
  headers={['기능', 'Claude Code', 'GitHub Copilot', 'Cursor', 'Windsurf', 'Aider']}
  rows={[
    { feature: '인터페이스', values: ['터미널 CLI + 웹', 'IDE 확장 + CLI', 'AI IDE (VS Code 포크)', 'AI IDE (VS Code 포크)', '터미널 CLI'] },
    { feature: '기반 모델', values: ['Claude (Anthropic)', 'GPT-4o / Claude / Gemini', 'GPT-4o / Claude / 커스텀', 'GPT-4o / Claude / 커스텀', '모든 LLM (선택)', ] },
    { feature: '에이전트 모드', values: ['기본 (항상)', 'Agent 모드 (별도)', 'Composer Agent', 'Cascade Agent', 'yes'] },
    { feature: '파일 시스템 접근', values: ['yes', 'yes', 'yes', 'yes', 'yes'] },
    { feature: 'MCP 지원', values: ['yes', 'yes', 'yes', 'yes', 'no'] },
    { feature: '서브에이전트', values: ['yes', 'partial', 'no', 'no', 'no'] },
    { feature: 'Agent Teams', values: ['yes', 'no', 'no', 'no', 'no'] },
    { feature: 'Git 통합', values: ['네이티브', '네이티브', 'partial', 'partial', '네이티브'] },
    { feature: '프로젝트 컨텍스트', values: ['CLAUDE.md', '.github/copilot-instructions.md', '.cursor/rules/', '.windsurfrules', 'CONVENTIONS.md'] },
    { feature: 'Hooks/자동화', values: ['yes', 'no', 'no', 'no', 'no'] },
    { feature: '웹 버전', values: ['yes', 'yes', 'no', 'no', 'no'] },
    { feature: 'CI/CD 통합', values: ['yes', 'yes', 'no', 'no', 'partial'] },
    { feature: '가격 (개인)', values: ['$20~/월', '$10/월', '$20/월', '$15/월', '무료 (OSS)'] },
    { feature: '오픈소스', values: ['no', 'no', 'no', 'no', 'yes'] },
  ]}
/>

### 도구별 강점

**Claude Code**의 강점:
- **깊은 추론 능력**: Opus 4.6 모델의 추론 성능을 최대한 활용하는 에이전트 아키텍처
- **터미널 네이티브**: 개발자가 이미 익숙한 CLI 환경에서 동작, 기존 워크플로우와 자연스럽게 통합
- **자율적 에이전트**: Tool Loop를 통한 복잡한 멀티스텝 작업 자율 수행
- **확장성**: Hooks, MCP, Skills로 무한히 확장 가능한 아키텍처
- **Agent Teams**: 경쟁 도구에 없는 네이티브 멀티 에이전트 협업

**GitHub Copilot**의 강점:
- **폭넓은 IDE 지원**: VS Code, JetBrains, Neovim 등 거의 모든 에디터 지원
- **GitHub 생태계 통합**: Issues, PR, Actions와의 완벽한 연동
- **낮은 진입 장벽**: $10/월, 무료 플랜도 제공
- **자동완성 품질**: 인라인 코드 제안의 품질과 속도

**Cursor**의 강점:
- **프로젝트 전체 이해**: 코드베이스 인덱싱으로 전체 프로젝트 맥락 파악
- **멀티파일 편집**: Composer로 여러 파일을 동시에 수정
- **시각적 diff**: 변경사항을 직관적으로 확인
- **IDE 일체형**: 별도 도구 전환 없이 에디터 안에서 모든 작업

**Aider**의 강점:
- **오픈소스**: 완전 무료, 커스터마이징 자유
- **모델 선택 자유**: OpenAI, Anthropic, Ollama 등 모든 LLM 지원
- **Git 네이티브**: 변경사항을 자동으로 커밋, 깔끔한 이력 관리
- **가벼움**: 최소한의 리소스로 동작

<Callout type="info" title="도구 선택 기준">
  "어떤 도구가 최고인가?"보다 "지금 이 문제에 어떤 도구가 적합한가?"가 더 나은 질문입니다.
  Claude Code는 **터미널 워크플로우, 깊은 추론, 디버깅, 아키텍처 설계**에 강점이 있고,
  Copilot은 **빠른 자동완성과 GitHub 통합**, Cursor는 **프로젝트 전체를 이해하는 멀티파일 편집**에 강합니다.
</Callout>

---

## 실전 활용 시나리오

### 시나리오 1: 새 프로젝트 시작

<CodeBlock
  code={`# 새 디렉토리 생성 후 Claude Code 시작
mkdir my-api-server && cd my-api-server
claude

# 프로젝트 초기화 요청
> Express.js + TypeScript로 REST API 서버를 만들어줘.
  다음 구조로 설정해줘:
  - src/routes/ - API 라우트
  - src/services/ - 비즈니스 로직
  - src/middleware/ - 미들웨어
  - Jest로 테스트 설정
  - ESLint + Prettier 설정
  - Docker 설정 포함

# Claude가 수행하는 작업들:
# 1. npm init -y 실행
# 2. 필요한 패키지 설치 (express, typescript, jest 등)
# 3. tsconfig.json, .eslintrc, .prettierrc 생성
# 4. 디렉토리 구조 생성
# 5. 기본 서버 코드 작성
# 6. Dockerfile, docker-compose.yml 생성
# 7. README.md 초안 작성

# 이어서 CLAUDE.md 생성
> /init`}
  language="bash"
  filename="시나리오 1: 새 프로젝트 시작"
/>

### 시나리오 2: 버그 수정

<CodeBlock
  code={`# 프로젝트에서 Claude Code 시작
cd my-project
claude

# 에러 정보와 함께 요청
> 사용자 로그인 시 "Invalid token format" 에러가 발생해.
  에러 로그는 이거야:

  Error: Invalid token format
    at verifyToken (src/auth/jwt.ts:45)
    at authMiddleware (src/middleware/auth.ts:12)

# Claude가 수행하는 작업들:
# 1. src/auth/jwt.ts:45 라인 확인
# 2. src/middleware/auth.ts:12 라인 확인
# 3. 관련 테스트 파일 확인
# 4. JWT 토큰 형식 검증 로직 분석
# 5. 문제 원인 설명 (예: Bearer 접두사 처리 누락)
# 6. 수정 코드 제안 및 적용
# 7. 테스트 추가하여 재발 방지 확인

# 수정 확인 후 커밋
> 변경사항을 커밋해줘`}
  language="bash"
  filename="시나리오 2: 버그 수정"
/>

### 시나리오 3: 리팩토링

<CodeBlock
  code={`claude

# 리팩토링 요청
> src/services/user-service.ts 파일이 500줄이 넘어.
  단일 책임 원칙에 따라 리팩토링해줘.
  기존 테스트가 모두 통과하도록 유지해야 해.

# Claude가 수행하는 작업들:
# 1. user-service.ts 전체 분석
# 2. 기존 테스트 파일 확인 (user-service.test.ts)
# 3. 책임 단위로 분리 계획 수립:
#    - UserAuthService (인증 관련)
#    - UserProfileService (프로필 관리)
#    - UserNotificationService (알림 관련)
# 4. 새 파일들 생성 및 코드 이동
# 5. import 경로 업데이트 (의존하는 모든 파일)
# 6. 테스트 실행하여 통과 확인
# 7. 변경 요약 출력

# 추가 요청
> 리팩토링한 코드에 JSDoc 주석도 추가해줘`}
  language="bash"
  filename="시나리오 3: 리팩토링"
/>

### 시나리오 4: 테스트 작성

<CodeBlock
  code={`claude

# 테스트 코드 작성 요청
> src/services/payment-service.ts의 단위 테스트를 작성해줘.
  다음 조건을 만족해야 해:
  - 모든 public 메서드에 대한 테스트
  - 성공 케이스와 실패 케이스 모두 포함
  - 외부 API 호출은 mock 처리
  - 엣지 케이스 (금액 0, 음수, 최대값) 테스트
  - 커버리지 80% 이상

# Claude가 수행하는 작업들:
# 1. payment-service.ts 분석 (메서드, 의존성 파악)
# 2. 외부 의존성 식별 (PaymentGateway, DB 등)
# 3. Mock 객체 설계
# 4. 테스트 파일 생성 (payment-service.test.ts)
# 5. 테스트 실행 (npm test)
# 6. 커버리지 확인
# 7. 부족한 케이스 추가

# 결과 확인
> 테스트 커버리지 리포트를 보여줘`}
  language="bash"
  filename="시나리오 4: 테스트 작성"
/>

### 시나리오 5: 코드 리뷰

<CodeBlock
  code={`claude

# Git diff 기반 코드 리뷰
> main 브랜치와 현재 브랜치의 차이를 리뷰해줘.
  보안 취약점, 성능 이슈, 코딩 컨벤션 위반을 중심으로 검토해줘.

# Claude가 수행하는 작업들:
# 1. git diff main...HEAD 실행
# 2. 변경된 파일 목록 확인
# 3. 각 파일의 변경사항 분석
# 4. 리뷰 결과를 카테고리별로 정리:
#    - [보안] SQL 인젝션 가능성 발견
#    - [성능] N+1 쿼리 패턴 감지
#    - [스타일] 네이밍 컨벤션 위반 3건
#    - [버그] null 체크 누락 1건
# 5. 각 이슈에 대한 수정 제안`}
  language="bash"
  filename="시나리오 5: 코드 리뷰"
/>

### 시나리오 6: 비대화형 모드로 CI/CD 통합

<CodeBlock
  code={`# GitHub Actions에서 자동 코드 리뷰
claude -p "$(cat <<'EOF'
이 PR의 변경사항을 리뷰해줘.
다음 관점으로 검토하고 JSON 형식으로 결과를 출력해:
- security: 보안 취약점
- performance: 성능 이슈
- bugs: 잠재적 버그
- style: 코딩 컨벤션 위반
EOF
)" --output-format json --max-turns 5

# 커밋 메시지 자동 생성
git diff --staged | claude -p "이 변경사항에 대한
  Conventional Commits 형식의 커밋 메시지를 생성해줘.
  본문은 한국어로 작성해." --output-format text

# 테스트 자동 생성 파이프라인
claude -p "src/services/ 디렉토리의 모든 서비스 파일에 대해
  누락된 테스트 케이스를 찾아 추가해줘" --max-turns 20`}
  language="bash"
  filename="시나리오 6: CI/CD 통합"
/>

---

## 성능과 비용

### 토큰 사용량 이해

Claude Code의 비용은 **API 토큰 사용량**에 비례합니다. Pro/Max 구독자는 포함된 사용량 내에서 무료이고, API 키 사용자는 종량제로 과금됩니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph Input["입력 토큰 (비용 낮음)"]
      A[시스템 프롬프트]
      B[CLAUDE.md]
      C[대화 이력]
      D[도구 실행 결과]
    end

    subgraph Output["출력 토큰 (비용 높음)"]
      E[텍스트 응답]
      F[도구 호출 요청]
      G[코드 생성]
    end

    Input --> H[Claude API]
    H --> Output

    style A fill:#f0ece5,stroke:#d4cdc4
    style B fill:#f0ece5,stroke:#d4cdc4
    style C fill:#f0ece5,stroke:#d4cdc4
    style D fill:#f0ece5,stroke:#d4cdc4
    style E fill:#fdf2ee,stroke:#da7756
    style F fill:#fdf2ee,stroke:#da7756
    style G fill:#fdf2ee,stroke:#da7756
  `}
  title="토큰 구성과 비용 구조"
  caption="입력 토큰보다 출력 토큰의 단가가 5배 높습니다 (Sonnet 4.5 기준: 입력 $3/백만, 출력 $15/백만)"
/>

### 모델별 비용 비교

| 모델 | 입력 토큰 (백만당) | 출력 토큰 (백만당) | 컨텍스트 윈도우 | 적합한 작업 |
|------|-------------------|-------------------|----------------|------------|
| **Sonnet 4.5** | $3 | $15 | 200K | 일상적 코딩, 빠른 응답 |
| **Opus 4.6** | $15 | $75 | 200K | 복잡한 추론, 아키텍처 |
| **Haiku 3.5** | $0.80 | $4 | 200K | 간단한 작업, 대량 처리 |

### 토큰 사용량 최적화 전략

<CodeBlock
  code={`# 1. /cost로 현재 세션 비용 확인
> /cost
# Session tokens: 45,230 input / 12,450 output
# Estimated cost: $0.32

# 2. /compact로 컨텍스트 압축 (토큰 절약)
> /compact 현재 작업 목표와 변경된 파일 목록을 유지해줘

# 3. 구체적인 요청으로 불필요한 도구 호출 최소화
# Bad: "이 프로젝트를 개선해줘" (모호 → 많은 탐색)
# Good: "src/utils/date.ts의 formatDate 함수에
#         ISO 8601 포맷 지원을 추가해줘" (명확 → 최소 탐색)

# 4. 모델 전환으로 비용 최적화
> /model sonnet   # 일상 작업은 Sonnet으로
> /model opus     # 복잡한 추론은 Opus로

# 5. 환경 변수로 기본 모델 설정
export CLAUDE_CODE_DEFAULT_MODEL=sonnet`}
  language="bash"
  filename="토큰 최적화 전략"
/>

### 비용 예측 가이드

일반적인 작업별 예상 토큰 사용량입니다 (Sonnet 4.5 기준):

| 작업 유형 | 예상 턴 수 | 예상 토큰 | 예상 비용 (API) |
|-----------|-----------|----------|----------------|
| 간단한 파일 수정 | 2~3턴 | ~20K | ~$0.05 |
| 버그 수정 (단일 파일) | 3~5턴 | ~50K | ~$0.15 |
| 새 기능 구현 (소규모) | 5~10턴 | ~100K | ~$0.40 |
| 리팩토링 (다중 파일) | 10~20턴 | ~200K | ~$1.00 |
| 프로젝트 초기 설정 | 15~30턴 | ~300K | ~$1.50 |
| 대규모 기능 구현 | 20~50턴 | ~500K+ | ~$3.00+ |

<Callout type="tip" title="비용 절약 팁">
  **Pro 플랜($20/월)** 사용자는 일일 약 45 메시지를 사용할 수 있습니다. 이 한도를 최대한 활용하려면: (1) 한 번에 명확하고 구체적인 요청을 하고, (2) 간단한 작업은 여러 개를 묶어서 요청하며, (3) 컨텍스트가 커질수록 `/compact`를 적극 활용하세요. **Max 5x($100/월)** 는 API 직접 사용 대비 약 18배 절약 효과가 있어, 하루 평균 $6 이상 사용하는 개발자에게 경제적입니다.
</Callout>

### 사용량 모니터링

<CodeBlock
  code={`# 세션 내 비용 확인
> /cost

# API 키 사용 시 Anthropic Console에서 확인
# https://console.anthropic.com/settings/usage

# 환경 변수로 일일 예산 제한 (API 키 사용 시)
export ANTHROPIC_API_MAX_DAILY_SPEND=20

# 비용 알림 설정 (Anthropic Console)
# Settings → Billing → Usage Alerts에서 임계값 설정`}
  language="bash"
  filename="사용량 모니터링"
/>

---

## 워크플로우 예시

<CodeBlock
  code={`# 1. 프로젝트 디렉토리에서 Claude Code 실행
claude

# 2. 자연어로 작업 요청
> "사용자 인증 API를 Express.js로 구현해줘. JWT를 사용하고
   리프레시 토큰도 지원해야 해."

# 3. Claude가 파일을 생성/수정하면 diff를 확인하고 승인

# 4. 테스트 작성 요청
> "auth-service.ts에 대한 유닛 테스트를 작성해줘"

# 5. 커밋 (커스텀 스킬 또는 직접 요청)
> "변경사항을 커밋해줘"`}
  language="bash"
  filename="기본 워크플로우"
/>

---

## 지원 환경

| OS | 요구 사항 |
|-----|----------|
| **macOS** | 13.0 (Ventura) 이상 |
| **Linux** | Ubuntu 20.04+ / Debian 10+ |
| **Windows** | Windows 10 1809+ (네이티브, WSL 불필요) |

<ChapterNav
  prev={{ title: '바이브 코딩이란?', path: '/docs/part-1--기초-바이브-코딩이란' }}
  next={{ title: '개발 환경 설정', path: '/docs/part-1--기초-개발-환경-설정' }}
/>
