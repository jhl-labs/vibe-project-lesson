import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { FileTree } from '../../components/FileTree';
import { TemplateFileViewer } from '../../components/TemplateFileViewer';
import { ChapterNav } from '../../components/ChapterNav';
import { templateFiles } from '../../data/template-files';

<Meta title="Part 1: 기초/CLAUDE.md 딥다이브" />

# CLAUDE.md 딥다이브

> Claude Code의 행동을 정의하는 프로젝트 지침서 — 작성법부터 팀 운영 전략까지

## CLAUDE.md란?

`CLAUDE.md`는 Claude Code가 대화 시작 시 **자동으로 로드하는 메모리 파일**입니다. 프로젝트의 규칙, 컨벤션, 기술 스택, 보안 정책 등을 정의하여 Claude가 프로젝트에 맞는 코드를 생성하도록 안내합니다.

<Callout type="important" title="왜 중요한가?">
  CLAUDE.md는 Claude Code에게 "이 프로젝트에서는 이렇게 해라"라고 알려주는 설정 파일입니다.
  잘 작성된 CLAUDE.md는 AI의 코드 품질을 크게 향상시킵니다. 반대로, 너무 길거나 모호하면
  중요한 규칙이 무시되는 **"fading memory" 현상**이 발생할 수 있습니다.
</Callout>

---

## CLAUDE.md 로딩 프로세스

Claude Code가 시작될 때 CLAUDE.md를 어떻게 찾고 로드하는지, 전체 프로세스를 시각적으로 이해합시다.

<MermaidDiagram
  chart={`flowchart TD
    A[Claude Code 시작] --> B[Enterprise 정책 로드]
    B --> C["~/.claude/CLAUDE.md 로드<br/>(글로벌 설정)"]
    C --> D["프로젝트 루트 CLAUDE.md 로드<br/>(팀 공유 설정)"]
    D --> E["CLAUDE.local.md 로드<br/>(개인 설정)"]
    E --> F[".claude/rules/*.md 스캔"]
    F --> G{paths 매칭?}
    G -->|Yes| H["조건부 규칙 포함"]
    G -->|No| I["건너뛰기"]
    H --> J["@import 구문 해석"]
    I --> J
    J --> K["Auto Memory 로드<br/>(MEMORY.md)"]
    K --> L[시스템 프롬프트에 병합]
    L --> M["서브트리 CLAUDE.md<br/>(파일 접근 시 lazy load)"]
    M --> N[대화 시작]
  `}
  title="CLAUDE.md 로딩 프로세스"
  caption="시작부터 대화 진입까지 모든 설정 파일이 순차적으로 병합됩니다"
/>

이 프로세스에서 핵심 포인트는 다음과 같습니다:

- **Enterprise 정책이 최상위 우선순위**를 가집니다 — 조직 관리자가 강제하는 보안 정책
- **글로벌 설정은 모든 프로젝트에 적용**됩니다 — 개인 언어 선호, 스타일 등
- **프로젝트 CLAUDE.md가 핵심**입니다 — 팀이 공유하는 프로젝트 규칙
- **서브트리 CLAUDE.md는 지연 로드**됩니다 — 해당 파일에 접근할 때만 로드

---

## 메모리 계층 구조

Claude Code는 여러 수준의 메모리 파일을 계층적으로 로드합니다. 현재 작업 디렉토리에서 시작하여 **루트 디렉토리까지 재귀적으로 탐색**하며 CLAUDE.md 파일을 찾습니다.

<FileTree
  title="CLAUDE.md 로딩 계층 (위에서 아래로 우선순위)"
  data={[
    {
      name: 'Enterprise 정책',
      type: 'folder',
      description: '조직 전체 (macOS: /Library/Application Support/ClaudeCode/)',
      children: [
        { name: 'CLAUDE.md', type: 'file', description: '회사 전체 보안 정책, 표준', highlight: true },
      ],
    },
    {
      name: '~/.claude/',
      type: 'folder',
      description: '글로벌 (모든 프로젝트)',
      children: [
        { name: 'CLAUDE.md', type: 'file', description: '개인 선호 설정 (언어, 스타일)', highlight: true },
      ],
    },
    {
      name: 'project-root/',
      type: 'folder',
      description: '프로젝트',
      children: [
        { name: 'CLAUDE.md', type: 'file', description: '팀 공유 프로젝트 설정 (Git 추적)', highlight: true },
        { name: 'CLAUDE.local.md', type: 'file', description: '개인 프로젝트 설정 (자동 .gitignore)', highlight: true },
        {
          name: '.claude/',
          type: 'folder',
          children: [
            { name: 'CLAUDE.md', type: 'file', description: '대체 위치 (CLAUDE.md와 동일)' },
            {
              name: 'rules/',
              type: 'folder',
              description: '조건부 규칙 파일들',
              children: [
                { name: 'frontend.md', type: 'file', description: 'paths: src/components/**' },
                { name: 'backend.md', type: 'file', description: 'paths: src/api/**' },
              ],
            },
          ],
        },
        {
          name: 'src/components/',
          type: 'folder',
          children: [
            { name: 'CLAUDE.md', type: 'file', description: '서브트리 메모리 (해당 파일 작업 시 lazy load)' },
          ],
        },
      ],
    },
  ]}
/>

<ComparisonTable
  title="메모리 계층별 특성 비교"
  headers={['속성', 'Enterprise', '글로벌', '프로젝트', 'Rules', '개인(local)', '서브트리']}
  rows={[
    { feature: '범위', values: ['조직 전체', '모든 프로젝트', '현재 프로젝트', '조건부', '현재 프로젝트', '특정 모듈'] },
    { feature: 'Git 추적', values: ['N/A', 'no', 'yes', 'yes', 'no', 'yes'] },
    { feature: '로드 시점', values: ['항상', '항상', '항상', 'paths 매칭 시', '항상', '파일 접근 시'] },
    { feature: '수정 주체', values: ['관리자', '개인', '팀', '팀', '개인', '모듈 담당자'] },
    { feature: '주요 용도', values: ['보안 정책', '언어/스타일', '프로젝트 규칙', '영역별 규칙', '개인 선호', '모듈 컨벤션'] },
  ]}
/>

---

## Rules 디렉토리 심화

`.claude/rules/` 디렉토리를 사용하면 하나의 거대한 CLAUDE.md 대신 **모듈화된 규칙 파일**로 관리할 수 있습니다. YAML 프론트매터의 `paths` 필드로 특정 파일 패턴에만 적용되는 조건부 규칙을 정의할 수 있습니다.

### 기본 구조

<CodeBlock
  code={`# .claude/rules/react-components.md
---
paths:
  - "src/components/**"
  - "src/pages/**"
---

- React 컴포넌트는 함수형으로 작성
- Props 인터페이스는 컴포넌트 파일 상단에 정의
- CSS Module 사용, 인라인 스타일 금지
- 컴포넌트 파일명은 PascalCase`}
  language="markdown"
  filename=".claude/rules/react-components.md"
/>

<CodeBlock
  code={`# .claude/rules/api-endpoints.md
---
paths:
  - "src/api/**"
  - "src/routes/**"
---

- Express Router 사용
- 모든 엔드포인트에 입력 검증 (zod)
- 에러 응답은 RFC 7807 형식
- 인증이 필요한 엔드포인트는 authMiddleware 적용`}
  language="markdown"
  filename=".claude/rules/api-endpoints.md"
/>

### 고급 Rules 패턴

실제 프로젝트에서 자주 사용하는 Rules 파일 패턴들입니다:

<CodeBlock
  code={`# .claude/rules/database.md
---
paths:
  - "src/infrastructure/persistence/**"
  - "src/migrations/**"
  - "prisma/**"
---

## 데이터베이스 규칙
- ORM은 Prisma 사용, raw SQL 금지
- 마이그레이션 파일은 직접 수정하지 않음
- 인덱스 추가 시 반드시 EXPLAIN ANALYZE 결과 확인
- N+1 쿼리 방지: include/select 적극 활용
- 트랜잭션 범위는 최소화`}
  language="markdown"
  filename=".claude/rules/database.md"
/>

<CodeBlock
  code={`# .claude/rules/testing.md
---
paths:
  - "**/*.test.ts"
  - "**/*.spec.ts"
  - "src/__tests__/**"
---

## 테스트 규칙
- AAA 패턴 (Arrange-Act-Assert) 사용
- 테스트 이름은 "should + 행위 + 조건" 형식
- Mock은 테스트 파일 내에서만 정의
- 외부 API 호출은 반드시 Mock/Stub 처리
- 스냅샷 테스트보다 동작 기반 테스트 선호`}
  language="markdown"
  filename=".claude/rules/testing.md"
/>

<CodeBlock
  code={`# .claude/rules/security.md
---
paths:
  - "src/auth/**"
  - "src/middleware/auth*"
  - "src/crypto/**"
---

## 보안 코드 규칙
- 암호화 로직 직접 구현 금지 (bcrypt, crypto 라이브러리 사용)
- JWT 시크릿은 반드시 환경 변수에서 로드
- 비밀번호는 평문 저장 금지, bcrypt cost factor 12 이상
- CORS 설정은 와일드카드(*) 금지
- Rate Limiting 미적용 엔드포인트 금지`}
  language="markdown"
  filename=".claude/rules/security.md"
/>

<Callout type="tip" title="Rules 파일 명명 규칙">
  Rules 파일명은 해당 규칙의 도메인을 명확히 나타내도록 지으세요. `react-components.md`, `api-endpoints.md`, `database.md`처럼 한 눈에 역할을 알 수 있어야 합니다. paths가 없는 규칙 파일은 모든 컨텍스트에서 항상 로드됩니다.
</Callout>

---

## 임포트 구문

CLAUDE.md 파일에서 `@path/to/file` 구문으로 다른 파일을 임포트할 수 있습니다. 거대한 단일 파일 대신 모듈화된 구조를 유지하는 데 유용합니다.

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
이 프로젝트는 TypeScript 기반의 REST API 서버입니다.

## 상세 규칙
@docs/context.md
@docs/api-standards.md

## 개인별 설정 (홈 디렉토리 참조)
@~/my-preferences.md`}
  language="markdown"
  filename="CLAUDE.md (임포트 예시)"
/>

<Callout type="info" title="임포트 경로">
  상대 경로와 절대 경로 모두 사용 가능합니다. `~/` 접두사로 홈 디렉토리의 파일을 참조하면
  팀원마다 다른 개인 설정을 Git에 커밋하지 않고도 적용할 수 있습니다.
</Callout>

---

## 실제 CLAUDE.md 분석

이 프로젝트의 실제 CLAUDE.md 파일을 살펴보겠습니다:

<TemplateFileViewer
  filename="CLAUDE.md"
  content={templateFiles['CLAUDE.md']}
  language="markdown"
  annotations={[
    { lineStart: 1, lineEnd: 8, text: '프로젝트 기본 정보를 정의합니다. Claude가 프로젝트의 이름, 설명, 기술 스택을 파악하는 데 사용됩니다.' },
    { lineStart: 10, lineEnd: 19, text: '빠른 명령어 섹션입니다. Claude가 빌드, 테스트, 린트 등의 명령어를 알 수 있게 합니다.' },
    { lineStart: 21, lineEnd: 29, text: '프로젝트 디렉토리 구조를 설명합니다. Clean Architecture 4레이어를 정의하고 있습니다.' },
    { lineStart: 31, lineEnd: 49, text: '코딩 규칙 섹션입니다. 네이밍, 스타일, 아키텍처 원칙을 정의하여 일관된 코드 생성을 유도합니다.' },
    { lineStart: 51, lineEnd: 65, text: '보안 필수 사항입니다. 절대 금지 항목과 필수 항목을 명확히 구분하여 AI가 안전한 코드를 생성하도록 합니다.' },
    { lineStart: 67, lineEnd: 80, text: 'AI 작업 지침입니다. 코드 생성과 리뷰 시 Claude가 따라야 할 규칙을 정의합니다.' },
  ]}
/>

---

## 작성 모범 사례와 안티패턴

CLAUDE.md의 품질이 곧 Claude Code의 코드 품질을 결정합니다. Anthropic 공식 문서와 커뮤니티 사례를 바탕으로 모범 사례와 안티패턴을 깊이 있게 비교합니다.

### 1. 간결하게 유지 — "fading memory" 방지

CLAUDE.md가 너무 길어지면 중요한 규칙이 노이즈에 묻혀 무시됩니다. Anthropic 공식 문서에서도 **"over-specified CLAUDE.md"를 가장 큰 안티패턴**으로 꼽습니다.

<CodeBlock
  code={`# --- GOOD: 명확하고 간결한 기술 스택 ---
## 기술 스택
- TypeScript 5.x (strict mode)
- Express.js 4.x
- PostgreSQL 15
- Jest (테스트)
- Prisma (ORM)

## 빠른 명령어
npm run dev        # 개발 서버
npm test           # 테스트
npm run build      # 빌드
npm run lint       # 린트

# --- BAD: 과도하게 장황한 기술 스택 ---
## 기술 스택
이 프로젝트는 TypeScript를 사용합니다. TypeScript는
JavaScript의 상위 집합(superset)으로, 정적 타입 시스템을
제공하여 런타임 에러를 줄여줍니다. 현재 버전은 5.x이며,
strict mode를 활성화하여 더 엄격한 타입 검사를 수행합니다.
(... 각 기술마다 이런 설명이 계속됨 ...)

Express.js는 Node.js의 가장 인기 있는 웹 프레임워크로...
PostgreSQL은 오픈소스 관계형 데이터베이스로...`}
  language="markdown"
  filename="기술 스택 작성 예시"
/>

<Callout type="warning" title="fading memory란?">
  LLM은 프롬프트가 길어질수록 앞부분의 내용을 덜 주의하는 경향이 있습니다.
  CLAUDE.md가 500줄 이상이 되면 앞부분에 작성한 중요한 보안 규칙이
  뒷부분의 장황한 코딩 스타일 설명에 밀려 무시될 수 있습니다.
  **핵심 규칙을 상단에, 간결하게** 배치하세요.
</Callout>

### 2. 규칙은 구체적으로

<CodeBlock
  code={`# --- GOOD: 구체적이고 실행 가능한 규칙 ---
## 코딩 규칙
- 함수 최대 길이: 30줄
- 파라미터 최대: 3개 (초과 시 객체 파라미터 사용)
- 파일명: kebab-case.ts
- 상수: UPPER_SNAKE_CASE
- 비동기 함수: async/await 사용 (.then() 금지)
- 에러 처리: try-catch + 커스텀 에러 클래스 사용
- import 순서: 외부 라이브러리 → 내부 모듈 → 상대 경로

# --- BAD: 모호하고 해석이 다양한 규칙 ---
## 코딩 규칙
- 깨끗한 코드를 작성하세요
- 좋은 네이밍을 사용하세요
- 적절한 에러 처리를 해주세요
- 성능을 고려하세요
- 테스트를 잘 작성하세요`}
  language="markdown"
  filename="규칙 구체성 비교"
/>

### 3. 불변 규칙과 선호도 구분

<CodeBlock
  code={`# --- GOOD: 강도별로 구분된 규칙 ---

## 절대 금지 (MUST NOT)
- 하드코딩된 시크릿 (API 키, 비밀번호, 토큰)
- eval() 또는 new Function()
- any 타입 사용 (unknown 사용)
- console.log를 프로덕션 코드에 남기기

## 필수 (MUST)
- 모든 public 함수에 JSDoc 작성
- 에러 처리는 커스텀 에러 클래스 사용
- DB 쿼리는 Prisma ORM으로만

## 권장 (SHOULD)
- 가능하면 함수형 프로그래밍 스타일
- 컴포넌트는 작게 분리
- 조기 반환(early return) 패턴 선호

# --- BAD: 모든 규칙이 같은 강도 ---
## 규칙
- 시크릿 하드코딩하지 마세요
- 함수형 스타일 쓰세요
- eval 쓰지 마세요
- 조기 반환 쓰세요
- any 쓰지 마세요`}
  language="markdown"
  filename="규칙 강도 구분"
/>

<Callout type="tip" title="정리 기준">
  Claude가 이미 올바르게 하고 있는 것이라면 CLAUDE.md에서 **삭제**하세요.
  반복적으로 실수하는 부분만 규칙으로 남기세요. 또는 반드시 지켜야 하는 규칙은 **Hook으로 전환**하세요
  — Hook은 CLAUDE.md와 달리 100% 실행이 보장됩니다.
</Callout>

### 4. 보안 규칙은 반드시 포함

<CodeBlock
  code={`## 보안 필수 사항

**절대 금지:**
- 하드코딩된 시크릿 (API 키, 비밀번호)
- eval() 또는 동적 코드 실행
- 검증 없는 사용자 입력 사용
- SQL 인젝션 가능한 쿼리
- 시스템 사용자명, IP, 호스트 정보 코드 노출

**필수:**
- 환경 변수로 설정 관리
- 모든 입력 검증 (zod, joi 등)
- 적절한 에러 처리 (스택 트레이스 노출 금지)
- HTTPS 강제, CORS 화이트리스트 방식`}
  language="markdown"
  filename="보안 규칙 예시"
/>

### 5. 안티패턴 종합

다음은 실제 프로젝트에서 자주 발견되는 CLAUDE.md 안티패턴입니다:

<ComparisonTable
  title="CLAUDE.md 작성 안티패턴"
  headers={['안티패턴', '문제점', '해결법']}
  rows={[
    { feature: '500줄 이상의 거대한 단일 파일', values: ['fading memory 발생', '.claude/rules/로 모듈화'] },
    { feature: '모호한 지침("좋은 코드 작성")', values: ['Claude가 해석 불가', '구체적 수치/패턴 명시'] },
    { feature: '이미 기본 동작인 규칙 나열', values: ['토큰 낭비, 노이즈 증가', '반복 실수만 규칙화'] },
    { feature: '보안 규칙 누락', values: ['시크릿 노출 위험', '보안 섹션 필수 포함'] },
    { feature: '예시 코드 없이 규칙만 나열', values: ['일관성 없는 코드 생성', '좋은/나쁜 예시 함께 제공'] },
    { feature: '오래된 규칙 미갱신', values: ['현재 코드와 불일치', '분기별 점검 루틴 수립'] },
    { feature: '개인 설정과 팀 설정 혼합', values: ['팀원 간 충돌', 'CLAUDE.local.md로 분리'] },
  ]}
/>

---

## CLAUDE.md 최적 길이와 구조

### 토큰 효율성

CLAUDE.md는 **시스템 프롬프트의 일부로 매 API 호출마다 전송**됩니다. 즉, CLAUDE.md가 길수록 매 턴마다 더 많은 입력 토큰을 소비합니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph Every["매 API 호출마다 전송"]
      A["시스템 프롬프트<br/>~2,000 토큰"]
      B["CLAUDE.md<br/>? 토큰"]
      C["Rules 파일<br/>? 토큰"]
      D["MEMORY.md<br/>? 토큰"]
    end

    subgraph Recommend["권장 토큰 예산"]
      E["CLAUDE.md<br/>500~1,500 토큰<br/>(약 50~150줄)"]
      F["Rules 파일 합계<br/>500~1,000 토큰"]
      G["MEMORY.md<br/>200줄 이내"]
    end

    Every --> H{총 입력 토큰}
    H --> Recommend
  `}
  title="CLAUDE.md 토큰 예산"
  caption="매 API 호출마다 전송되므로 간결할수록 비용이 절약됩니다"
/>

### 권장 구조와 길이

<CodeBlock
  code={`# CLAUDE.md 권장 구조 (약 80~120줄)

## 프로젝트 개요                    # ~5줄: 이름, 설명, 기술 스택
## 빠른 명령어                      # ~10줄: dev, test, build, lint
## 프로젝트 구조                    # ~10줄: 핵심 디렉토리 설명
## 코딩 규칙                       # ~15줄: 네이밍, 스타일 핵심만
## 보안 필수 사항                   # ~10줄: 절대 금지 + 필수
## AI 작업 지침                    # ~10줄: 코드 생성/리뷰 시 규칙
## 환경 변수                       # ~5줄: .env.example 참조
## 참고 문서                       # ~5줄: 상세 문서 링크

# 나머지는 .claude/rules/로 분리:
# - .claude/rules/frontend.md      # React/Vue 관련 규칙
# - .claude/rules/backend.md       # API/서버 관련 규칙
# - .claude/rules/database.md      # DB 관련 규칙
# - .claude/rules/testing.md       # 테스트 관련 규칙`}
  language="markdown"
  filename="권장 구조"
/>

<Callout type="info" title="80/20 법칙">
  CLAUDE.md의 핵심 20%가 전체 효과의 80%를 차지합니다. 프로젝트 개요, 빠른 명령어, 보안 규칙 — 이 세 가지만 잘 작성해도 Claude Code의 코드 품질이 크게 향상됩니다. 나머지 세부 규칙은 Rules 파일로 분리하세요.
</Callout>

---

## 프로젝트 유형별 CLAUDE.md 템플릿

### 웹 애플리케이션 (React + Next.js)

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
- **이름**: my-web-app
- **설명**: Next.js 기반 SaaS 대시보드
- **기술 스택**: TypeScript, Next.js 14 (App Router), React 18, Tailwind CSS

## 빠른 명령어
npm run dev          # 개발 서버 (localhost:3000)
npm run build        # 프로덕션 빌드
npm test             # Jest 테스트
npm run lint         # ESLint
npm run storybook    # 컴포넌트 문서

## 프로젝트 구조
src/
├── app/              # Next.js App Router 페이지
├── components/       # 재사용 가능 UI 컴포넌트
│   ├── ui/           # 기본 UI (Button, Input, Modal)
│   └── features/     # 기능별 컴포넌트
├── hooks/            # 커스텀 React 훅
├── lib/              # 유틸리티, API 클라이언트
├── stores/           # Zustand 상태 관리
└── types/            # TypeScript 타입 정의

## 코딩 규칙
- 컴포넌트: 함수형 + named export
- 스타일: Tailwind CSS (인라인 스타일 금지)
- 상태 관리: 서버 상태는 TanStack Query, 클라이언트 상태는 Zustand
- App Router: 서버 컴포넌트 기본, 'use client'는 최소화

## 보안
- API 키는 환경 변수로만 (.env.local)
- 사용자 입력은 zod로 검증
- XSS 방지: dangerouslySetInnerHTML 금지`}
  language="markdown"
  filename="웹 애플리케이션 템플릿"
/>

### REST API 서버 (Express + TypeScript)

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
- **이름**: my-api-server
- **설명**: Express.js 기반 REST API 서버
- **기술 스택**: TypeScript, Express.js 4, PostgreSQL, Prisma

## 빠른 명령어
npm run dev          # 개발 서버 (nodemon)
npm test             # Jest 테스트
npm run build        # TypeScript 컴파일
npm run migrate      # Prisma 마이그레이션
npm run seed         # DB 시드 데이터

## 프로젝트 구조 (Clean Architecture)
src/
├── domain/           # 비즈니스 로직 (순수, 의존성 없음)
├── application/      # 유스케이스, 서비스
├── infrastructure/   # DB, 외부 API 연동
└── presentation/     # HTTP 컨트롤러, 라우트, 미들웨어

## 코딩 규칙
- 의존성 방향: presentation → application → domain
- domain 레이어는 외부 라이브러리 import 금지
- 에러: AppError 클래스 상속 (src/shared/errors/)
- 응답 형식: { data, meta, error } 표준 구조

## 보안
- 모든 엔드포인트 입력 검증 (zod)
- JWT 인증 (Bearer 토큰)
- Rate Limiting 적용 (express-rate-limit)
- SQL 인젝션 방지: Prisma ORM만 사용, raw query 금지`}
  language="markdown"
  filename="API 서버 템플릿"
/>

### 모바일 앱 (React Native)

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
- **이름**: my-mobile-app
- **설명**: React Native 기반 크로스플랫폼 모바일 앱
- **기술 스택**: TypeScript, React Native 0.74, Expo SDK 51

## 빠른 명령어
npx expo start       # 개발 서버
npx expo start --ios # iOS 시뮬레이터
npm test             # Jest 테스트
npx expo build       # 빌드

## 프로젝트 구조
src/
├── screens/          # 화면 컴포넌트
├── components/       # 공유 UI 컴포넌트
├── navigation/       # React Navigation 설정
├── hooks/            # 커스텀 훅
├── services/         # API 통신 레이어
├── stores/           # Zustand 상태 관리
└── utils/            # 유틸리티 함수

## 코딩 규칙
- 네비게이션: React Navigation v6 (TypedNavigator)
- 스타일: StyleSheet.create() 사용 (인라인 스타일 최소화)
- 비동기 저장: @react-native-async-storage
- 플랫폼 분기: Platform.select() 사용
- 접근성: accessibilityLabel 필수 (모든 인터랙티브 요소)

## 보안
- 민감 데이터는 expo-secure-store에 저장
- API 키는 .env (react-native-config)
- Deep Link URL 검증 필수`}
  language="markdown"
  filename="모바일 앱 템플릿"
/>

### 데이터 파이프라인 (Python)

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
- **이름**: my-data-pipeline
- **설명**: ETL 데이터 파이프라인
- **기술 스택**: Python 3.12, Apache Airflow, pandas, SQLAlchemy

## 빠른 명령어
python -m pytest              # 테스트
ruff check .                  # 린트
ruff format .                 # 포맷팅
airflow dags test my_dag      # DAG 테스트
docker compose up             # 로컬 Airflow 실행

## 프로젝트 구조
src/
├── dags/              # Airflow DAG 정의
├── operators/         # 커스텀 Airflow Operator
├── extractors/        # 데이터 추출 (Extract)
├── transformers/      # 데이터 변환 (Transform)
├── loaders/           # 데이터 적재 (Load)
├── schemas/           # Pydantic 스키마
└── utils/             # 유틸리티

## 코딩 규칙
- 파일명: snake_case.py (PEP 8)
- 타입 힌트 필수 (모든 함수 시그니처)
- docstring: Google 스타일
- pandas: method chaining 선호
- SQL: SQLAlchemy ORM 우선, raw SQL은 text() 래핑

## 보안
- DB 인증 정보: Airflow Connections으로 관리
- API 키: Airflow Variables (암호화)
- PII 데이터: 변환 단계에서 마스킹 처리`}
  language="markdown"
  filename="데이터 파이프라인 템플릿"
/>

---

## CLAUDE.local.md 활용법

`CLAUDE.local.md`는 **개인별 설정**을 담는 파일로, Git에 커밋되지 않습니다(자동으로 .gitignore에 추가). 팀 공유 규칙과 개인 선호를 깔끔하게 분리할 수 있습니다.

### 언제 CLAUDE.local.md를 사용하는가?

<ComparisonTable
  title="CLAUDE.md vs CLAUDE.local.md 사용 기준"
  headers={['설정 항목', 'CLAUDE.md (팀 공유)', 'CLAUDE.local.md (개인)']}
  rows={[
    { feature: '기술 스택 정의', values: ['yes', 'no'] },
    { feature: '코딩 컨벤션', values: ['yes', 'no'] },
    { feature: '보안 규칙', values: ['yes', 'no'] },
    { feature: '빠른 명령어', values: ['yes', 'no'] },
    { feature: '응답 언어 설정', values: ['no', 'yes'] },
    { feature: '개인 코딩 스타일', values: ['no', 'yes'] },
    { feature: '로컬 DB 접속 정보', values: ['no', 'yes'] },
    { feature: '에디터별 설정', values: ['no', 'yes'] },
    { feature: '디버깅 선호 방식', values: ['no', 'yes'] },
  ]}
/>

### 실전 CLAUDE.local.md 예시

<CodeBlock
  code={`# CLAUDE.local.md

## 개인 설정
- 모든 대답은 한국어로
- 코드 주석은 영어로 작성
- 설명은 비유와 예시를 많이 사용

## 로컬 환경
- Node.js v20.11.0
- PostgreSQL 포트: 5433 (기본 5432 아님)
- Redis 포트: 6380

## 디버깅 선호
- console.log보다 debugger 사용
- 에러 발생 시 스택 트레이스 전체 출력
- 테스트 실패 시 --verbose 플래그 추가

## 에디터
- VS Code 사용 중
- 확장: ESLint, Prettier, GitLens
- 터미널: zsh + oh-my-zsh`}
  language="markdown"
  filename="CLAUDE.local.md"
/>

<Callout type="warning" title="개인 정보 주의">
  CLAUDE.local.md에도 비밀번호, API 키 등 민감한 정보를 직접 기재하지 마세요.
  Git에 추적되지는 않지만, Claude Code의 프롬프트에 포함되어 API로 전송됩니다.
  시스템 사용자명, IP, 호스트 정보도 노출에 주의하세요.
</Callout>

---

## 글로벌 CLAUDE.md (~/. claude/CLAUDE.md)

홈 디렉토리의 `~/.claude/CLAUDE.md`는 **모든 프로젝트에 적용**되는 글로벌 설정입니다. 프로젝트에 관계없이 항상 적용하고 싶은 개인 선호를 여기에 작성합니다.

<CodeBlock
  code={`# ~/.claude/CLAUDE.md

# 글로벌 설정
- 대답은 항상 한국어로 해
- 항상 변경 사항은 모두 git commit & push
- 시스템 사용자명, IP, 호스트 정보가 절대로 프로젝트 코드에 노출되면 안됨
- 커밋 메시지는 Conventional Commits 형식 사용
- 코드 생성 시 기존 파일의 스타일과 패턴을 먼저 확인하고 따르기`}
  language="markdown"
  filename="~/.claude/CLAUDE.md"
/>

<Callout type="tip" title="글로벌 vs 프로젝트 설정 충돌">
  글로벌 설정과 프로젝트 설정이 충돌하면 **프로젝트 설정이 우선**합니다. 예를 들어, 글로벌에서 "한국어로 대답"을 설정하고 프로젝트에서 "영어로 대답"을 설정하면 해당 프로젝트에서는 영어로 대답합니다.
</Callout>

---

## Auto Memory 시스템 상세

Claude Code는 `~/.claude/projects/` 디렉토리에 **영구적인 자동 메모리**를 관리합니다. 대화 간에 유지되는 학습 내용을 기록하여, 세션이 바뀌어도 프로젝트에 대한 이해를 유지합니다.

### 메모리 디렉토리 구조

<MermaidDiagram
  chart={`flowchart TD
    A["~/.claude/projects/"] --> B["프로젝트-해시-1/"]
    A --> C["프로젝트-해시-2/"]

    B --> D["memory/"]
    D --> E["MEMORY.md<br/>(핵심 메모리, 200줄 제한)<br/>시스템 프롬프트에 자동 포함"]
    D --> F["debugging.md<br/>(디버깅 패턴)"]
    D --> G["patterns.md<br/>(코드 패턴)"]
    D --> H["decisions.md<br/>(아키텍처 결정)"]

    C --> I["memory/"]
    I --> J["MEMORY.md"]
  `}
  title="Auto Memory 디렉토리 구조"
  caption="MEMORY.md만 시스템 프롬프트에 자동 로드되고, 나머지는 참조용입니다"
/>

### MEMORY.md 작성 패턴

<CodeBlock
  code={`# Project Memory

## Project Overview
- Storybook 기반 MDX 교육 자료
- 29개 챕터, 6개 파트 구성
- 빌드: npm run build-storybook, 개발: npm run dev

## Key Patterns
- MDX 파일에서 Storybook <Meta title="..." /> 사용
- ChapterNav으로 이전/다음 네비게이션
- 코드 예시는 CodeBlock, 비교표는 ComparisonTable
- Callout 타입: info, tip, warning

## Common Mistakes
- TypeORM @Column() 데코레이터 누락 시 마이그레이션 실패
- Next.js 13+ app router에서 'use client' 누락 주의

## Useful Commands
- npm test -- --coverage --watchAll=false
- npx typeorm migration:run -d src/data-source.ts`}
  language="markdown"
  filename="MEMORY.md 예시"
/>

### Auto Memory 동작 원리

- **자동 기록**: Claude Code가 대화 중 중요한 패턴을 발견하면 MEMORY.md에 자동 추가
- **용량 제한**: MEMORY.md는 **200줄까지** 시스템 프롬프트에 포함
- **수동 편집**: `/memory` 커맨드로 시스템 에디터에서 직접 편집 가능
- **# 키**: 대화 중 `#`을 누르면 메모를 MEMORY.md에 빠르게 추가
- **분리 전략**: 200줄 이상의 상세 정보는 별도 파일(debugging.md, patterns.md)로 분리하고 MEMORY.md에서 참조

<Callout type="tip" title="메모리 관리 팁">
  MEMORY.md는 200줄까지 시스템 프롬프트에 포함됩니다. 상세한 내용은 별도 파일(debugging.md, patterns.md 등)로 분리하고 MEMORY.md에서 간략히 요약만 남기세요. 프로젝트의 "핵심 지식"만 MEMORY.md에 유지하는 것이 중요합니다.
</Callout>

---

## Compaction API와 CLAUDE.md의 관계

Claude Code는 컨텍스트 윈도우가 채워지면 자동으로 대화를 요약하여 **사실상 무한한 대화**를 지원합니다. 이때 CLAUDE.md와의 관계를 이해하는 것이 중요합니다.

### Compaction 발동 시 보존되는 것

<MermaidDiagram
  chart={`flowchart LR
    subgraph Before["Compaction 전"]
      A["시스템 프롬프트"]
      B["CLAUDE.md"]
      C["MEMORY.md"]
      D["대화 이력 (긴 대화)"]
      E["도구 실행 결과들"]
    end

    F[/"Compaction 실행"/]

    subgraph After["Compaction 후"]
      G["시스템 프롬프트 (유지)"]
      H["CLAUDE.md (유지)"]
      I["MEMORY.md (유지)"]
      J["대화 요약 (압축됨)"]
    end

    Before --> F --> After
  `}
  title="Compaction 전후 비교"
  caption="CLAUDE.md와 MEMORY.md는 항상 유지되지만, 대화 이력은 요약됩니다"
/>

| 방식 | 트리거 | 보존 내용 | 명령어 |
|------|--------|-----------|--------|
| Auto Compact | 컨텍스트 임계값 도달 시 자동 | 핵심 컨텍스트 + 최근 대화 | (자동) |
| Manual Compact | 사용자 수동 실행 | 사용자 지정 보존 지시사항 | /compact [지시사항] |
| Clear | 전체 초기화 | 없음 (새 세션) | /clear |

### CLAUDE.md와 Compaction의 시너지

<CodeBlock
  code={`# Compaction 시 CLAUDE.md의 역할

# 1. CLAUDE.md에 핵심 규칙이 잘 정리되어 있으면
#    Compaction 후에도 규칙이 보존됩니다.
#    → CLAUDE.md는 Compaction에 영향받지 않음

# 2. 그러나 대화 중에 구두로 전달한 임시 규칙은
#    Compaction 시 손실될 수 있습니다.
#    → 반복적으로 전달하는 규칙은 CLAUDE.md에 추가하세요

# 3. 수동 Compaction으로 보존할 내용 지정
/compact 현재 작업 중인 인증 모듈의 설계 결정과 미완료 TODO를 보존해줘

# 4. 자동 Compaction 설정 (Claude Code v2.0.64+)
# 대기 시간 없이 즉시 압축 실행`}
  language="text"
  filename="Compaction 활용법"
/>

<Callout type="info" title="Compaction 활용 팁">
  Anthropic은 긴 세션에서 /compact를 적극 활용할 것을 권장합니다. 특히 작업 전환 시 이전 작업의 핵심 결정사항만 보존하면 새 작업의 품질이 향상됩니다. CLAUDE.md에 핵심 규칙이 잘 정리되어 있다면, Compaction 후에도 Claude는 프로젝트 규칙을 정확히 따릅니다.
</Callout>

---

## 팀 규모별 CLAUDE.md 운영 전략

### 1인 개발자

<CodeBlock
  code={`# 1인 개발 — 간단하게 운영

# 구조:
project/
├── CLAUDE.md              # 프로젝트 규칙 (50~80줄)
└── CLAUDE.local.md        # 개인 설정 (선택적)

# 포인트:
# - 팀 공유가 없으므로 CLAUDE.md에 개인 선호 포함 가능
# - Rules 디렉토리는 프로젝트가 커지면 도입
# - MEMORY.md로 개인 학습 내용 축적`}
  language="text"
  filename="1인 개발자 전략"
/>

### 소규모 팀 (2~5명)

<CodeBlock
  code={`# 소규모 팀 — 핵심 규칙 공유

# 구조:
project/
├── CLAUDE.md              # 팀 공유 규칙 (80~120줄)
├── .claude/
│   └── rules/
│       ├── frontend.md    # 프론트엔드 담당자 규칙
│       └── backend.md     # 백엔드 담당자 규칙
└── CLAUDE.local.md        # 각자 개인 설정

# 포인트:
# - CLAUDE.md는 PR 리뷰 대상 (팀 합의 필요)
# - 개인 선호는 CLAUDE.local.md로 분리
# - 새 팀원 온보딩 시 CLAUDE.md가 프로젝트 가이드 역할
# - 주 1회 CLAUDE.md 리뷰 미팅 권장`}
  language="text"
  filename="소규모 팀 전략"
/>

### 중규모 팀 (6~20명)

<CodeBlock
  code={`# 중규모 팀 — 모듈화 + CODEOWNERS

# 구조:
project/
├── CLAUDE.md                  # 전체 팀 규칙 (100~150줄)
├── .claude/
│   └── rules/
│       ├── frontend.md        # 프론트엔드 팀
│       ├── backend.md         # 백엔드 팀
│       ├── database.md        # DBA/인프라 팀
│       ├── testing.md         # QA 팀
│       └── security.md        # 보안 팀
├── CLAUDE.local.md            # 개인 설정
└── src/
    ├── frontend/CLAUDE.md     # 프론트엔드 서브트리 메모리
    └── backend/CLAUDE.md      # 백엔드 서브트리 메모리

# CODEOWNERS 설정:
# CLAUDE.md            @tech-lead @architecture-team
# .claude/rules/*.md   @tech-lead
# src/frontend/CLAUDE.md  @frontend-lead

# 포인트:
# - CODEOWNERS로 CLAUDE.md 변경 리뷰 강제
# - 팀별 Rules 파일 관리 담당자 지정
# - 서브트리 CLAUDE.md로 모듈별 규칙 분리
# - 월 1회 전체 CLAUDE.md 점검`}
  language="text"
  filename="중규모 팀 전략"
/>

### 대규모 팀 / 엔터프라이즈 (20명+)

<CodeBlock
  code={`# 대규모 팀 — Enterprise 정책 + 계층 구조

# 구조:
# (시스템 디렉토리)
/Library/Application Support/ClaudeCode/
└── CLAUDE.md                  # Enterprise 정책 (보안팀 관리)

# (프로젝트)
project/
├── CLAUDE.md                  # 프로젝트 공통 규칙
├── .claude/
│   └── rules/
│       ├── common.md          # 공통 규칙
│       ├── team-alpha.md      # 팀 Alpha 규칙
│       ├── team-beta.md       # 팀 Beta 규칙
│       ├── security.md        # 보안 규칙 (보안팀 관리)
│       └── compliance.md      # 컴플라이언스 규칙
├── packages/
│   ├── web/CLAUDE.md          # 웹 서비스 규칙
│   ├── api/CLAUDE.md          # API 서비스 규칙
│   └── shared/CLAUDE.md       # 공유 라이브러리 규칙
└── CLAUDE.local.md            # 개인 설정

# 포인트:
# - Enterprise 정책으로 보안 규칙 강제
# - Monorepo의 각 패키지별 CLAUDE.md
# - 보안/컴플라이언스 규칙은 별도 팀이 관리
# - CI에서 CLAUDE.md 린트 검사 (필수 섹션 존재 여부)
# - 분기별 감사: CLAUDE.md와 실제 코드 일치 여부 확인`}
  language="text"
  filename="대규모 팀 전략"
/>

<ComparisonTable
  title="팀 규모별 CLAUDE.md 운영 비교"
  headers={['항목', '1인', '소규모 (2~5)', '중규모 (6~20)', '대규모 (20+)']}
  rows={[
    { feature: 'CLAUDE.md 줄 수', values: ['50~80', '80~120', '100~150', '100~150'] },
    { feature: 'Rules 파일 수', values: ['0~2', '2~4', '4~8', '5~10+'] },
    { feature: 'CODEOWNERS 사용', values: ['no', 'no', 'yes', 'yes'] },
    { feature: 'Enterprise 정책', values: ['no', 'no', 'no', 'yes'] },
    { feature: '서브트리 CLAUDE.md', values: ['no', 'no', 'yes', 'yes'] },
    { feature: '점검 주기', values: ['수시', '주 1회', '월 1회', '분기별'] },
    { feature: 'CI 린트 검사', values: ['no', 'no', 'partial', 'yes'] },
  ]}
/>

---

## 유용한 커맨드

| 커맨드 | 설명 |
|--------|------|
| `/init` | 현재 프로젝트를 분석하여 CLAUDE.md 자동 생성 |
| `/memory` | 시스템 에디터에서 메모리 파일 직접 편집 |
| `#` 키 | 대화 중 메모리에 지침 빠르게 추가 |
| `/compact` | 컨텍스트 압축 (긴 세션에서 메모리 효율화) |
| `/clear` | 대화 초기화 (작업 전환 시) |

<Callout type="info" title="/init으로 시작하기">
  Claude Code에서 `/init` 명령어를 실행하면 현재 프로젝트의 구조, 의존성, 설정 파일을 분석하여
  CLAUDE.md 초안을 자동 생성합니다. 이를 기반으로 프로젝트에 맞게 다듬어 나가세요.
</Callout>

---

## CLAUDE.md vs Hook vs Rules

각 설정 방법의 적합한 용도가 다릅니다:

<ComparisonTable
  title="설정 방법별 특성 비교"
  headers={['속성', 'CLAUDE.md', 'Hook', 'Rules']}
  rows={[
    { feature: '실행 보장', values: ['권고 (advisory)', '보장 (deterministic)', '조건부 권고'] },
    { feature: '용도', values: ['일반 코딩 컨벤션', '매번 반드시 실행할 작업', '특정 파일/디렉토리 규칙'] },
    { feature: '적용 범위', values: ['전체 프로젝트', '특정 이벤트', '특정 파일 패턴'] },
    { feature: '예시', values: ['"함수는 30줄 이내"', '커밋 전 린트 실행', '"React 컴포넌트는 함수형"'] },
    { feature: 'Git 추적', values: ['yes', 'yes', 'yes'] },
    { feature: 'Claude 무시 가능?', values: ['yes', 'no', 'yes'] },
  ]}
/>

<CodeBlock
  code={`# 설정 방법 선택 가이드

# "함수 길이 30줄 이내로 작성" → CLAUDE.md
# → Claude가 대부분 잘 따르지만 가끔 무시할 수 있음

# "커밋 전 반드시 npm run lint 실행" → Hook
# → 100% 실행이 보장됨 (Claude가 건너뛸 수 없음)

# "src/components/** 에서만 Tailwind CSS 사용" → Rules
# → 해당 디렉토리 작업 시에만 조건부로 적용`}
  language="text"
  filename="설정 방법 선택 가이드"
/>

---

## 실전 CLAUDE.md 점검 체크리스트

프로젝트의 CLAUDE.md가 효과적으로 작동하는지 정기적으로 점검하세요.

### 구조 점검

- [ ] 프로젝트 개요가 간결하게 정리되어 있는가? (기술 스택, 이름, 설명)
- [ ] 빠른 명령어가 최신 상태인가? (dev, test, build, lint)
- [ ] 프로젝트 디렉토리 구조가 실제와 일치하는가?
- [ ] 전체 길이가 150줄 이내인가? (초과 시 Rules로 분리 검토)

### 규칙 품질

- [ ] 모든 규칙이 구체적이고 실행 가능한가? (모호한 표현 없음)
- [ ] 규칙의 강도가 구분되어 있는가? (절대 금지 / 필수 / 권장)
- [ ] Claude가 이미 잘 하는 것을 불필요하게 명시하지 않았는가?
- [ ] 예시 코드가 포함되어 있는가? (특히 네이밍, 구조 관련)

### 보안

- [ ] 보안 규칙 섹션이 존재하는가?
- [ ] 하드코딩된 시크릿 금지 규칙이 있는가?
- [ ] 입력 검증 규칙이 있는가?
- [ ] 시스템 정보(사용자명, IP, 호스트) 노출 방지 규칙이 있는가?

### 운영

- [ ] CLAUDE.local.md가 .gitignore에 포함되어 있는가?
- [ ] 팀원 간 개인 설정이 CLAUDE.md에 혼합되지 않았는가?
- [ ] Rules 파일의 paths 패턴이 실제 디렉토리와 일치하는가?
- [ ] 마지막 점검 날짜가 3개월 이내인가?

### 최적화

- [ ] 임포트(@) 구문으로 외부 문서를 효과적으로 참조하는가?
- [ ] 서브트리 CLAUDE.md가 필요한 대규모 모듈이 있는가?
- [ ] 반복적으로 전달하는 구두 지시가 있다면 CLAUDE.md에 추가했는가?
- [ ] Hook으로 전환해야 할 필수 규칙이 없는가?

<Callout type="tip" title="점검 루틴 자동화">
  이 체크리스트를 `.claude/commands/check-claude-md.md` 스킬로 작성하면 `/check-claude-md` 커맨드로 Claude에게 자동 점검을 요청할 수 있습니다.
</Callout>

---

## CLAUDE.md 설정 파일 비교

다른 AI 코딩 도구들의 프로젝트 설정 방식과 비교합니다.

<ComparisonTable
  title="AI 코딩 도구별 프로젝트 설정 비교"
  headers={['기능', 'Claude Code', 'GitHub Copilot', 'Cursor', 'Aider']}
  rows={[
    { feature: '설정 파일명', values: ['CLAUDE.md', 'copilot-instructions.md', '.cursor/rules/', 'CONVENTIONS.md'] },
    { feature: '설정 위치', values: ['프로젝트 루트 / .claude/', '.github/', '.cursor/', '프로젝트 루트'] },
    { feature: '계층 구조', values: ['yes', 'partial', 'yes', 'no'] },
    { feature: '글로벌 설정', values: ['~/.claude/CLAUDE.md', 'VS Code settings', '~/.cursor/rules/', 'no'] },
    { feature: '조건부 적용', values: ['paths 프론트매터', 'no', 'globs 패턴', 'no'] },
    { feature: '임포트 구문', values: ['@path/to/file', 'no', 'no', 'no'] },
    { feature: '개인 설정 분리', values: ['CLAUDE.local.md', 'no', 'no', 'no'] },
    { feature: '자동 메모리', values: ['MEMORY.md', 'no', 'no', 'no'] },
    { feature: '서브트리 설정', values: ['하위 디렉토리 CLAUDE.md', 'no', 'no', 'no'] },
    { feature: 'Enterprise 정책', values: ['시스템 디렉토리', 'no', 'no', 'no'] },
  ]}
/>

<Callout type="info" title="멀티 도구 프로젝트">
  팀에서 Claude Code와 Cursor를 동시에 사용한다면, 공통 규칙은 별도 마크다운 파일(예: `docs/coding-conventions.md`)에 작성하고, CLAUDE.md와 .cursor/rules/ 양쪽에서 임포트하거나 참조하는 방식이 효율적입니다.
</Callout>

---

## 고급 패턴: CLAUDE.md 활용 사례

### 패턴 1: 코드 생성 템플릿 참조

<CodeBlock
  code={`# CLAUDE.md에서 코드 생성 패턴 안내

## 새 서비스 생성 시 참조
- 템플릿: src/services/_template.ts
- 모든 서비스는 BaseService를 상속
- 필수 메서드: validate(), execute(), rollback()
- 에러 처리: ServiceError 클래스 사용

## 새 API 엔드포인트 생성 시
- 템플릿: src/routes/_template.ts
- 라우트 파일명: {resource}.routes.ts
- 컨트롤러 파일명: {resource}.controller.ts
- 입력 검증 스키마: {resource}.schema.ts`}
  language="markdown"
  filename="코드 생성 패턴"
/>

### 패턴 2: 마이그레이션 가이드 포함

<CodeBlock
  code={`# CLAUDE.md에 마이그레이션 컨텍스트 포함

## 현재 진행 중인 마이그레이션
- Express → Fastify 전환 중 (60% 완료)
- 새 코드는 Fastify로 작성
- src/routes-legacy/ = Express (건드리지 않음)
- src/routes/ = Fastify (새 코드)
- 기존 Express 미들웨어를 Fastify 플러그인으로 전환 시
  src/migration/middleware-mapping.md 참조`}
  language="markdown"
  filename="마이그레이션 가이드"
/>

### 패턴 3: AI 작업별 지침 분리

<CodeBlock
  code={`# CLAUDE.md — AI 작업 지침

## 코드 생성 시
1. 기존 패턴과 스타일 따르기 (같은 디렉토리의 파일 참조)
2. 테스트 코드 함께 작성
3. 에러 처리 포함
4. 새 의존성 추가 전 기존 라이브러리로 해결 가능한지 확인

## 리뷰 시
1. 보안 취약점 우선 확인
2. 에러 처리 검증
3. 성능 이슈 체크 (N+1, 불필요한 루프)
4. 네이밍/스타일 컨벤션 준수 여부

## 리팩토링 시
1. 기존 테스트가 모두 통과하도록 유지
2. 한 번에 하나의 리팩토링만 수행
3. 변경 전후 동작이 동일해야 함 (regression 방지)
4. 커밋은 리팩토링 단위로 분리

## 디버깅 시
1. 에러 메시지와 스택 트레이스 먼저 분석
2. 관련 코드 최소 범위로 확인
3. 가설 → 검증 → 수정 순서 진행
4. 수정 후 반드시 테스트 추가`}
  language="markdown"
  filename="작업별 AI 지침"
/>

---

## 자주 묻는 질문 (FAQ)

### Q: CLAUDE.md와 .claude/CLAUDE.md 중 어디에 작성해야 하나요?

둘 다 프로젝트 레벨 설정이며, 둘 다 존재하면 모두 로드됩니다. 관례적으로 **프로젝트 루트의 CLAUDE.md**를 주로 사용합니다. `.claude/CLAUDE.md`는 프로젝트 루트를 깔끔하게 유지하고 싶을 때 사용합니다.

### Q: CLAUDE.md가 너무 길어졌어요. 어떻게 줄이나요?

1. **Rules 파일로 분리**: 도메인별 규칙을 `.claude/rules/`로 이동
2. **임포트 활용**: 상세 문서는 `@docs/...`로 참조
3. **불필요한 규칙 삭제**: Claude가 이미 잘 하는 것 제거
4. **서브트리 CLAUDE.md 활용**: 모듈별 규칙을 해당 디렉토리로 이동

### Q: CLAUDE.md에 예시 코드를 포함해야 하나요?

**네, 핵심 패턴에 대해서는 짧은 예시를 포함하세요.** "함수 네이밍은 camelCase"라고만 쓰는 것보다 `getUserById`, `calculateTotalPrice` 같은 구체적 예시가 있으면 Claude가 더 일관된 코드를 생성합니다. 단, 예시가 너무 길면 토큰 낭비이니 1~3줄 이내로 유지하세요.

### Q: MEMORY.md는 직접 편집해도 되나요?

**네, 편집을 권장합니다.** `/memory` 커맨드로 시스템 에디터에서 편집하거나, `#` 키로 대화 중에 메모를 추가할 수 있습니다. 자동으로 쌓인 내용 중 불필요한 것은 정리하고, 핵심 학습 내용만 유지하세요.

### Q: 여러 프로젝트에서 공통 규칙을 공유하려면?

1. **글로벌 CLAUDE.md** (`~/.claude/CLAUDE.md`)에 공통 규칙 작성
2. 또는 공통 규칙을 별도 저장소에 관리하고, 각 프로젝트의 CLAUDE.md에서 `@` 임포트로 참조
3. Enterprise 환경에서는 시스템 디렉토리에 조직 정책 배치

---

## 요약: CLAUDE.md 작성의 핵심 원칙

1. **간결하게**: 100~150줄 이내, 핵심만 담기
2. **구체적으로**: "좋은 코드" 대신 "함수 30줄 이내, camelCase 네이밍"
3. **구조적으로**: 강도 구분 (절대 금지 > 필수 > 권장), 섹션별 정리
4. **모듈화**: Rules 파일, 서브트리 CLAUDE.md, 임포트 구문 활용
5. **보안 우선**: 보안 규칙은 반드시 포함, 최상단 배치
6. **정기 점검**: 실제 코드와의 일치 여부 확인, 불필요한 규칙 제거
7. **팀 분리**: 공유 규칙(CLAUDE.md)과 개인 선호(CLAUDE.local.md) 분리

<ChapterNav
  prev={{ title: '개발 환경 설정', path: '/docs/part-1--기초-개발-환경-설정' }}
  next={{ title: '프롬프트 엔지니어링', path: '/docs/part-1--기초-프롬프트-엔지니어링' }}
/>
