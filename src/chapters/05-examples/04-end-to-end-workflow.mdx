import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { Timeline } from '../../components/Timeline';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/End-to-End 워크플로우" />

# End-to-End 워크플로우

> 요구사항부터 PR 머지까지, Claude Code로 전체 개발 사이클 수행하기

## 시나리오

기존 Express.js API 프로젝트에 **"사용자 프로필 이미지 업로드"** 기능을 추가하는 실전 워크플로우입니다. Part 1에서 배운 프롬프트 기법, Part 3의 워크플로우 도구들, Part 4의 MCP 통합을 모두 활용합니다.

<MermaidDiagram
  chart={`flowchart LR
    A["1. 요구사항\n분석"] --> B["2. 설계\n(Plan Mode)"]
    B --> C["3. 구현"]
    C --> D["4. 테스트"]
    D --> E["5. 코드 리뷰"]
    E --> F["6. PR 생성"]
    style A fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style F fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="End-to-End 워크플로우 6단계"
  caption="예시 워크플로우: Explore → Plan → Implement → Commit"
/>

---

## 1단계: 요구사항 분석 (Explore)

먼저 기존 코드베이스를 탐색하여 현재 구조를 파악합니다.

<CodeBlock
  code={`# 인터뷰 패턴: Claude에게 질문을 먼저 받기
> 사용자 프로필 이미지 업로드 기능을 추가하려고 해.
> 구현을 시작하기 전에 내가 결정해야 할 사항들을 질문해줘.

# Claude의 질문 예시:
# 1. 이미지 저장소: 로컬 파일 시스템 vs S3 vs CloudFlare R2?
# 2. 이미지 크기 제한과 허용 포맷은?
# 3. 리사이즈/썸네일 생성이 필요한가?
# 4. 기존 User 모델에 profileImageUrl 필드를 추가하면 되는가?
# 5. 인증된 사용자만 업로드 가능한가?

# 개발자 답변 후 → Claude가 스펙 정리`}
  language="text"
  filename="1단계: 요구사항 인터뷰"
/>

<CodeBlock
  code={`# 서브에이전트로 코드베이스 탐색 (메인 컨텍스트 보존)
> 서브에이전트를 사용해서 현재 프로젝트의 파일 업로드 관련 코드가 있는지,
> User 모델 구조는 어떤지, 인증 미들웨어는 어떻게 구현되어 있는지 조사해줘.`}
  language="text"
  filename="서브에이전트로 탐색"
/>

<Callout type="tip" title="컨텍스트 보존 전략">
  탐색을 서브에이전트에 위임하면 메인 세션의 컨텍스트가 깨끗하게 유지됩니다.
  탐색 결과만 요약되어 돌아오므로 이후 구현 단계에서 컨텍스트가 부족해지는 문제를 방지합니다.
</Callout>

---

## 2단계: 설계 (Plan Mode)

`Shift+Tab`을 2회 눌러 Plan Mode에 진입합니다 (Normal → Auto-accept → **Plan Mode**). Plan Mode에서는 Claude가 파일을 수정하지 않고 **읽기와 계획만** 수행합니다.

<CodeBlock
  code={`# Plan Mode 진입 후
> 다음 요구사항으로 구현 계획을 세워줘:
> - S3에 이미지 저장 (aws-sdk v3 사용)
> - 최대 5MB, JPEG/PNG/WebP만 허용
> - Sharp로 200x200 썸네일 생성
> - User 모델에 profileImageUrl 필드 추가
> - 인증된 사용자만 업로드 가능
> - 기존 auth 미들웨어 패턴을 따를 것

# Claude의 계획 출력 예시:
# 1. 새 파일: src/infrastructure/storage/s3-client.ts
# 2. 새 파일: src/application/user/upload-avatar.use-case.ts
# 3. 수정: src/domain/user/entity.ts (profileImageUrl 필드 추가)
# 4. 수정: User 모델에 profileImageUrl 필드 추가
# 5. 새 파일: src/presentation/api/users/upload-avatar.ts
# 6. 새 파일: src/__tests__/upload-avatar.test.ts

# 계획 승인 후 Shift+Tab 2회로 구현 모드로 전환`}
  language="text"
  filename="2단계: Plan Mode에서 설계"
/>

<Callout type="info" title="Plan Mode 활용 팁">
  - **확장 사고(Extended Thinking)**: 기본적으로 **활성화**되어 있으며, 필요 시 설정이나 토글(Option/Alt+T)로 끌 수 있습니다 ([Anthropic Docs](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)).
  - **계획 저장**: 복잡한 기능은 계획을 별도 마크다운 파일로 저장하면 세션 간 참조 가능
  - **위험도 매칭**: 고위험 변경(DB 스키마, 인증)은 Plan Mode에서 충분히 검토한 후 구현
</Callout>

---

## 3단계: 구현 (Implement)

계획이 승인되면 단계별로 구현합니다.

<CodeBlock
  code={`# 3-1. 도메인 레이어 수정
> 계획의 1단계를 실행해줘. User 엔터티에 profileImageUrl 필드를 추가해줘.

# 3-2. 인프라 레이어 구현
> S3 클라이언트를 구현해줘. 기존 src/infrastructure/ 패턴을 따르고,
> 환경 변수로 버킷명과 리전을 설정할 수 있게 해줘.

# 3-3. 유스케이스 구현
> 이미지 업로드 유스케이스를 구현해줘.
> - 파일 크기 5MB 제한
> - JPEG, PNG, WebP만 허용
> - Sharp로 200x200 썸네일 생성
> - 원본과 썸네일 모두 S3에 저장
> 구현 후 테스트를 실행해줘.

# 3-4. API 라우터 구현
> @src/presentation/api/users/ 패턴을 따라 업로드 엔드포인트를 추가해줘.
> multer로 multipart/form-data를 처리하고, 기존 authMiddleware를 사용해.`}
  language="text"
  filename="3단계: 단계별 구현 프롬프트"
/>

<Callout type="warning" title="검증 수단을 항상 포함하세요">
  각 단계에서 "구현 후 테스트를 실행해줘"를 포함하면 Claude가 **자기 검증 루프(self-verification loop)**를 수행합니다. Anthropic 문서는 테스트 실행을 통한 검증을 꾸준히 권장합니다.
</Callout>

### Claude가 생성하는 것

각 단계에서 Claude는 기존 프로젝트 패턴에 맞춰 파일을 생성/수정합니다:
- **Domain**: User 엔터티에 `profileImageUrl` 필드 추가
- **Infrastructure**: S3 클라이언트 — 환경 변수로 버킷/리전 설정
- **Application**: `UploadAvatarUseCase` — 파일 검증 → 썸네일 생성 → S3 업로드 → DB 업데이트
- **Presentation**: multer로 multipart/form-data 처리하는 API 엔드포인트

"구현 후 테스트를 실행해줘"가 포함된 단계에서는 Claude가 자동으로 테스트를 돌리고, 실패하면 수정합니다.

---

## 4단계: 테스트

<CodeBlock
  code={`# 테스트 작성 요청 (구체적으로!)
> upload-avatar.use-case.ts의 테스트를 작성해줘.
> 다음 케이스를 커버해:
> 1. 정상 업로드 (JPEG 1MB)
> 2. 파일 크기 초과 (6MB)
> 3. 허용하지 않는 파일 타입 (GIF)
> 4. S3 업로드 실패 시 에러 처리
> 5. 썸네일이 200x200으로 생성되는지
>
> S3Client는 mock하고, sharp은 실제 동작을 테스트해.
> 테스트 작성 후 실행까지 해줘.`}
  language="text"
  filename="4단계: 테스트 작성 프롬프트"
/>

<Callout type="tip" title="테스트 프롬프트 작성법">
  테스트 케이스를 **번호로 나열**하면 Claude가 빠뜨리지 않습니다. "테스트를 작성해줘"보다 "다음 5개 케이스를 커버해줘"가 훨씬 정확한 결과를 만듭니다.
</Callout>

---

## 5단계: 코드 리뷰 (새 세션)

Writer/Reviewer 패턴으로 새 세션에서 리뷰합니다.

<CodeBlock
  code={`# 새 터미널/세션에서 리뷰
> git diff main 의 변경사항을 리뷰해줘. 다음을 중점적으로 확인해:
> 1. 보안: 파일 업로드 시 취약점 (파일명 인젝션, MIME 위장 등)
> 2. 에러 처리: 모든 실패 경로가 적절히 처리되는지
> 3. 성능: 대용량 파일 처리 시 메모리 이슈가 없는지
> 4. 테스트 커버리지: 엣지 케이스가 충분히 커버되는지`}
  language="text"
  filename="5단계: 새 세션에서 코드 리뷰"
/>

<Callout type="info" title="Writer/Reviewer 패턴">
  구현한 세션과 **다른 세션**에서 리뷰하면, 새로운 컨텍스트의 Claude가
  구현 과정의 편향 없이 객관적으로 코드를 평가합니다.
  이 패턴은 Anthropic 공식 블로그와 커뮤니티에서 널리 권장됩니다.
</Callout>

### 리뷰에서 자주 발견되는 이슈

<ComparisonTable
  title="파일 업로드 보안 점검 항목"
  headers={['취약점', '위험', '대응 방법']}
  rows={[
    { feature: 'MIME 위장', values: ['확장자를 바꿔 실행 파일 업로드', 'magic bytes 검증 (file-type 라이브러리)'] },
    { feature: '파일명 인젝션', values: ['../../ 경로로 디렉토리 탐색', 'UUID로 파일명 생성, 원본 파일명 미사용'] },
    { feature: '무제한 업로드', values: ['디스크/메모리 고갈', 'multer limits 설정 (5MB)'] },
    { feature: '미인증 접근', values: ['누구나 이미지 업로드', 'authMiddleware 필수 적용'] },
  ]}
/>

---

## 6단계: PR 생성

<CodeBlock
  code={`# 리뷰 반영 후 커밋 & PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.
> PR 설명에 다음을 포함해:
> - 기능 요약
> - 변경된 파일 목록과 이유
> - 테스트 방법
> - AI 사용 내역

# Claude가 자동으로:
# 1. git add & commit (Conventional Commits 형식)
# 2. git push
# 3. gh pr create (GitHub CLI)`}
  language="text"
  filename="6단계: PR 생성"
/>

---

## 전체 프롬프트 요약

<ComparisonTable
  title="단계별 핵심 프롬프트 패턴"
  headers={['단계', '핵심 기법', '목적']}
  rows={[
    { feature: '1. 요구사항', values: ['인터뷰 패턴 + 서브에이전트 탐색', '정확한 스펙 확정 + 컨텍스트 보존'] },
    { feature: '2. 설계', values: ['Plan Mode (Shift+Tab)', '코드 수정 없이 계획만 수립'] },
    { feature: '3. 구현', values: ['단계별 분할 + 검증 포함', '각 단계를 독립적으로 검증'] },
    { feature: '4. 테스트', values: ['구체적 테스트 케이스 번호 나열', '엣지 케이스까지 커버'] },
    { feature: '5. 리뷰', values: ['Writer/Reviewer 패턴', '편향 없는 객관적 리뷰'] },
    { feature: '6. PR', values: ['AI 사용 내역 포함', '투명한 AI 활용 기록'] },
  ]}
/>

---

## 실패 시 대처

<CodeBlock
  code={`# 같은 이슈로 2번 이상 실패했을 때
/clear
# 더 나은 프롬프트로 새 세션 시작

# 특정 체크포인트로 되돌리기
> 직전 작업을 취소하고 이전 상태로 돌아가줘

# 구현 중 방향이 잘못되었을 때
# Esc를 눌러 즉시 중단 → 방향 수정 후 재지시`}
  language="bash"
  filename="실패 대처 명령어"
/>

### 실패 시나리오별 대응 전략

<ComparisonTable
  title="실패 시나리오와 대응"
  headers={['상황', '증상', '대응']}
  rows={[
    { feature: '같은 에러 반복', values: ['동일 수정을 2회 이상 시도', '/clear 후 에러 메시지와 함께 새 세션 시작'] },
    { feature: '컨텍스트 소진', values: ['Claude 응답 품질 저하, 이전 내용 잊음', '/clear 후 핵심 컨텍스트만 다시 제공'] },
    { feature: '잘못된 방향', values: ['구현이 요구사항과 다른 방향으로 진행', 'Esc로 중단, Plan Mode로 전환하여 재설계'] },
    { feature: '테스트 실패', values: ['구현은 완료했으나 테스트가 통과하지 않음', '실패 로그를 복사하여 "이 테스트 실패를 수정해줘" 요청'] },
  ]}
/>

<Callout type="tip" title="Hooks 활용으로 품질 자동화">
  Part 3에서 배운 Hooks를 설정하면 이 워크플로우가 더 강력해집니다:
  - `PostToolUse` + `Edit|Write` → 자동 포맷팅 (Prettier)
  - `Stop` + `agent` → 매 응답 후 자동 테스트 실행
  - `PreToolUse` + `Bash` → 위험 명령 차단
</Callout>

---

## 실습: 전체 워크플로우 직접 해보기

아래 프롬프트를 순서대로 Claude Code에 입력하여 전체 워크플로우를 체험합니다.

<CodeBlock
  code={`# === 실습 시나리오: 기존 API에 "비밀번호 변경" 기능 추가 ===

# 1단계: 요구사항 인터뷰
> 사용자 비밀번호 변경 기능을 추가하려고 해.
> 구현 전에 내가 결정해야 할 사항들을 질문해줘.

# (Claude의 질문에 답변: 현재 비밀번호 확인 필요, bcrypt 사용,
#  최소 8자, 최근 3개 비밀번호 재사용 금지)

# 2단계: 설계 (Shift+Tab 2회로 Plan Mode 진입)
> 다음 요구사항으로 구현 계획을 세워줘:
> - 현재 비밀번호 확인 후 변경
> - bcrypt로 해싱
> - 최소 8자, 대소문자+숫자+특수문자 포함
> - 최근 3개 비밀번호 재사용 금지
> - 변경 후 이메일 알림 발송

# 3단계: 구현 (Shift+Tab 2회로 구현 모드)
> 계획을 실행해줘. Domain Layer부터 시작해서
> 각 레이어를 순서대로 구현해줘.
> 각 단계마다 테스트를 실행해줘.

# 4단계: 테스트
> 다음 케이스를 커버하는 테스트를 작성하고 실행해줘:
> 1. 정상 비밀번호 변경
> 2. 현재 비밀번호 불일치
> 3. 새 비밀번호가 정책 미충족 (8자 미만, 특수문자 없음 등)
> 4. 최근 3개 비밀번호 재사용 시도
> 5. 미인증 사용자 접근

# 5단계: 리뷰 (새 세션에서)
> git diff main 의 변경사항을 리뷰해줘.
> 보안, 에러 처리, 테스트 커버리지를 중점 확인해.

# 6단계: PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.`}
  language="text"
  filename="실습: 비밀번호 변경 기능 전체 워크플로우"
/>

---

## 실습: 프론트엔드 워크플로우 직접 해보기

백엔드 시나리오와 별도로, 프론트엔드 기능을 처음부터 구현하는 워크플로우입니다.

<CodeBlock
  code={`# === 실습 시나리오: React 대시보드에 "알림 센터" 추가 ===

# 1단계: 요구사항 인터뷰
> 대시보드 헤더에 알림 센터(벨 아이콘 + 드롭다운)를 추가하려고 해.
> 구현 전에 내가 결정해야 할 사항들을 질문해줘.

# (Claude 질문 예시: 실시간 vs 폴링, 읽음/안읽음 구분,
#  알림 타입, 최대 표시 개수, 알림 클릭 시 동작)

# 2단계: 타입 먼저 정의 (Plan Mode)
> 다음 요구사항으로 타입과 구현 계획을 세워줘:
> - 알림 타입: info, warning, error, success
> - 읽음/안읽음 상태
> - 최대 50개, 오래된 순 자동 삭제
> - 벨 아이콘에 안읽은 알림 수 배지
> - 드롭다운에 알림 목록, "모두 읽음" 버튼

# 3단계: 구현
> @src/types/dashboard.ts 에 NotificationProps 타입을 추가하고,
> @src/components/dashboard/StatCard.tsx 패턴을 따라
> NotificationBell 컴포넌트를 구현해줘.
> useNotifications 커스텀 훅도 만들어줘.
> 구현 후 테스트를 실행해줘.

# 4단계: 테스트
> 다음 케이스를 커버하는 테스트를 작성하고 실행해줘:
> 1. 알림이 없을 때 배지 숨김
> 2. 안읽은 알림 수 배지 표시
> 3. 벨 클릭 시 드롭다운 토글
> 4. 알림 클릭 시 읽음 처리
> 5. "모두 읽음" 클릭 시 전체 읽음
> 6. 키보드 접근성 (Enter로 토글, Esc로 닫기)

# 5단계: 리뷰 (새 세션에서)
> git diff main 의 변경사항을 리뷰해줘.
> 접근성, 메모리 누수(이벤트 리스너 cleanup), 상태 관리를 중점 확인해.

# 6단계: PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.`}
  language="text"
  filename="실습: 알림 센터 기능 전체 워크플로우"
/>

<Callout type="info" title="프론트엔드 워크플로우 특징">
  백엔드와 동일한 6단계지만 프론트엔드만의 차이가 있습니다:
  - **타입 먼저**: props 인터페이스를 먼저 정의하면 구현이 정확해집니다
  - **기존 패턴 참조**: `@` 기호로 기존 컴포넌트를 참조하여 일관성 유지
  - **접근성 필수**: 키보드 내비게이션, aria 속성, 스크린 리더 지원을 테스트에 포함
  - **cleanup 검증**: 이벤트 리스너, 타이머, 구독 등의 정리를 리뷰에서 확인
</Callout>

<ChapterNav
  prev={{ title: '프론트엔드 프로젝트', path: '/docs/part-5--실전-예제-프론트엔드-프로젝트' }}
  next={{ title: '보안', path: '/docs/part-6--모범-사례-보안' }}
/>
