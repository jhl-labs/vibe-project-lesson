import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { FileTree } from '../../components/FileTree';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/Python API" />

# Python API 예제

> TypeScript API와 동일한 아키텍처를 Python으로 구현하며, Clean Architecture가 언어에 독립적임을 체험하기

앞 챕터에서 TypeScript로 만든 Clean Architecture API를 이번에는 **Python(FastAPI)으로 동일하게 구현**합니다. 두 결과를 비교하면서 "언어와 프레임워크는 다르지만 아키텍처 원칙은 같다"는 것을 직접 확인합니다.

## 최종 프로젝트 구조

<FileTree
  title="examples/python-api/"
  data={[
    {
      name: 'app/',
      type: 'folder',
      children: [
        { name: 'main.py', type: 'file', description: 'FastAPI 앱 엔트리포인트' },
        {
          name: 'domain/',
          type: 'folder',
          description: '비즈니스 로직 (순수, 의존성 없음)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'entity.py', type: 'file', description: 'User 엔터티' },
                { name: 'repository.py', type: 'file', description: 'Repository Protocol' },
              ],
            },
          ],
        },
        {
          name: 'application/',
          type: 'folder',
          description: '유스케이스',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'use_cases.py', type: 'file', description: '유스케이스' },
                { name: 'dtos.py', type: 'file', description: 'DTO' },
              ],
            },
          ],
        },
        {
          name: 'infrastructure/',
          type: 'folder',
          children: [
            {
              name: 'database/',
              type: 'folder',
              children: [
                { name: 'models.py', type: 'file', description: 'SQLAlchemy 모델' },
                { name: 'repository.py', type: 'file', description: 'Repository 구현' },
              ],
            },
          ],
        },
        {
          name: 'presentation/',
          type: 'folder',
          children: [
            {
              name: 'api/',
              type: 'folder',
              children: [
                { name: 'users.py', type: 'file', description: 'API 라우터' },
              ],
            },
            {
              name: 'schemas/',
              type: 'folder',
              children: [
                { name: 'user.py', type: 'file', description: 'Pydantic 스키마' },
              ],
            },
          ],
        },
        {
          name: 'core/',
          type: 'folder',
          children: [
            { name: 'config.py', type: 'file', description: '환경 설정' },
            { name: 'database.py', type: 'file', description: 'DB 연결' },
          ],
        },
      ],
    },
    {
      name: 'tests/',
      type: 'folder',
      children: [
        { name: 'test_user_entity.py', type: 'file', description: '엔터티 단위 테스트' },
        { name: 'test_create_user.py', type: 'file', description: '유스케이스 단위 테스트' },
        { name: 'conftest.py', type: 'file', description: 'pytest 픽스처' },
      ],
    },
    { name: 'requirements.txt', type: 'file' },
    { name: '.env.example', type: 'file' },
  ]}
/>

<Callout type="tip" title="SQLite로 간편하게">
  이 프로젝트는 `aiosqlite`로 SQLite를 사용합니다. Docker나 별도 DB 설치 없이 `pip install -r requirements.txt && uvicorn app.main:app --reload`만으로 바로 시작할 수 있습니다.
</Callout>

---

## 실습 1: CLAUDE.md 작성 + 프로젝트 초기화

<CodeBlock
  code={`CLAUDE.md를 생성해줘. 내용은 다음과 같아:
- 프로젝트: FastAPI + SQLAlchemy + pytest 기반 Clean Architecture API
- DB: SQLite (aiosqlite), 프로덕션에서는 PostgreSQL 전환 가능
- 아키텍처: domain/ → application/ → infrastructure/ → presentation/
- domain은 외부 의존성 금지, application은 domain Protocol만 의존
- 파일명 snake_case, 클래스 PascalCase
- 테스트: pytest + AsyncMock, httpx로 통합 테스트`}
  language="text"
  filename="프롬프트 1-1: CLAUDE.md 생성"
/>

<CodeBlock
  code={`FastAPI + SQLAlchemy + pytest 프로젝트를 초기화해줘.
Clean Architecture 구조로 다음 디렉토리를 생성해:
- app/domain/user/
- app/application/user/
- app/infrastructure/database/
- app/presentation/api/
- app/presentation/schemas/
- app/core/
- tests/

requirements.txt에 fastapi, uvicorn, sqlalchemy[asyncio],
aiosqlite, pydantic-settings, pytest, pytest-asyncio, httpx를 포함해.
.env.example도 생성해줘.`}
  language="text"
  filename="프롬프트 1-2: 프로젝트 초기화"
/>

### Claude가 생성하는 것

- `requirements.txt` — FastAPI, SQLAlchemy, pytest 등 의존성 목록
- `app/core/config.py` — `pydantic-settings` 기반 환경 설정 (`DATABASE_URL`, `DEBUG`)
- `app/core/database.py` — SQLAlchemy async 엔진 + 세션 팩토리
- `.env.example` — 환경 변수 템플릿
- 위 FileTree에 표시된 디렉토리 구조 (`__init__.py` 포함)

### 여기서 배우는 것

<Callout type="info" title="Python에서의 환경 설정">
  TypeScript에서는 `dotenv`로 환경 변수를 읽었지만, Python에서는 **`pydantic-settings`**가 `.env` 파일 로딩 + 타입 검증을 한 번에 처리합니다. `Settings` 클래스에 `database_url: str`을 선언하면, 환경 변수가 없을 때 타입 에러로 알려줍니다.
</Callout>

---

## 실습 2: Domain Layer — Python 스타일의 비즈니스 로직

<CodeBlock
  code={`app/domain/user/ 아래에 다음을 구현해줘:
1. entity.py: User 데이터클래스
   - @dataclass, create() 클래스메서드 (이메일 정규식 검증, 소문자 변환)
   - activate/deactivate 상태 전이 (pending→active→inactive)
2. repository.py: UserRepository Protocol (find_by_id, find_by_email, save)

외부 라이브러리 없이 Python 표준 라이브러리만 사용해.`}
  language="text"
  filename="프롬프트 2: Domain Layer"
/>

### Claude가 생성하는 것

- **`entity.py`** — `@dataclass`로 정의된 `User` 엔터티. TypeScript의 `class`와 역할은 같지만, Python의 `@dataclass`는 `__init__`, `__eq__` 등을 자동 생성
- **`repository.py`** — `Protocol` 클래스로 정의된 `UserRepository`. TypeScript의 `interface`에 해당

### 여기서 배우는 것

<Callout type="info" title="Protocol vs Interface — 같은 목적, 다른 방식">
  TypeScript는 `interface IUserRepository`로 계약을 정의하고, 구현체가 `implements`를 명시합니다.

  Python의 `Protocol`은 **구조적 서브타이핑(structural subtyping)**을 사용합니다. `implements` 키워드 없이, 메서드 시그니처만 일치하면 자동으로 호환됩니다. 이것이 Python의 **duck typing** 철학입니다: "오리처럼 걷고 꽥꽥거리면, 오리다."

  **두 방식 모두** Domain이 인터페이스를 정의하고 Infrastructure가 구현한다는 핵심 원칙은 동일합니다.
</Callout>

<Callout type="tip" title="확인 포인트">
  생성된 `entity.py`의 `import` 목록을 확인해보세요. `dataclasses`, `re`, `uuid`만 있고, FastAPI나 SQLAlchemy 같은 외부 패키지가 없어야 합니다. TypeScript Domain Layer와 같은 원칙입니다.
</Callout>

---

## 실습 3: Application Layer — 유스케이스 흐름

<CodeBlock
  code={`app/application/user/ 아래에 유스케이스를 구현해줘:
1. dtos.py: CreateUserDto, UserResponseDto (frozen=True 데이터클래스)
   - UserResponseDto에 from_entity() 클래스메서드 포함
2. use_cases.py: CreateUserUseCase, GetUserUseCase
   - 생성자에서 UserRepository Protocol을 주입받음
   - 이메일 중복 체크 → User.create() → save → DTO 반환`}
  language="text"
  filename="프롬프트 3: Application Layer"
/>

### Claude가 생성하는 것

- **`dtos.py`** — `frozen=True`로 불변 보장된 데이터클래스들. TypeScript의 `readonly`와 동일한 목적
- **`use_cases.py`** — `CreateUserUseCase`와 `GetUserUseCase`. TypeScript 버전과 흐름이 거의 동일

### 여기서 배우는 것

<Callout type="info" title="TypeScript와 비교해보세요">
  TypeScript의 `create-user.ts`와 Python의 `use_cases.py`를 나란히 열어보면, **비즈니스 흐름이 거의 1:1로 대응**됩니다:

  1. `find_by_email` → 중복 확인
  2. `User.create()` → 엔터티 생성
  3. `save()` → 영속화
  4. `from_entity()` → DTO 변환

  언어 문법은 다르지만 유스케이스의 구조는 동일합니다. 이것이 Clean Architecture가 **언어 독립적**이라는 의미입니다.
</Callout>

---

## 실습 4: Infrastructure Layer — SQLAlchemy 저장소

<CodeBlock
  code={`app/infrastructure/database/ 아래에 구현해줘:
1. models.py: SQLAlchemy UserModel (id, email, name, status 컬럼)
2. user_repository.py: SQLAlchemyUserRepository
   - AsyncSession을 생성자로 주입
   - UserRepository Protocol의 메서드 구현 (find_by_id, find_by_email, save)
   - ORM 모델 ↔ Domain 엔터티 변환 메서드 포함`}
  language="text"
  filename="프롬프트 4: Infrastructure Layer"
/>

### Claude가 생성하는 것

- **`models.py`** — SQLAlchemy ORM 모델. DB 테이블 구조를 정의
- **`user_repository.py`** — `UserRepository` Protocol을 만족하는 구현체. ORM 모델과 Domain 엔터티 간 변환 로직 포함

### 여기서 배우는 것

<Callout type="info" title="ORM 모델 ≠ Domain 엔터티">
  생성된 코드에서 `UserModel`(ORM)과 `User`(Domain)가 **별도 클래스**인 것을 확인하세요. Repository 안에 `_to_domain()` 같은 변환 메서드가 있습니다.

  왜 분리하나요? ORM 모델은 DB 테이블 구조에 종속되지만, Domain 엔터티는 비즈니스 규칙만 표현해야 합니다. 이 분리 덕분에 DB 스키마가 변경되어도 Domain 로직은 영향을 받지 않습니다.
</Callout>

<Callout type="tip" title="TypeScript 버전과의 차이">
  TypeScript API는 InMemoryRepository(Map 기반)를 사용했고, Python API는 SQLAlchemy + SQLite를 사용합니다. **어느 쪽이든 Domain과 Application Layer의 코드는 동일합니다.** 저장소 구현이 달라도 인터페이스(Protocol)만 지키면 상위 레이어에 영향이 없다는 것을 두 예제로 직접 확인할 수 있습니다.
</Callout>

---

## 실습 5: Presentation Layer — FastAPI 라우터

<CodeBlock
  code={`Presentation Layer를 구현해줘:
1. app/presentation/schemas/user.py
   - Pydantic BaseModel로 CreateUserRequest, UserResponse 정의
   - CreateUserRequest에 EmailStr로 이메일 검증
2. app/presentation/api/users.py
   - APIRouter에 POST /users/ (201), GET /users/{user_id} (200) 등록
   - FastAPI Depends로 UseCase 의존성 주입
   - ValueError → HTTPException 변환
3. app/main.py
   - FastAPI 앱 생성, lifespan으로 시작 시 테이블 자동 생성
   - users 라우터 등록`}
  language="text"
  filename="프롬프트 5: Presentation Layer + 앱 조립"
/>

### Claude가 생성하는 것

- **`schemas/user.py`** — Pydantic 모델로 HTTP 요청/응답 스키마 정의. `EmailStr`로 이메일 형식 자동 검증
- **`api/users.py`** — FastAPI 라우터. `Depends()`로 UseCase를 주입받는 엔드포인트
- **`main.py`** — FastAPI 앱 조립. `lifespan`으로 DB 테이블 자동 생성

### 여기서 배우는 것

<Callout type="info" title="FastAPI Depends vs Express 수동 조립">
  TypeScript에서는 `app.ts`에서 직접 `new Repository()` → `new UseCase(repo)` → `new Controller(useCase)`로 조립했습니다.

  Python(FastAPI)에서는 **`Depends()` 함수**가 이를 대신합니다. 팩토리 함수를 정의하면 FastAPI가 요청마다 자동으로 의존성을 생성하고 주입합니다. 프레임워크가 DI 컨테이너 역할을 하는 셈입니다.

  방식은 다르지만, **"UseCase는 인터페이스에만 의존한다"**는 원칙은 동일합니다.
</Callout>

<Callout type="tip" title="이중 검증의 의미">
  Pydantic의 `EmailStr`이 이미 이메일을 검증하는데, 왜 Domain에서도 정규식으로 검증하나요? Presentation Layer의 검증은 "HTTP 입력이 올바른가"를 확인하고, Domain의 검증은 "비즈니스 규칙에 맞는가"를 확인합니다. API가 아닌 다른 진입점(CLI, 배치 등)에서도 Domain 검증이 작동해야 하기 때문입니다.
</Callout>

---

## 실습 6: 테스트 작성 및 실행

<CodeBlock
  code={`다음 테스트를 작성하고 실행해줘:

1. tests/test_user_entity.py: User 엔터티 단위 테스트
   - 정상 생성, 이메일 소문자 변환, 잘못된 이메일 거부
   - 상태 전이: pending→active, active→inactive
   - 잘못된 상태 전이 시 ValueError

2. tests/test_create_user.py: CreateUserUseCase 단위 테스트
   - AsyncMock으로 Repository mock
   - 정상 생성, 이메일 중복, 잘못된 이메일, 소문자 변환

3. tests/conftest.py: pytest 픽스처
   - 인메모리 SQLite 세션 (테스트마다 테이블 생성/삭제)
   - httpx AsyncClient 픽스처

pytest-asyncio를 사용하고, 테스트 실행까지 해줘.`}
  language="text"
  filename="프롬프트 6: 테스트 작성 및 실행"
/>

### Claude가 생성하는 것

- **`test_user_entity.py`** — 엔터티 단위 테스트 (pytest.raises로 예외 검증)
- **`test_create_user.py`** — UseCase 단위 테스트 (`AsyncMock`으로 Repository mock)
- **`conftest.py`** — pytest 픽스처 (인메모리 SQLite, httpx 클라이언트)
- 모든 테스트 실행 결과

### 여기서 배우는 것

<Callout type="info" title="Python Mock vs TypeScript Mock">
  - TypeScript: `jest.Mocked<IUserRepository>` — `jest.fn()`으로 각 메서드를 직접 모킹
  - Python: `AsyncMock()` — `unittest.mock`의 비동기 모킹. `return_value`와 `assert_called_once()`로 검증

  문법은 다르지만 **패턴은 동일**합니다: 인터페이스를 만족하는 가짜 객체를 만들어 주입하고, 호출 여부를 검증합니다.
</Callout>

<Callout type="tip" title="conftest.py의 역할">
  생성된 `conftest.py`를 보면, 매 테스트마다 **인메모리 SQLite 테이블을 생성하고 삭제**합니다. 이 덕분에 테스트 간 데이터 오염 없이 격리된 환경에서 실행됩니다. TypeScript의 `beforeEach`에서 `jest.fn()`을 초기화하는 것과 같은 목적입니다.
</Callout>

---

## TypeScript API vs Python API 비교

<ComparisonTable
  title="TS API vs Python API 구현 비교"
  headers={['항목', 'TypeScript', 'Python']}
  rows={[
    { feature: '프레임워크', values: ['Express.js', 'FastAPI'] },
    { feature: '저장소', values: ['InMemoryRepository (Map)', 'SQLAlchemy + SQLite'] },
    { feature: '테스트', values: ['Jest + jest.Mocked', 'pytest + AsyncMock'] },
    { feature: '인터페이스', values: ['interface (명시적 implements)', 'Protocol (구조적, duck typing)'] },
    { feature: '비동기', values: ['async/await', 'async/await'] },
    { feature: '타입 시스템', values: ['정적 (컴파일 타임)', '동적 (런타임 힌트)'] },
    { feature: '데이터 클래스', values: ['class (private constructor)', '@dataclass'] },
    { feature: '의존성 주입', values: ['생성자 주입 (수동 조립)', 'FastAPI Depends (프레임워크 DI)'] },
    { feature: '입력 검증', values: ['값 객체 (Email class)', 'Pydantic + 엔터티 검증'] },
    { feature: '네이밍', values: ['camelCase', 'snake_case'] },
  ]}
/>

<Callout type="info" title="언어가 달라도 아키텍처는 같다">
  두 예제에서 확인할 수 있는 공통점:
  - **Domain Layer**가 인터페이스(Protocol/interface)를 정의하고, Infrastructure Layer가 구현
  - **Application Layer**는 인터페이스에만 의존하여, 저장소가 Map이든 SQLite든 상관없음
  - **Presentation Layer**는 프레임워크(Express/FastAPI)에 특화된 변환만 담당

  프레임워크와 DB는 **세부사항(detail)**이며, 비즈니스 로직과 분리됩니다. 이것이 Clean Architecture의 핵심 가치입니다.
</Callout>


<ChapterNav
  prev={{ title: 'TypeScript API', path: '/docs/part-5--실전-예제-typescript-api' }}
  next={{ title: '프론트엔드 프로젝트', path: '/docs/part-5--실전-예제-프론트엔드-프로젝트' }}
/>
