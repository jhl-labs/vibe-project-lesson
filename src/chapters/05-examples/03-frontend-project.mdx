import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { FileTree } from '../../components/FileTree';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/프론트엔드 프로젝트" />

# 프론트엔드 프로젝트 예제

> React 대시보드를 **타입 → 구현 → 테스트 → 접근성** 순서로 만들며, 프론트엔드에서의 Claude Code 활용법 익히기

백엔드 API 예제에서 레이어 분리를 배웠다면, 이번에는 프론트엔드에서의 **컴포넌트 개발 워크플로우**를 체험합니다. 핵심은 **타입을 먼저 정의**하고, Claude Code가 그 타입에 맞는 구현을 생성하게 하는 것입니다.

## Claude Code 워크플로우

<MermaidDiagram
  chart={`flowchart LR
    A["1. 타입 정의"] --> B["2. 컴포넌트\n구현"]
    B --> C["3. 커스텀 훅"]
    C --> D["4. 테스트\n작성"]
    D --> E["5. 접근성\n검증"]
    E --> F["6. 페이지\n조립"]
    style A fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style F fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="프론트엔드 컴포넌트 개발 순서"
  caption="타입 먼저 정의하면 Claude가 타입에 맞는 정확한 코드를 생성합니다"
/>

## 최종 프로젝트 구조

<FileTree
  title="examples/react-dashboard/"
  data={[
    {
      name: 'src/',
      type: 'folder',
      children: [
        {
          name: 'components/',
          type: 'folder',
          description: 'UI 컴포넌트',
          highlight: true,
          children: [
            {
              name: 'ui/',
              type: 'folder',
              description: '기본 UI 요소',
              children: [
                { name: 'Button.tsx', type: 'file', description: '버튼 컴포넌트' },
                { name: 'Card.tsx', type: 'file', description: '카드 컴포넌트' },
                { name: 'Input.tsx', type: 'file', description: '입력 필드' },
              ],
            },
            {
              name: 'dashboard/',
              type: 'folder',
              description: '대시보드 전용',
              children: [
                { name: 'StatCard.tsx', type: 'file', description: '통계 카드' },
                { name: 'Chart.tsx', type: 'file', description: '차트 래퍼' },
                { name: 'DataGrid.tsx', type: 'file', description: '데이터 그리드' },
              ],
            },
          ],
        },
        {
          name: 'hooks/',
          type: 'folder',
          description: '커스텀 훅',
          children: [
            { name: 'useDebounce.ts', type: 'file' },
            { name: 'useFetch.ts', type: 'file' },
          ],
        },
        {
          name: 'types/',
          type: 'folder',
          children: [
            { name: 'dashboard.ts', type: 'file', description: '타입 정의' },
          ],
        },
        {
          name: '__tests__/',
          type: 'folder',
          description: '테스트',
          children: [
            { name: 'StatCard.test.tsx', type: 'file' },
            { name: 'DataGrid.test.tsx', type: 'file' },
          ],
        },
        {
          name: 'pages/',
          type: 'folder',
          children: [
            { name: 'Dashboard.tsx', type: 'file', description: '대시보드 페이지' },
          ],
        },
      ],
    },
    { name: 'tailwind.config.ts', type: 'file' },
    { name: 'tsconfig.json', type: 'file' },
  ]}
/>

---

## 실습 1: 타입 정의 — 컴포넌트의 설계도

<CodeBlock
  code={`src/types/dashboard.ts에 대시보드 컴포넌트 타입을 정의해줘:

1. StatCardProps: title(string), value(number|string),
   change(optional: value+type), icon(ReactNode), loading(boolean)

2. DataGridColumn<T>: key(keyof T), header, width, sortable,
   render(커스텀 렌더러 함수)

3. DataGridProps<T>: columns, data, loading, onRowClick, emptyMessage`}
  language="text"
  filename="프롬프트 1: 타입 정의"
/>

### Claude가 생성하는 것

- **`dashboard.ts`** — `StatCardProps`, `DataGridColumn<T>`, `DataGridProps<T>` 인터페이스. 제네릭 `<T>`로 어떤 데이터 타입이든 수용 가능

### 여기서 배우는 것

<Callout type="info" title="왜 타입을 먼저 정의하나?">
  이후 실습에서 Claude Code에 "**@src/types/dashboard.ts** 의 StatCardProps에 맞는 컴포넌트를 만들어줘"라고 요청하면, Claude는 이 파일을 읽고 **props 구조를 정확히 이해한 상태에서** 코드를 생성합니다.

  타입 없이 "통계 카드 컴포넌트 만들어줘"라고 하면 Claude가 props를 임의로 결정합니다. 타입을 먼저 정의하면 **원하는 인터페이스를 확정**하고 나서 구현을 맡기는 셈입니다. 백엔드에서 Repository 인터페이스를 먼저 정의한 것과 같은 원리입니다.
</Callout>

---

## 실습 2: StatCard 컴포넌트

<CodeBlock
  code={`@src/types/dashboard.ts 의 StatCardProps에 맞는 StatCard 컴포넌트를 만들어줘.
Tailwind CSS로 스타일링하고 다음을 포함해:
- 로딩 상태: animate-pulse 스켈레톤 UI
- 변화율 표시: 증가는 초록(↑), 감소는 빨강(↓)
- 접근성: role="status", aria-label 포함
- hover 시 shadow 트랜지션`}
  language="text"
  filename="프롬프트 2: StatCard 구현"
/>

### Claude가 생성하는 것

- **`StatCard.tsx`** — title, value, 변화율을 표시하는 카드 컴포넌트. `loading` prop이 true이면 스켈레톤 UI를 렌더링

### 여기서 배우는 것

<Callout type="info" title="접근성을 프롬프트에 포함하는 이유">
  생성된 코드에서 다음을 확인해보세요:
  - 로딩 상태에 `role="status"`와 `sr-only` 텍스트가 있나요?
  - 변화율에 `aria-label="증가 12.5%"` 같은 대체 텍스트가 있나요?
  - 아이콘에 `aria-hidden="true"`가 적용되어 있나요?

  접근성을 **나중에 추가하면** 구조를 바꿔야 할 수 있습니다. 처음부터 프롬프트에 명시하면 자연스럽게 반영됩니다.
</Callout>

---

## 실습 3: DataGrid 컴포넌트

<CodeBlock
  code={`@src/types/dashboard.ts 의 DataGridProps에 맞는 DataGrid 컴포넌트를 만들어줘.
Tailwind CSS로 스타일링하고 다음 기능을 포함해:
- 컬럼 정렬 (오름차순/내림차순 토글)
- 로딩 스켈레톤 (5행 표시)
- 빈 상태 메시지
- 행 클릭 이벤트
- 커스텀 셀 렌더러 (render prop)
- 접근성: aria-sort, 키보드로 행 선택 가능 (Enter, Space)`}
  language="text"
  filename="프롬프트 3: DataGrid 구현"
/>

### Claude가 생성하는 것

- **`DataGrid.tsx`** — 정렬, 로딩, 빈 상태, 커스텀 렌더링을 지원하는 테이블 컴포넌트. `useMemo`로 정렬된 데이터를 계산하고, `useState`로 정렬 상태를 관리

### 여기서 배우는 것

<Callout type="info" title="제네릭 컴포넌트의 가치">
  생성된 `DataGrid`가 `<T>`를 사용하고 있는지 확인하세요. `DataGrid<Order>`, `DataGrid<User>` 처럼 **어떤 데이터 타입이든** 동일한 컴포넌트로 표현할 수 있습니다.

  `render` prop도 확인하세요. 금액 컬럼에 `₩` 포맷팅, 상태 컬럼에 배지 스타일 등 **셀마다 다른 렌더링**을 컬럼 정의에서 선언적으로 처리합니다.
</Callout>

<Callout type="tip" title="확인 포인트: 키보드 접근성">
  `onRowClick`이 있는 행에 `tabIndex={0}`과 `onKeyDown` (Enter/Space) 핸들러가 있나요? 마우스로 클릭 가능한 모든 요소는 키보드로도 동일하게 동작해야 합니다.
</Callout>

---

## 실습 4: 커스텀 훅

<CodeBlock
  code={`다음 커스텀 훅을 구현해줘:

1. useDebounce<T>(value, delay): 값 변경 후 delay ms 대기 후 반영
   - 검색 입력 필드에서 타이핑마다 API를 호출하지 않도록

2. useFetch<T>(url): GET 요청 + 로딩/에러 상태 관리
   - AbortController로 언마운트 시 요청 취소
   - 에러 시 AbortError는 무시`}
  language="text"
  filename="프롬프트 4: 커스텀 훅"
/>

### Claude가 생성하는 것

- **`useDebounce.ts`** — `setTimeout`/`clearTimeout`으로 값 변경을 지연하는 훅
- **`useFetch.ts`** — `data`, `error`, `loading` 상태를 관리하는 데이터 패칭 훅

### 여기서 배우는 것

<Callout type="info" title="cleanup 함수가 핵심">
  생성된 두 훅에서 `useEffect`의 **return 문**(cleanup 함수)을 확인하세요:
  - `useDebounce`: `clearTimeout(timer)` — 값이 바뀌면 이전 타이머를 취소
  - `useFetch`: `controller.abort()` — 컴포넌트가 언마운트되면 진행 중인 요청을 취소

  cleanup이 없으면 **메모리 누수**와 **경쟁 조건(race condition)**이 발생합니다. 이전 요청의 응답이 나중에 도착해서 새 데이터를 덮어쓰는 문제가 대표적입니다.
</Callout>

---

## 실습 5: 테스트 작성

<CodeBlock
  code={`@src/components/dashboard/StatCard.tsx 의 테스트를 작성해줘.
Testing Library를 사용하고 다음 케이스를 커버해:
1. title과 value 렌더링
2. 증가 변화율 표시 (↑, 초록)
3. 감소 변화율 표시 (↓, 빨강)
4. 로딩 스켈레톤 + 접근성 라벨
5. 아이콘 렌더링

@src/components/dashboard/DataGrid.tsx 테스트도 작성해줘:
1. 데이터 렌더링
2. 정렬 토글
3. 빈 상태 메시지
4. 행 클릭 이벤트
5. 키보드로 행 선택 (Enter, Space)

테스트 작성 후 실행까지 해줘.`}
  language="text"
  filename="프롬프트 5: 테스트 작성"
/>

### Claude가 생성하는 것

- **`StatCard.test.tsx`** — 5개 테스트 케이스 (렌더링, 변화율, 로딩, 아이콘)
- **`DataGrid.test.tsx`** — 5개 테스트 케이스 (데이터, 정렬, 빈 상태, 클릭, 키보드)
- 테스트 실행 결과 (실패 시 자동 수정)

### 여기서 배우는 것

<Callout type="info" title="Testing Library의 철학">
  생성된 테스트에서 `screen.getByText()`, `screen.getByRole()` 같은 쿼리를 확인하세요. Testing Library는 **사용자가 실제로 보고 상호작용하는 방식**으로 테스트합니다:
  - `getByText('총 매출')` — "총 매출"이라는 텍스트가 화면에 있는가?
  - `getByRole('status')` — 스크린 리더가 인식하는 status 요소가 있는가?
  - `fireEvent.click()` → `fireEvent.keyDown(Enter)` — 클릭과 키보드 모두 작동하는가?

  구현 세부사항(className, state 값)이 아닌 **사용자 관점의 동작**을 검증합니다.
</Callout>

---

## 실습 6: 접근성 검증

<CodeBlock
  code={`@src/components/dashboard/ 아래 모든 컴포넌트의 접근성을 검토해줘.
다음을 확인하고 수정해:
1. 키보드 내비게이션: 클릭 가능한 요소에 tabIndex, onKeyDown 추가
2. 스크린 리더: aria-label, role, aria-sort 속성 확인
3. 색상 대비: 텍스트와 배경 간 WCAG AA(4.5:1) 충족 여부
4. 로딩 상태: role="status"와 sr-only 안내 텍스트 확인

수정 후 테스트를 실행해줘.`}
  language="text"
  filename="프롬프트 6: 접근성 검증"
/>

### Claude가 수행하는 것

- 모든 대시보드 컴포넌트를 순회하며 접근성 문제 발견 및 수정
- 수정 후 기존 테스트가 여전히 통과하는지 확인

### 여기서 배우는 것

<ComparisonTable
  title="프론트엔드 접근성 점검 항목"
  headers={['항목', '기준', '구현 방법']}
  rows={[
    { feature: '키보드 내비게이션', values: ['모든 인터랙션이 키보드로 가능', 'tabIndex, onKeyDown (Enter/Space)'] },
    { feature: '스크린 리더', values: ['시각 정보에 대체 텍스트 제공', 'aria-label, aria-sort, role 속성'] },
    { feature: '색상 대비', values: ['WCAG AA 기준 4.5:1 이상', 'Tailwind의 600/900 색상 조합'] },
    { feature: '로딩 상태', values: ['비동기 상태를 명확히 전달', 'role="status", sr-only 텍스트'] },
    { feature: '정렬 상태', values: ['현재 정렬 방향을 인식 가능', 'aria-sort="ascending|descending"'] },
  ]}
/>

<Callout type="tip" title="접근성을 별도 단계로 분리하는 이유">
  실습 2~3에서 프롬프트에 접근성을 포함했는데 왜 다시 검증하나요? Claude가 **모든 요구사항을 100% 반영하지 않을 수 있기** 때문입니다. 접근성 전용 검토 단계를 두면 빠뜨린 부분을 보완할 수 있습니다. "수정 후 테스트를 실행해줘"를 포함하여 기존 기능이 깨지지 않는지도 확인합니다.
</Callout>

---

## 실습 7: 대시보드 페이지 조립

<CodeBlock
  code={`지금까지 만든 컴포넌트와 훅을 조합해서 대시보드 페이지를 만들어줘.

src/pages/Dashboard.tsx:
- 상단: StatCard 4개 (총 매출, 신규 사용자, 주문 수, 전환율)
- useFetch로 /api/dashboard/stats에서 데이터 로딩
- 하단: DataGrid로 최근 주문 목록 표시
- 주문 상태 컬럼에 커스텀 렌더러 (배지 스타일)
- 검색 입력: useDebounce로 300ms 디바운스 적용

로딩 상태와 에러 상태도 처리해줘.
Tailwind CSS로 반응형 레이아웃을 적용해 (sm: 2열, lg: 4열).`}
  language="text"
  filename="프롬프트 7: 대시보드 페이지 조립"
/>

### Claude가 생성하는 것

- **`Dashboard.tsx`** — StatCard, DataGrid, useDebounce, useFetch를 조합한 대시보드 페이지
- 반응형 그리드 (`grid-cols-1 sm:grid-cols-2 lg:grid-cols-4`)
- 주문 상태별 배지 컬러 (pending: 노랑, completed: 초록, cancelled: 빨강)

### 여기서 배우는 것

<Callout type="info" title="조립 단계의 포인트">
  생성된 `Dashboard.tsx`를 열어보면, **새로운 로직이 거의 없습니다**. 이미 만들어둔 컴포넌트와 훅을 `import`하고 **데이터를 연결하는 코드**가 대부분입니다.

  이것이 컴포넌트 기반 개발의 가치입니다. 각 실습에서 독립적으로 테스트된 부품을 **조립만 하면 페이지가 완성**됩니다. 백엔드의 Clean Architecture에서 레이어를 조립하는 것과 같은 원리입니다.
</Callout>

<Callout type="tip" title="프론트엔드에서 Claude Code 활용 팁">
  - **이미지 붙여넣기**: 디자인 스크린샷을 터미널에 붙여넣으면 Claude가 시각적으로 인식합니다
  - **기존 컴포넌트 참조**: `@` 기호로 기존 컴포넌트를 참조하면 일관된 패턴을 따릅니다
  - **타입 먼저**: props 타입을 먼저 정의하면 Claude가 더 정확한 코드를 생성합니다
  - **테스트 병행**: "구현 후 테스트를 실행해줘"를 습관적으로 포함하세요
</Callout>

<ChapterNav
  prev={{ title: 'Python API', path: '/docs/part-5--실전-예제-python-api' }}
  next={{ title: 'End-to-End 워크플로우', path: '/docs/part-5--실전-예제-end-to-end-워크플로우' }}
/>
