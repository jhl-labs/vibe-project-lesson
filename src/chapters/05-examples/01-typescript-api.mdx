import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { FileTree } from '../../components/FileTree';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/TypeScript API" />

# TypeScript API 예제

> Claude Code에 프롬프트를 입력하여 Clean Architecture API를 처음부터 만들어보기

이 챕터에서는 코드를 직접 작성하지 않습니다. **Claude Code에 프롬프트를 입력**하고, 생성된 결과를 확인하며, 각 단계에서 **어떤 아키텍처 개념이 적용되었는지** 학습합니다.

## 완성 목표

<MermaidDiagram
  chart={`flowchart TB
    A["HTTP Request"] --> B["Presentation Layer\n(Controller)"]
    B --> C["Application Layer\n(Use Case)"]
    C --> D["Domain Layer\n(Entity + Value Object)"]
    C --> E["Infrastructure Layer\n(InMemory Repository)"]
    E --> F["In-Memory Store"]
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="Clean Architecture 레이어 구조"
  caption="의존성 방향: Presentation → Application → Domain ← Infrastructure"
/>

7개의 실습을 순서대로 진행하면 위 구조의 API가 완성됩니다. 각 실습은 **하나의 프롬프트**로 이루어지며, `npm install && npm run dev`만으로 실행 가능합니다.

## 최종 프로젝트 구조

<FileTree
  title="examples/typescript-api/"
  data={[
    {
      name: 'src/',
      type: 'folder',
      children: [
        {
          name: 'domain/',
          type: 'folder',
          description: '비즈니스 로직 (순수, 의존성 없음)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'entity.ts', type: 'file', description: 'User 엔터티' },
                { name: 'repository.ts', type: 'file', description: 'Repository 인터페이스' },
                { name: 'value-objects.ts', type: 'file', description: '값 객체 (Email)' },
              ],
            },
          ],
        },
        {
          name: 'application/',
          type: 'folder',
          description: '유스케이스 (비즈니스 흐름 조율)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'create-user.ts', type: 'file', description: '사용자 생성 유스케이스' },
                { name: 'get-user.ts', type: 'file', description: '사용자 조회 유스케이스' },
                { name: 'dtos.ts', type: 'file', description: 'DTO 정의' },
              ],
            },
          ],
        },
        {
          name: 'infrastructure/',
          type: 'folder',
          description: '저장소 구현체',
          children: [
            {
              name: 'persistence/',
              type: 'folder',
              children: [
                { name: 'in-memory-user-repository.ts', type: 'file', description: 'InMemory 구현체' },
              ],
            },
          ],
        },
        {
          name: 'presentation/',
          type: 'folder',
          description: 'HTTP 컨트롤러',
          children: [
            {
              name: 'http/',
              type: 'folder',
              children: [
                { name: 'user-controller.ts', type: 'file', description: 'REST API' },
              ],
            },
            {
              name: 'middleware/',
              type: 'folder',
              children: [
                { name: 'error-handler.ts', type: 'file', description: '에러 처리' },
                { name: 'request-logger.ts', type: 'file', description: '요청 로깅' },
              ],
            },
          ],
        },
      ],
    },
    {
      name: 'tests/',
      type: 'folder',
      children: [
        { name: 'user.test.ts', type: 'file', description: '단위 테스트' },
        { name: 'user.integration.test.ts', type: 'file', description: '통합 테스트' },
      ],
    },
    { name: 'package.json', type: 'file' },
    { name: 'tsconfig.json', type: 'file' },
  ]}
/>

---

## 실습 1: CLAUDE.md 작성 + 프로젝트 초기화

첫 번째 단계는 **CLAUDE.md를 먼저 작성**한 뒤, 프로젝트를 초기화하는 것입니다.

<CodeBlock
  code={`CLAUDE.md를 생성해줘. 내용은 다음과 같아:
- 프로젝트: Express + Jest 기반 Clean Architecture API
- 저장소: InMemoryRepository (Map 기반, DB 없음)
- 아키텍처: domain/ → application/ → infrastructure/ → presentation/
- domain은 외부 의존성 금지, application은 domain 인터페이스만 의존
- 파일명 kebab-case, 클래스 PascalCase, Conventional Commits
- 테스트: jest.Mocked로 Repository mock, supertest로 통합 테스트`}
  language="text"
  filename="프롬프트 1-1: CLAUDE.md 생성"
/>

<CodeBlock
  code={`Express + Jest + TypeScript 프로젝트를 초기화해줘.
Clean Architecture 구조로 다음 디렉토리를 생성해:
- src/domain/user/
- src/application/user/
- src/infrastructure/persistence/
- src/presentation/http/
- tests/

tsconfig.json은 strict 모드로 설정하고,
Jest는 ts-jest로 TypeScript를 지원하게 해줘.`}
  language="text"
  filename="프롬프트 1-2: 프로젝트 초기화"
/>

### Claude가 생성하는 것

- `package.json` — Express, Jest, TypeScript 등 의존성이 설정된 파일
- `tsconfig.json` — strict 모드가 활성화된 TypeScript 설정
- `jest.config.js` — ts-jest 프리셋이 적용된 Jest 설정
- 위 FileTree에 표시된 빈 디렉토리 구조

### 여기서 배우는 것

<Callout type="info" title="CLAUDE.md를 먼저 만드는 이유">
  Claude Code는 세션 시작 시 **CLAUDE.md를 자동으로 읽습니다**. 아키텍처 규칙과 컨벤션을 여기에 명시하면, 이후 모든 프롬프트에서 "Clean Architecture를 따라줘", "kebab-case로 해줘" 같은 반복 지시가 필요 없습니다. **한 번 정의하면 전체 세션에서 일관성이 유지됩니다.**
</Callout>

---

## 실습 2: Domain Layer — 비즈니스 규칙의 핵심

<CodeBlock
  code={`src/domain/user/ 아래에 다음 파일을 구현해줘:
1. value-objects.ts: Email 값 객체 (정규식 검증, 소문자 변환, equals 비교)
2. entity.ts: User 엔터티
   - private constructor + create() 팩토리 메서드
   - reconstitute()로 저장소에서 복원
   - activate/deactivate 상태 전이 (pending→active→inactive)
3. repository.ts: IUserRepository 인터페이스 (findById, findByEmail, save)

Domain Layer는 외부 의존성 없이 순수 TypeScript로만 작성해.`}
  language="text"
  filename="프롬프트 2: Domain Layer"
/>

### Claude가 생성하는 것

- **`value-objects.ts`** — `Email` 클래스. `new Email()`이 아닌 `Email.create()`로만 생성 가능하며, 잘못된 이메일 형식은 생성 시점에 거부됨
- **`entity.ts`** — `User` 클래스. 상태 전이 규칙이 메서드 안에 캡슐화됨 (`pending`에서만 `activate()` 가능)
- **`repository.ts`** — `IUserRepository` 인터페이스. **구현이 아닌 계약**만 정의

### 여기서 배우는 것

<Callout type="info" title="Domain Layer의 핵심 원칙 3가지">
  **1. 외부 의존성 제로** — 생성된 코드에서 `import`를 확인해보세요. Express, DB 라이브러리 등 외부 패키지가 하나도 없습니다. 순수 TypeScript만으로 작성됩니다.

  **2. 자기 검증(Self-validating)** — `Email.create("invalid")`를 호출하면 즉시 에러가 발생합니다. 잘못된 데이터가 시스템에 유입되는 것을 **타입 레벨에서 차단**합니다.

  **3. 인터페이스로 경계 정의** — `IUserRepository`는 "데이터를 어디에 저장할지"를 Domain이 결정하지 않겠다는 선언입니다. 이 인터페이스 덕분에 나중에 InMemory든 PostgreSQL이든 자유롭게 교체할 수 있습니다.
</Callout>

<Callout type="tip" title="확인 포인트">
  생성된 `entity.ts`를 열어보세요. `activate()` 메서드 안에 `if (this._status !== 'pending')` 조건이 있나요? 이것이 **비즈니스 규칙의 캡슐화**입니다 — 상태 전이 규칙이 컨트롤러나 서비스가 아닌 엔터티 자체에 존재합니다.
</Callout>

---

## 실습 3: Application Layer — 유스케이스 흐름

<CodeBlock
  code={`src/application/user/ 아래에 유스케이스를 구현해줘:
1. dtos.ts: CreateUserDto (입력), UserResponseDto (출력, 엔터티→DTO 변환 메서드 포함)
2. create-user.ts: 이메일 중복 체크 → User.create() → save → DTO 반환
3. get-user.ts: ID로 조회 → 없으면 Error throw → DTO 반환

IUserRepository를 생성자 주입으로 받아서 의존성 역전을 적용해.`}
  language="text"
  filename="프롬프트 3: Application Layer"
/>

### Claude가 생성하는 것

- **`dtos.ts`** — 입력(`CreateUserDto`)과 출력(`UserResponseDto`)을 분리하는 데이터 전송 객체
- **`create-user.ts`** — "사용자 생성"이라는 비즈니스 흐름을 조율하는 유스케이스. 중복 검사 → 엔터티 생성 → 저장 → 응답 변환의 4단계
- **`get-user.ts`** — "사용자 조회" 유스케이스

### 여기서 배우는 것

<Callout type="info" title="Application Layer가 하는 일과 하지 않는 일">
  생성된 `create-user.ts`를 보면, 유스케이스는 **흐름을 조율**할 뿐 직접 검증하지 않습니다:

  - 이메일 형식 검증? → `User.create()` 안에서 값 객체가 처리 (Domain의 책임)
  - 데이터 저장? → `this.userRepository.save()` 호출만 (Infrastructure의 책임)
  - HTTP 상태 코드? → 여기서는 모름 (Presentation의 책임)

  유스케이스는 **"이메일이 중복인지 확인하고, 사용자를 만들어서 저장한다"**라는 비즈니스 흐름만 표현합니다.
</Callout>

<Callout type="tip" title="확인 포인트">
  생성된 코드에서 `constructor(private userRepository: IUserRepository)`를 찾아보세요. **구체적인 클래스가 아닌 인터페이스**를 받고 있습니다. 이것이 의존성 역전(DIP)의 실제 적용입니다.
</Callout>

---

## 실습 4: Infrastructure Layer — 저장소 구현

<CodeBlock
  code={`src/infrastructure/persistence/in-memory-user-repository.ts를 구현해줘.
- IUserRepository 인터페이스를 구현
- Map<string, User>으로 메모리에 저장
- findById, findByEmail, save 메서드 구현`}
  language="text"
  filename="프롬프트 4: Infrastructure Layer"
/>

### Claude가 생성하는 것

- **`in-memory-user-repository.ts`** — `Map`을 사용한 약 20줄의 간결한 저장소 구현체. `IUserRepository` 인터페이스를 `implements`함

### 여기서 배우는 것

<Callout type="info" title="의존성 역전의 실제 효과">
  이 파일이 전체 프로젝트에서 **유일하게 "데이터를 어디에 저장할지" 결정하는 곳**입니다. Application Layer의 `create-user.ts`는 이 파일의 존재를 모릅니다 — 오직 `IUserRepository` 인터페이스만 알고 있을 뿐입니다.

  이것이 의미하는 바: 나중에 이 파일 하나만 `PostgresUserRepository`로 교체하면, 나머지 코드는 **한 줄도 바꾸지 않고** 실제 DB를 사용할 수 있습니다.
</Callout>

<Callout type="tip" title="프로덕션에서는?">
  InMemoryRepository는 학습용입니다. 프로덕션 환경에서는 Prisma, TypeORM 등 실제 DB 구현체로 교체하면 됩니다. **인터페이스만 동일하게 구현**하면 Application Layer 코드 변경 없이 저장소를 교체할 수 있습니다.
</Callout>

---

## 실습 5: Presentation Layer — HTTP 진입점

<CodeBlock
  code={`Presentation Layer를 구현해줘:
1. src/presentation/http/user-controller.ts
   - POST /api/users → CreateUserUseCase 호출 → 201 응답
   - GET /api/users/:id → GetUserUseCase 호출 → 200 응답
   - 에러 시 적절한 HTTP 상태 코드 반환 (400, 404)
2. src/presentation/middleware/error-handler.ts — 전역 에러 핸들러
3. src/presentation/middleware/request-logger.ts — 요청 로깅
4. src/presentation/app.ts
   - Express 앱 설정 (helmet, cors, json)
   - InMemoryUserRepository → UseCase → Controller 의존성 조립
   - 라우터 등록`}
  language="text"
  filename="프롬프트 5: Presentation Layer"
/>

### Claude가 생성하는 것

- **`user-controller.ts`** — HTTP 요청을 받아 유스케이스를 호출하고, 결과를 HTTP 응답으로 변환하는 컨트롤러
- **`app.ts`** — 모든 레이어를 조립하는 진입점. `new InMemoryUserRepository()` → `new CreateUserUseCase(repo)` → `new UserController(useCase)` 순서로 의존성을 연결

### 여기서 배우는 것

<Callout type="info" title="의존성 조립은 어디서?">
  생성된 `app.ts`를 열어보세요. **구체적인 클래스의 인스턴스를 생성하고 연결하는 코드**가 한 곳에 모여 있습니다:

  ```
  const repo = new InMemoryUserRepository();
  const createUseCase = new CreateUserUseCase(repo);
  const controller = new UserController(createUseCase, ...);
  ```

  이것이 **Composition Root** 패턴입니다 — "무엇을 사용할지"의 결정이 애플리케이션 진입점 한 곳에만 존재합니다. 저장소를 교체하려면 이 한 줄만 바꾸면 됩니다.
</Callout>

<Callout type="tip" title="확인 포인트">
  `user-controller.ts`에서 `import`를 확인해보세요. **Domain이나 Infrastructure를 직접 import하지 않습니다.** Application Layer의 유스케이스만 import합니다. 이것이 레이어 간 의존성 규칙의 실제 모습입니다.
</Callout>

---

## 실습 6: 단위 테스트 — Mock으로 격리 테스트

<CodeBlock
  code={`CreateUserUseCase의 단위 테스트를 작성해줘:
- 정상 생성 시 이메일, 이름, status=pending 검증
- 이메일 중복 시 'Email already exists' 에러
- 잘못된 이메일 형식 시 'Invalid email' 에러
- 대문자 이메일 입력 시 소문자로 변환 확인

IUserRepository는 jest.Mocked로 mock해줘.
테스트 작성 후 npm test로 실행까지 해줘.`}
  language="text"
  filename="프롬프트 6: 단위 테스트"
/>

### Claude가 생성하는 것

- **`tests/user.test.ts`** — 4개의 테스트 케이스를 포함한 단위 테스트
- Claude는 테스트를 작성한 뒤 **자동으로 `npm test`를 실행**하고, 실패하면 코드를 수정하여 전체 통과시킴

### 여기서 배우는 것

<Callout type="info" title="왜 DB 없이 테스트가 가능한가?">
  생성된 테스트 코드를 보면 `jest.fn()`으로 만든 **가짜 Repository**를 사용합니다. 실제 저장소가 아닌 Mock 객체를 주입하기 때문에:

  - **DB 설정 불필요** — 테스트 실행에 외부 서비스가 필요 없음
  - **빠른 실행** — 네트워크/디스크 I/O 없이 밀리초 단위로 완료
  - **격리된 검증** — UseCase의 로직만 정확히 테스트

  이것이 가능한 이유는 실습 3에서 **인터페이스로 의존성을 주입**했기 때문입니다. 의존성 역전이 테스트 용이성으로 직결됩니다.
</Callout>

<Callout type="tip" title="'실행까지 해줘'의 효과">
  프롬프트 끝에 **"테스트 작성 후 실행까지 해줘"**라고 추가하면, Claude Code가 `npm test`를 실행하고 실패한 테스트를 자동으로 수정합니다. 이 피드백 루프 덕분에 **처음부터 통과하는 테스트 코드**를 받을 수 있습니다.
</Callout>

---

## 실습 7: 통합 테스트 + 서버 실행

<CodeBlock
  code={`1. src/index.ts에서 app을 import하고 서버를 시작하는 엔트리포인트를 만들어줘.
   graceful shutdown도 포함해.

2. tests/user.integration.test.ts 통합 테스트를 작성해줘:
   - supertest로 POST /api/users → 201 응답 확인
   - 생성한 사용자를 GET /api/users/:id로 조회 → 200 응답 확인
   - 존재하지 않는 ID 조회 시 404 확인

3. 모든 테스트를 실행하고 결과를 보여줘.`}
  language="text"
  filename="프롬프트 7: 통합 테스트 + 서버"
/>

### Claude가 생성하는 것

- **`src/index.ts`** — 서버 엔트리포인트 (포트 바인딩, graceful shutdown)
- **`tests/user.integration.test.ts`** — supertest로 실제 HTTP 요청을 보내는 통합 테스트
- 모든 테스트 실행 결과 (단위 + 통합)

### 여기서 배우는 것

<Callout type="info" title="단위 테스트 vs 통합 테스트">
  - **실습 6의 단위 테스트**: Repository를 Mock으로 대체하여 UseCase **로직만** 검증
  - **실습 7의 통합 테스트**: 실제 HTTP 요청 → Controller → UseCase → Repository **전체 흐름** 검증

  두 테스트 모두 DB 없이 실행됩니다. InMemoryRepository 덕분에 통합 테스트에서도 **외부 의존성 없이 전체 파이프라인을 검증**할 수 있습니다.
</Callout>

이 시점에서 `npm run dev`를 실행하면 서버가 동작합니다. `curl`이나 Postman으로 직접 API를 호출해보세요:

<CodeBlock
  code={`# 사용자 생성
curl -X POST http://localhost:3000/api/users \\
  -H "Content-Type: application/json" \\
  -d '{"email": "test@example.com", "name": "Test User"}'

# 사용자 조회 (위 응답의 id 사용)
curl http://localhost:3000/api/users/{id}`}
  language="bash"
  filename="API 테스트"
/>

---

## 정리: 레이어별 역할과 규칙

<ComparisonTable
  title="Clean Architecture 레이어별 역할"
  headers={['레이어', '역할', '의존 대상', '테스트 방법']}
  rows={[
    { feature: 'Domain', values: ['엔터티, 값 객체, 비즈니스 규칙', '없음 (순수 코드)', '단위 테스트 (mock 불필요)'] },
    { feature: 'Application', values: ['유스케이스, 흐름 조율', 'Domain 인터페이스', '단위 테스트 (Repository mock)'] },
    { feature: 'Infrastructure', values: ['저장소 구현', 'Domain 인터페이스', '단위 테스트 (InMemory)'] },
    { feature: 'Presentation', values: ['HTTP 요청/응답 처리', 'Application 유스케이스', '통합 테스트 (supertest)'] },
  ]}
/>

<Callout type="tip" title="이 실습에서 가장 중요한 한 가지">
  7개 실습을 통해 만든 코드에서 **저장소를 InMemory에서 PostgreSQL로 교체한다고 상상해보세요.** 바꿔야 하는 파일은 `in-memory-user-repository.ts` 하나와 `app.ts`의 조립 코드 한 줄뿐입니다. Domain, Application, Presentation Layer는 전혀 건드리지 않습니다. 이것이 Clean Architecture와 의존성 역전이 주는 실질적 가치입니다.
</Callout>


<ChapterNav
  prev={{ title: 'GitHub Actions', path: '/docs/part-4--mcp와-통합-github-actions' }}
  next={{ title: 'Python API', path: '/docs/part-5--실전-예제-python-api' }}
/>
