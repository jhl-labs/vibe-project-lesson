import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { FileTree } from '../../components/FileTree';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/TypeScript API" />

# TypeScript API 예제

> Express + Prisma + Jest 기반 Clean Architecture — Claude Code로 처음부터 구현하기

이 챕터에서는 **코드를 읽는 것**에서 끝나지 않습니다. Claude Code에 아래 프롬프트를 직접 입력하여 Clean Architecture 기반 TypeScript API를 **처음부터 구현**합니다.

## 완성 목표

<MermaidDiagram
  chart={`flowchart TB
    A["HTTP Request"] --> B["Presentation Layer\n(Controller)"]
    B --> C["Application Layer\n(Use Case)"]
    C --> D["Domain Layer\n(Entity + Value Object)"]
    C --> E["Infrastructure Layer\n(Prisma Repository)"]
    E --> F["PostgreSQL"]
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="Clean Architecture 레이어 구조"
  caption="의존성 방향: Presentation → Application → Domain ← Infrastructure"
/>

## 프로젝트 구조

<FileTree
  title="examples/typescript-api/"
  data={[
    {
      name: 'src/',
      type: 'folder',
      children: [
        {
          name: 'domain/',
          type: 'folder',
          description: '비즈니스 로직 (순수, 의존성 없음)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'entity.ts', type: 'file', description: 'User 엔터티' },
                { name: 'repository.ts', type: 'file', description: 'Repository 인터페이스' },
                { name: 'value-objects.ts', type: 'file', description: '값 객체 (Email, Name)' },
              ],
            },
          ],
        },
        {
          name: 'application/',
          type: 'folder',
          description: '유스케이스 (비즈니스 흐름 조율)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'create-user.ts', type: 'file', description: '사용자 생성 유스케이스' },
                { name: 'get-user.ts', type: 'file', description: '사용자 조회 유스케이스' },
                { name: 'dtos.ts', type: 'file', description: 'DTO 정의' },
              ],
            },
          ],
        },
        {
          name: 'infrastructure/',
          type: 'folder',
          description: 'DB, 외부 API 연동',
          children: [
            {
              name: 'persistence/',
              type: 'folder',
              children: [
                { name: 'prisma-user-repository.ts', type: 'file', description: 'Prisma 구현체' },
              ],
            },
          ],
        },
        {
          name: 'presentation/',
          type: 'folder',
          description: 'HTTP 컨트롤러',
          children: [
            {
              name: 'http/',
              type: 'folder',
              children: [
                { name: 'user-controller.ts', type: 'file', description: 'REST API' },
                { name: 'user-dto.ts', type: 'file', description: '요청/응답 DTO' },
              ],
            },
          ],
        },
      ],
    },
    {
      name: 'tests/',
      type: 'folder',
      children: [
        { name: 'user.test.ts', type: 'file', description: '단위 테스트' },
        { name: 'user.integration.test.ts', type: 'file', description: '통합 테스트' },
      ],
    },
    { name: 'package.json', type: 'file' },
    { name: 'tsconfig.json', type: 'file' },
    { name: 'prisma/', type: 'folder', children: [{ name: 'schema.prisma', type: 'file' }] },
  ]}
/>

---

## 실습 1: 프로젝트 초기화

Claude Code에 아래 프롬프트를 입력하여 프로젝트를 세팅합니다.

<CodeBlock
  code={`# 프롬프트 1: 프로젝트 초기화
> Express + Prisma + Jest + TypeScript 프로젝트를 초기화해줘.
> Clean Architecture 구조로 다음 디렉토리를 생성해:
> - src/domain/user/
> - src/application/user/
> - src/infrastructure/persistence/
> - src/presentation/http/
> - tests/
>
> tsconfig.json은 strict 모드로 설정하고,
> Jest는 ts-jest로 TypeScript를 지원하게 해줘.
> Prisma는 PostgreSQL로 설정하되 마이그레이션은 아직 실행하지 마.`}
  language="text"
  filename="실습: 프로젝트 초기화 프롬프트"
/>

<Callout type="tip" title="초기화 팁">
  프로젝트 루트에 **CLAUDE.md**를 먼저 만들면 Claude Code가 프로젝트 컨벤션을 일관되게 따릅니다.
  "CLAUDE.md를 먼저 생성해줘. 기술 스택은 Express + Prisma + Jest이고, Clean Architecture를 따르며, Conventional Commits를 사용한다고 적어줘."
</Callout>

### Prisma 스키마

<CodeBlock
  code={`// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  status    String   @default("pending")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`}
  language="prisma"
  filename="prisma/schema.prisma"
  highlightLines={[11, 12, 13, 14, 15]}
/>

### Docker Compose (개발 환경)

<CodeBlock
  code={`# docker-compose.yml
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: devpass
      POSTGRES_DB: clean_api
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:`}
  language="yaml"
  filename="docker-compose.yml"
/>

<CodeBlock
  code={`# .env
DATABASE_URL="postgresql://dev:devpass@localhost:5432/clean_api"`}
  language="bash"
  filename=".env"
/>

<CodeBlock
  code={`# 실습 프롬프트: 환경 설정
> docker-compose.yml로 PostgreSQL을 설정하고,
> .env에 DATABASE_URL을 넣어줘.
> Prisma 스키마에 User 모델을 정의하고 마이그레이션을 실행해줘.
> npx prisma migrate dev --name init`}
  language="text"
  filename="실습: 환경 설정 프롬프트"
/>

### CLAUDE.md 예시

<CodeBlock
  code={`# CLAUDE.md

## 프로젝트 개요
Express + Prisma + Jest 기반 Clean Architecture API

## 기술 스택
- Runtime: Node.js 20, TypeScript 5
- Framework: Express.js
- ORM: Prisma (PostgreSQL)
- Test: Jest + ts-jest + supertest

## 아키텍처 규칙
- src/domain/: 순수 비즈니스 로직 (외부 의존성 금지)
- src/application/: 유스케이스 (Domain 인터페이스만 의존)
- src/infrastructure/: DB, 외부 API 구현체
- src/presentation/: HTTP 컨트롤러

## 코딩 컨벤션
- 파일명: kebab-case.ts
- 클래스: PascalCase, 함수/변수: camelCase
- Conventional Commits (feat:, fix:, refactor:)
- 함수 최대 30줄

## 테스트 규칙
- 단위 테스트: Repository를 jest.Mocked로 mock
- 통합 테스트: supertest + 테스트 DB
- 테스트 파일: tests/*.test.ts`}
  language="markdown"
  filename="CLAUDE.md"
/>

<Callout type="info" title="CLAUDE.md가 중요한 이유">
  Claude Code는 세션 시작 시 CLAUDE.md를 자동으로 읽습니다. 아키텍처 규칙, 네이밍 컨벤션, 테스트 패턴을 여기에 명시하면 매번 프롬프트에서 반복하지 않아도 됩니다.
</Callout>

---

## 실습 2: Domain Layer 구현

### 값 객체 (Value Object)

<CodeBlock
  code={`// src/domain/user/value-objects.ts
export class Email {
  private constructor(public readonly value: string) {}

  static create(email: string): Email {
    if (!email.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)) {
      throw new Error(\`Invalid email: \${email}\`);
    }
    return new Email(email.toLowerCase());
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }
}`}
  language="typescript"
  filename="src/domain/user/value-objects.ts"
/>

<Callout type="info" title="값 객체(Value Object)란?">
  - **불변(immutable)**: 생성 후 변경 불가
  - **자기 검증(self-validating)**: 잘못된 값으로는 생성 자체가 불가능
  - **동등성 비교**: `equals()` 메서드로 값 기반 비교
  - Email을 `string`이 아닌 `Email` 타입으로 다루면 잘못된 이메일이 시스템에 유입되는 것을 컴파일 타임에 방지합니다
</Callout>

### 엔터티 (Entity)

<CodeBlock
  code={`// src/domain/user/entity.ts
import { Email } from './value-objects';

export class User {
  private constructor(
    public readonly id: string,
    public readonly email: Email,
    public readonly name: string,
    private _status: 'pending' | 'active' | 'inactive'
  ) {}

  static create(data: { email: string; name: string }): User {
    const email = Email.create(data.email);
    return new User(
      crypto.randomUUID(),
      email,
      data.name,
      'pending'
    );
  }

  static reconstitute(data: {
    id: string; email: string; name: string; status: string
  }): User {
    return new User(
      data.id,
      Email.create(data.email),
      data.name,
      data.status as 'pending' | 'active' | 'inactive'
    );
  }

  get status() { return this._status; }

  activate(): void {
    if (this._status !== 'pending') {
      throw new Error('Only pending users can be activated');
    }
    this._status = 'active';
  }

  deactivate(): void {
    if (this._status !== 'active') {
      throw new Error('Only active users can be deactivated');
    }
    this._status = 'inactive';
  }
}`}
  language="typescript"
  filename="src/domain/user/entity.ts"
  highlightLines={[5, 6, 7, 8, 12, 22, 35, 42]}
/>

<Callout type="info" title="Domain Layer 핵심 원칙">
  - **외부 의존성 없음**: 프레임워크, DB, HTTP 등에 의존하지 않음
  - **비즈니스 규칙 캡슐화**: `activate()`는 pending 상태에서만, `deactivate()`는 active 상태에서만 가능
  - **private constructor**: `create()` 팩토리 메서드를 통해서만 생성 가능 → 유효성 보장
  - **reconstitute()**: DB에서 복원할 때 사용 (검증 없이 기존 데이터로 재구성)
</Callout>

### Repository 인터페이스

<CodeBlock
  code={`// src/domain/user/repository.ts
import { User } from './entity';

export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: User): Promise<void>;
}`}
  language="typescript"
  filename="src/domain/user/repository.ts"
/>

<CodeBlock
  code={`# 실습 프롬프트: Domain Layer
> src/domain/user/ 아래에 다음 파일을 구현해줘:
> 1. value-objects.ts: Email 값 객체 (정규식 검증, 소문자 변환, equals)
> 2. entity.ts: User 엔터티 (private constructor, create/reconstitute 팩토리,
>    activate/deactivate 상태 전이)
> 3. repository.ts: IUserRepository 인터페이스 (findById, findByEmail, save)
>
> Domain Layer는 외부 의존성 없이 순수 TypeScript로만 작성해.`}
  language="text"
  filename="실습: Domain Layer 프롬프트"
/>

---

## 실습 3: Application Layer 구현

<CodeBlock
  code={`// src/application/user/dtos.ts
export class CreateUserDto {
  constructor(
    public readonly email: string,
    public readonly name: string,
  ) {}
}

export class UserResponseDto {
  constructor(
    public readonly id: string,
    public readonly email: string,
    public readonly name: string,
    public readonly status: string,
  ) {}

  static from(user: { id: string; email: { value: string }; name: string; status: string }) {
    return new UserResponseDto(user.id, user.email.value, user.name, user.status);
  }
}`}
  language="typescript"
  filename="src/application/user/dtos.ts"
/>

<CodeBlock
  code={`// src/application/user/create-user.ts
import { User } from '../../domain/user/entity';
import { IUserRepository } from '../../domain/user/repository';
import { CreateUserDto, UserResponseDto } from './dtos';

export class CreateUserUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(dto: CreateUserDto): Promise<UserResponseDto> {
    // 1. 비즈니스 검증: 이메일 중복 확인
    const existing = await this.userRepository.findByEmail(dto.email);
    if (existing) {
      throw new Error('Email already exists');
    }

    // 2. 도메인 엔터티 생성 (값 객체 검증 포함)
    const user = User.create({ email: dto.email, name: dto.name });

    // 3. 영속화
    await this.userRepository.save(user);

    // 4. 응답 DTO 변환
    return UserResponseDto.from(user);
  }
}`}
  language="typescript"
  filename="src/application/user/create-user.ts"
  highlightLines={[7, 11, 17, 20, 23]}
/>

<CodeBlock
  code={`# 실습 프롬프트: Application Layer
> src/application/user/ 아래에 유스케이스를 구현해줘:
> 1. dtos.ts: CreateUserDto, UserResponseDto
> 2. create-user.ts: 이메일 중복 체크 → User.create() → save → DTO 반환
> 3. get-user.ts: ID로 조회 → 없으면 Error throw → DTO 반환
>
> IUserRepository를 생성자 주입으로 받아서 의존성 역전을 적용해.`}
  language="text"
  filename="실습: Application Layer 프롬프트"
/>

---

## 실습 4: Infrastructure Layer 구현

<CodeBlock
  code={`// src/infrastructure/persistence/prisma-user-repository.ts
import { PrismaClient } from '@prisma/client';
import { User } from '../../domain/user/entity';
import { IUserRepository } from '../../domain/user/repository';

export class PrismaUserRepository implements IUserRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(id: string): Promise<User | null> {
    const row = await this.prisma.user.findUnique({ where: { id } });
    return row ? User.reconstitute(row) : null;
  }

  async findByEmail(email: string): Promise<User | null> {
    const row = await this.prisma.user.findUnique({ where: { email } });
    return row ? User.reconstitute(row) : null;
  }

  async save(user: User): Promise<void> {
    await this.prisma.user.upsert({
      where: { id: user.id },
      create: {
        id: user.id,
        email: user.email.value,
        name: user.name,
        status: user.status,
      },
      update: {
        email: user.email.value,
        name: user.name,
        status: user.status,
      },
    });
  }
}`}
  language="typescript"
  filename="src/infrastructure/persistence/prisma-user-repository.ts"
  highlightLines={[6, 11, 16, 20]}
/>

<Callout type="info" title="의존성 역전 원칙 (DIP)">
  - Domain Layer가 `IUserRepository` **인터페이스**를 정의
  - Infrastructure Layer가 `PrismaUserRepository`로 **구현**
  - Application Layer는 인터페이스에만 의존 → DB 변경 시 구현체만 교체하면 됨
  - 테스트 시 Mock Repository를 주입하여 DB 없이 단위 테스트 가능
</Callout>

---

## 실습 5: Presentation Layer 구현

<CodeBlock
  code={`// src/presentation/http/user-controller.ts
import { Router, Request, Response } from 'express';
import { CreateUserUseCase } from '../../application/user/create-user';
import { GetUserUseCase } from '../../application/user/get-user';
import { CreateUserDto } from '../../application/user/dtos';

export class UserController {
  public router = Router();

  constructor(
    private createUserUseCase: CreateUserUseCase,
    private getUserUseCase: GetUserUseCase,
  ) {
    this.router.post('/users', this.create.bind(this));
    this.router.get('/users/:id', this.getById.bind(this));
  }

  private async create(req: Request, res: Response) {
    try {
      const dto = new CreateUserDto(req.body.email, req.body.name);
      const result = await this.createUserUseCase.execute(dto);
      res.status(201).json(result);
    } catch (error) {
      if (error instanceof Error) {
        res.status(400).json({ error: error.message });
      }
    }
  }

  private async getById(req: Request, res: Response) {
    try {
      const result = await this.getUserUseCase.execute(req.params.id);
      res.json(result);
    } catch (error) {
      if (error instanceof Error) {
        res.status(404).json({ error: error.message });
      }
    }
  }
}`}
  language="typescript"
  filename="src/presentation/http/user-controller.ts"
/>

---

## 실습 6: 테스트 작성

<CodeBlock
  code={`// tests/user.test.ts
import { CreateUserUseCase } from '../src/application/user/create-user';
import { IUserRepository } from '../src/domain/user/repository';

describe('CreateUserUseCase', () => {
  let useCase: CreateUserUseCase;
  let mockRepo: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    mockRepo = {
      findById: jest.fn(),
      findByEmail: jest.fn().mockResolvedValue(null),
      save: jest.fn(),
    };
    useCase = new CreateUserUseCase(mockRepo);
  });

  it('should create user with valid data', async () => {
    const result = await useCase.execute({
      email: 'test@example.com',
      name: 'Test User',
    });

    expect(result.email).toBe('test@example.com');
    expect(result.name).toBe('Test User');
    expect(result.status).toBe('pending');
    expect(mockRepo.save).toHaveBeenCalledTimes(1);
  });

  it('should throw error for duplicate email', async () => {
    mockRepo.findByEmail.mockResolvedValue({} as any);

    await expect(
      useCase.execute({ email: 'test@example.com', name: 'Test' })
    ).rejects.toThrow('Email already exists');
  });

  it('should throw error for invalid email format', async () => {
    await expect(
      useCase.execute({ email: 'invalid-email', name: 'Test' })
    ).rejects.toThrow('Invalid email');
  });

  it('should lowercase email before saving', async () => {
    const result = await useCase.execute({
      email: 'Test@EXAMPLE.com',
      name: 'Test User',
    });

    expect(result.email).toBe('test@example.com');
  });
});`}
  language="typescript"
  filename="tests/user.test.ts"
  highlightLines={[18, 30, 38, 44]}
/>

<CodeBlock
  code={`# 실습 프롬프트: 테스트 작성 및 실행
> CreateUserUseCase의 단위 테스트를 작성해줘.
> 다음 케이스를 커버해:
> 1. 정상 생성 (이메일, 이름, 상태 검증)
> 2. 이메일 중복 시 에러
> 3. 잘못된 이메일 형식 시 에러
> 4. 이메일 소문자 변환 확인
>
> IUserRepository는 jest.Mocked로 mock하고,
> 테스트 작성 후 실행까지 해줘.`}
  language="text"
  filename="실습: 테스트 프롬프트"
/>

<Callout type="tip" title="테스트 작성 핵심 패턴">
  - **AAA 패턴**: Arrange(준비) → Act(실행) → Assert(검증)
  - **의존성 주입**: Repository를 Mock으로 교체하여 DB 없이 단위 테스트
  - **경계 테스트**: 정상 케이스와 에러 케이스를 모두 커버
  - **"테스트 작성 후 실행까지 해줘"**: Claude가 실행 결과를 보고 자동으로 오류를 수정합니다
</Callout>

---

## 실습 7: 전체 조립 및 검증

<CodeBlock
  code={`# 실습 프롬프트: 조립 및 통합 테스트
> 1. src/index.ts에 Express 앱을 생성하고 UserController를 등록해줘.
>    PrismaClient와 PrismaUserRepository를 연결해서 의존성을 조립해.
>
> 2. 통합 테스트를 작성해줘:
>    - supertest로 POST /users, GET /users/:id 엔드포인트 테스트
>    - 실제 Prisma Client를 사용하되, 테스트 DB를 사용하도록 설정
>
> 3. 모든 테스트를 실행하고 결과를 보여줘.`}
  language="text"
  filename="실습: 전체 조립 프롬프트"
/>

## 레이어 간 의존성 규칙 정리

<ComparisonTable
  title="Clean Architecture 레이어별 역할과 규칙"
  headers={['레이어', '역할', '의존 대상', '테스트 방법']}
  rows={[
    { feature: 'Domain', values: ['엔터티, 값 객체, 비즈니스 규칙', '없음 (순수 코드)', '단위 테스트 (mock 불필요)'] },
    { feature: 'Application', values: ['유스케이스, 흐름 조율', 'Domain 인터페이스', '단위 테스트 (Repository mock)'] },
    { feature: 'Infrastructure', values: ['DB, 외부 API 구현', 'Domain 인터페이스', '통합 테스트 (테스트 DB)'] },
    { feature: 'Presentation', values: ['HTTP 요청/응답 처리', 'Application 유스케이스', 'E2E 테스트 (supertest)'] },
  ]}
/>


<ChapterNav
  prev={{ title: 'MCP 서버 활용', path: '/docs/part-4--mcp와-통합-mcp-서버-활용' }}
  next={{ title: 'Python API', path: '/docs/part-5--실전-예제-python-api' }}
/>
