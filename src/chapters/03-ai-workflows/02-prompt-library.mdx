import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 3: AI Agent 워크플로우/프롬프트 라이브러리" />

# 프롬프트 라이브러리

> 상황별 최적화된 프롬프트 템플릿 모음

## 개요

프롬프트 라이브러리는 이 프로젝트 템플릿의 `docs/prompts/` 디렉토리에 저장된 **14개의 프롬프트 템플릿**입니다. 각 템플릿은 특정 개발 작업에 최적화된 구조화된 프롬프트를 제공합니다.

<Callout type="info" title="왜 프롬프트 라이브러리가 필요한가?">
  매번 프롬프트를 처음부터 작성하면 품질이 들쭉날쭉합니다.
  검증된 템플릿을 재사용하면 일관된 고품질 결과를 얻을 수 있습니다.
</Callout>

## 카테고리별 분류 (전체 14개)

| 카테고리 | 프롬프트 | 파일 | 핵심 산출물 |
|----------|----------|------|------------|
| 설계 | API 설계 | `api-design.md` | 엔드포인트, Request/Response 스키마 |
| 설계 | DB 스키마 | `database-schema.md` | ERD, DDL, 인덱스 전략 |
| 설계 | 아키텍처 결정 | `architecture-decision.md` | ADR 문서, 옵션 비교표 |
| 구현 | 기능 구현 | `feature-implement.md` | 레이어별 코드, 테스트 |
| 구현 | 버그 수정 | `bug-fix.md` | 근본 원인 분석, 수정 코드 |
| 구현 | 리팩토링 | `refactor.md` | 코드 스멜 분석, 개선 코드 |
| 검토 | 코드 리뷰 | `code-review.md` | 심각도별 피드백 |
| 검토 | 보안 검토 | `security-review.md` | OWASP 기반 취약점 리포트 |
| 검토 | 성능 검토 | `performance-review.md` | 병목 분석, 최적화 방안 |
| 테스트 | 테스트 생성 | `test-generation.md` | 단위/통합/E2E 테스트 코드 |
| 마이그레이션 | 마이그레이션 | `migration.md` | 실행 계획, 롤백 전략 |
| 마이그레이션 | 의존성 업그레이드 | `upgrade-dependency.md` | Breaking changes, 마이그레이션 가이드 |
| 문서 | API 문서 | `api-docs.md` | OpenAPI 스펙, 예시 코드 |
| 문서 | README 생성 | `readme-gen.md` | 구조화된 README |

## 프롬프트 공통 구조

모든 프롬프트 템플릿은 다음 5개 섹션 구조를 따릅니다:

<CodeBlock
  code={`# 프롬프트 제목

## 목적
이 프롬프트가 해결하는 문제

## 프롬프트 템플릿
[변수]를 채워서 AI에게 전달할 텍스트

## 출력 형식
기대하는 결과물의 구조

## 예시
구체적인 입력 → 출력 사례

## 체크리스트
완료 후 검증 항목`}
  language="markdown"
  filename="프롬프트 공통 구조"
/>

---

## 설계 (Design) 프롬프트

### api-design.md — API 설계

RESTful API 엔드포인트를 체계적으로 설계합니다. 리소스명과 요구사항을 입력하면 엔드포인트 목록, Request/Response 스키마, 에러 케이스, 인증 요구사항을 생성합니다.

**필수 입력:** 리소스명, 비즈니스 요구사항, 관련 도메인 엔티티, 제약 조건

<CodeBlock
  code={`# 프롬프트 템플릿 (핵심)
나는 [리소스명]에 대한 API를 설계해야 해.

### 요구사항
- [비즈니스 요구사항]

### 관련 도메인 엔티티
- [엔티티]: [설명]

### 제약 조건
- [보안/성능/호환성 요구사항]

다음을 포함해서 API를 설계해줘:
1. 엔드포인트 목록 (HTTP method, path, description)
2. Request/Response 스키마
3. 에러 케이스
4. 인증/권한 요구사항

# 출력 예시 (주문 API)
## API 설계: Order

| Method | Path | Description | Auth |
|--------|------|-------------|------|
| POST | /api/v1/orders | 주문 생성 | Customer |
| GET | /api/v1/orders | 내 주문 목록 | Customer |
| GET | /api/v1/orders/:id | 주문 상세 | Customer/Admin |
| PATCH | /api/v1/orders/:id/status | 상태 변경 | Admin |
| POST | /api/v1/orders/:id/cancel | 주문 취소 | Customer |`}
  language="markdown"
  filename="api-design.md"
/>

**체크리스트:** RESTful 원칙 준수, 일관된 명명 규칙, 적절한 HTTP 상태 코드, 페이지네이션, 버전 관리(/v1/), 에러 응답 형식 통일

### database-schema.md — DB 스키마 설계

데이터베이스 스키마를 설계합니다. 도메인과 엔티티 관계를 입력하면 ERD(Mermaid), 테이블 정의, DDL, 인덱스 전략, 마이그레이션 고려사항을 생성합니다.

**필수 입력:** 도메인 설명, 주요 엔티티, 관계, DB 종류, 성능 요구사항

<CodeBlock
  code={`# 출력 예시 (이커머스 주문 시스템, PostgreSQL)

### ERD (Mermaid)
erDiagram
    USER ||--o{ ORDER : places
    ORDER ||--|{ ORDER_ITEM : contains
    PRODUCT ||--o{ ORDER_ITEM : "ordered in"

### DDL (발췌)
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(12, 2) NOT NULL CHECK (total_amount >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT chk_order_status CHECK (
        status IN ('pending','confirmed','shipped','delivered','cancelled')
    )
);

### 인덱스 전략 (발췌)
-- 주문 이력 조회 (사용자별 + 날짜순)
CREATE INDEX idx_orders_user_created
ON orders(user_id, created_at DESC);

-- Partial Index: 진행 중인 주문만
CREATE INDEX idx_orders_status
ON orders(status) WHERE status NOT IN ('delivered','cancelled');`}
  language="sql"
  filename="database-schema.md"
/>

**체크리스트:** 정규화 수준, 인덱스 전략, 제약 조건, Soft delete 정책, 타임스탬프, NULL 허용 정책, 데이터 타입 최적화

### architecture-decision.md — 아키텍처 결정

기술 의사결정을 구조화된 ADR(Architecture Decision Record)로 작성합니다. 여러 옵션의 장단점을 비교하고 권장 결정 및 근거를 제시합니다.

**필수 입력:** 결정이 필요한 사안, 후보 옵션들, 평가 기준, 제약 조건

<CodeBlock
  code={`# 프롬프트 템플릿 (핵심)
아키텍처 결정이 필요해.

### 결정 사안
[어떤 기술/구조적 결정이 필요한지]

### 후보 옵션
- 옵션 A: [설명]
- 옵션 B: [설명]

### 평가 기준
- [성능, 확장성, 학습 곡선, 비용 등]

# 출력 예시 (실시간 알림 기술 스택 선정)
## ADR-007: 실시간 알림 시스템 기술 스택

### 비교표
| 기준 | Socket.io | AWS AppSync | Pusher |
|------|-----------|-------------|--------|
| 실시간성 | 매우 높음 | 높음 | 높음 |
| 확장성 | 직접 관리 | 자동 | 자동 |
| 비용 | 서버 비용 | 종량제 | 고정+종량 |
| 학습 곡선 | 중간 | 높음 | 낮음 |

### 결정: Socket.io
### 근거: 실시간성 최우선, 기존 Node.js 인프라 활용 가능`}
  language="markdown"
  filename="architecture-decision.md"
/>

---

## 구현 (Implementation) 프롬프트

### feature-implement.md — 기능 구현

새로운 기능을 프로젝트의 아키텍처와 컨벤션에 맞게 구현합니다. Clean Architecture 4레이어(Domain → Application → Infrastructure → Presentation)를 따라 구현 코드, 테스트, 문서를 생성합니다.

**필수 입력:** 사용자 스토리, 수락 조건, 기술적 요구사항, 영향받는 레이어

<CodeBlock
  code={`# 프롬프트 템플릿 (핵심)
새 기능을 구현해줘.

### 사용자 스토리
[사용자]로서 [기능]을 원한다. 그래야 [가치]를 얻을 수 있다.

### 수락 조건
- [조건 1]
- [조건 2]

### 기술적 요구사항
- [요구사항]

다음 순서로 구현해줘:
1. 구현 계획 및 파일 변경 목록
2. Domain Layer (Entity, Value Object)
3. Application Layer (Use Case)
4. Infrastructure Layer (Repository)
5. Presentation Layer (Controller, DTO)
6. 테스트 코드
7. 문서 업데이트

# 출력 예시 (사용자 활동 로그 조회 기능)
## 구현 계획

### 파일 변경 목록
| 파일 | 변경 유형 | 설명 |
|------|----------|------|
| src/domain/entities/ActivityLog.ts | 추가 | 엔티티 정의 |
| src/application/usecases/GetActivityLogs.ts | 추가 | 유스케이스 |
| src/infrastructure/repositories/ActivityLogRepo.ts | 추가 | 저장소 |
| src/presentation/controllers/ActivityController.ts | 추가 | API 엔드포인트 |
| src/presentation/dtos/ActivityLogDto.ts | 추가 | 응답 DTO (IP 마스킹) |`}
  language="markdown"
  filename="feature-implement.md"
/>

### bug-fix.md — 버그 수정

버그를 체계적으로 분석하고 수정합니다. 증상과 재현 방법을 입력하면 근본 원인 분석, 수정 코드, 테스트, 회귀 방지 방안을 제공합니다.

**필수 입력:** 증상, 재현 방법, 예상/실제 동작, 에러 메시지, 관련 코드 위치

<CodeBlock
  code={`# 출력 예시 (JWT 토큰 간헐적 만료 버그)

## 근본 원인
토큰 검증 시 서버 시간과 토큰 생성 시간 사이에 시간대(timezone) 불일치.
서버가 UTC를 사용하지만 토큰 생성 시 로컬 시간을 사용하고 있어,
특정 조건에서 토큰이 미래에 생성된 것으로 판단되어 무효화됩니다.

## 수정 코드
// auth.ts — 토큰 생성 시 UTC 사용
const generateToken = (userId: string) => {
  return jwt.sign(
    { userId, iat: Math.floor(Date.now() / 1000) },
    SECRET,
    { expiresIn: '1h' }
  );
};

// auth.middleware.ts — clock skew 허용
const verifyToken = (token: string) => {
  return jwt.verify(token, SECRET, {
    clockTolerance: 60 // 60초 허용
  });
};

## 회귀 방지
- CI에 시간대 관련 테스트 추가
- 토큰 생성/검증 로직을 단일 모듈로 캡슐화`}
  language="typescript"
  filename="bug-fix.md"
/>

**체크리스트:** 근본 원인 파악, 재현 테스트 작성, 사이드 이펙트 검토, 회귀 테스트 추가, 관련 문서 업데이트

### refactor.md — 리팩토링

코드 개선을 위한 리팩토링을 제안합니다. 현재 문제점을 분석하고 단계별 개선 방안을 제시합니다.

**필수 입력:** 대상 코드/파일, 현재 문제점, 리팩토링 목표

<CodeBlock
  code={`# 프롬프트 템플릿 (핵심)
리팩토링을 해줘.

### 대상 코드
[파일 경로]

### 현재 문제점
- [문제 1: 예 - 함수가 200줄로 너무 김]
- [문제 2: 예 - 5단계 중첩 조건문]

### 목표
- [가독성 향상]
- [테스트 용이성 개선]

# 출력 예시 (200줄 processOrder 함수)
## 발견된 코드 스멜
1. Long Method (200줄)
2. Feature Envy (Order 객체 내부 로직을 외부에서 처리)
3. Complex Conditional (5단계 중첩)

## 리팩토링 계획
### Step 1: Extract Method — 검증 로직 분리
### Step 2: Introduce Parameter Object — 파라미터 그룹화
### Step 3: Replace Conditional with Strategy — 결제 방식별 분기 제거

## 예상 효과
- 함수 평균 길이: 200줄 → 20줄
- 순환 복잡도: 15 → 3
- 테스트 케이스 분리 가능`}
  language="markdown"
  filename="refactor.md"
/>

---

## 검토 (Review) 프롬프트

### code-review.md — 코드 리뷰

변경된 코드에 대해 체계적인 리뷰를 수행합니다. Critical/Major/Minor/Positive 4단계로 분류된 피드백과 최종 승인 상태를 제공합니다.

**필수 입력:** 변경 목적, 변경 파일 목록

<CodeBlock
  code={`# 출력 예시 (프로필 이미지 업로드 기능 리뷰)

## 코드 리뷰 결과

### Critical
🔴 [src/api/upload.ts:34] MIME 타입 검증 누락
- Content-Type 헤더만 확인하고 파일 매직 바이트를 검증하지 않음
- 악성 파일 업로드 가능

🔴 [src/api/upload.ts:52] Path Traversal 취약점
- 파일명을 그대로 사용하여 ../../../etc/passwd 접근 가능
→ uuid로 파일명 생성 필요

### Major
🟠 [src/services/image.ts:15] 이미지 리사이징 미적용
- 원본 크기 그대로 저장 시 스토리지/대역폭 낭비

### Positive
✅ 에러 핸들링이 일관적으로 잘 구현됨

### 결론: 수정 요청 (Critical 2건 해결 필요)`}
  language="markdown"
  filename="code-review.md"
/>

### security-review.md — 보안 검토

OWASP Top 10 기반으로 코드의 보안 취약점을 식별합니다. 각 취약점에 대해 공격 시나리오와 수정 코드를 함께 제시합니다.

**필수 입력:** 검토 대상, 시스템 컨텍스트(시스템 유형, 인증 방식, 데이터 민감도), 위협 모델

<CodeBlock
  code={`# 출력 예시 (사용자 정보 API 보안 검토)

## 보안 검토 결과
- Critical: 1건 / High: 2건 / Medium: 1건 / Low: 1건

### [CRITICAL] IDOR — 타 사용자 정보 접근 가능
위치: user.controller.ts:45
유형: A01:2021-Broken Access Control

// 현재 코드 — 권한 확인 없음
@Get(':id')
async getUser(@Param('id') id: string) {
  return this.userService.findById(id);
}

// 수정 코드 — 본인 또는 관리자만 접근
@Get(':id')
@UseGuards(AuthGuard)
async getUser(@Param('id') id: string, @CurrentUser() user: User) {
  if (id !== user.id && !user.isAdmin) {
    throw new ForbiddenException();
  }
  return this.userService.findById(id);
}

### [HIGH] SQL Injection
위치: user.service.ts:23
// 현재: 문자열 직접 연결
this.db.query(\`SELECT * FROM users WHERE name LIKE '%\${query}%'\`)
// 수정: 파라미터화된 쿼리
this.db.query('SELECT * FROM users WHERE name LIKE $1', [\`%\${query}%\`])

### [HIGH] 민감 정보 로깅
에러 로그에 비밀번호 포함 → sanitizedBody 사용`}
  language="typescript"
  filename="security-review.md"
/>

**OWASP Top 10:2025 체크리스트:** A01 접근 제어, A02 보안 설정 오류, A03 공급망 취약점, A04 암호화 실패, A05 인젝션, A06 불안전한 설계, A07 인증 실패, A08 무결성 실패, A09 로깅 실패, A10 예외 처리 미흡

### performance-review.md — 성능 검토

코드 및 시스템의 성능 이슈를 분석합니다. 병목 지점을 식별하고 우선순위별 최적화 방안과 예상 개선 효과를 제시합니다.

**필수 입력:** 성능 지표(응답 시간, 처리량 등), 문제 증상, 환경 정보

<CodeBlock
  code={`# 출력 예시 (주문 목록 API 성능 분석)

## 성능 분석 결과

### 병목 지점
1. 🔴 N+1 쿼리 (주문별 상품 정보 개별 조회)
   → Eager Loading / DataLoader 적용
2. 🟠 불필요한 컬럼 로딩 (전체 SELECT *)
   → 필요 컬럼만 SELECT
3. 🟡 인덱스 미사용 (user_id + created_at 복합 인덱스 없음)
   → 복합 인덱스 추가

### 최적화 방안 (우선순위별)
| 순위 | 방안 | 예상 개선 |
|------|------|----------|
| 1 | N+1 해결 (JOIN) | 응답 시간 60% 감소 |
| 2 | 캐시 레이어 추가 | 반복 요청 90% 감소 |
| 3 | 컬럼 선택 최적화 | 데이터 전송량 40% 감소 |`}
  language="markdown"
  filename="performance-review.md"
/>

---

## 테스트 프롬프트

### test-generation.md — 테스트 생성

대상 코드에 대한 테스트 케이스를 생성합니다. AAA(Arrange-Act-Assert) 패턴을 따르며, 단위/통합/E2E 테스트를 지원합니다.

**필수 입력:** 테스트 대상 코드, 테스트 유형, 테스트 프레임워크

<CodeBlock
  code={`# 출력 예시 (UserService Jest 단위 테스트)

describe('UserService', () => {
  let service: UserService;
  let mockRepo: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockRepo = {
      findByEmail: jest.fn(),
      save: jest.fn(),
    };
    service = new UserService(mockRepo);
  });

  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // Arrange
      const dto = { email: 'test@example.com', name: 'Test' };
      mockRepo.findByEmail.mockResolvedValue(null);
      mockRepo.save.mockResolvedValue({ id: '1', ...dto });

      // Act
      const result = await service.createUser(dto);

      // Assert
      expect(result.email).toBe('test@example.com');
      expect(mockRepo.save).toHaveBeenCalledTimes(1);
    });

    it('should throw if email already exists', async () => {
      mockRepo.findByEmail.mockResolvedValue({ id: '1' });
      await expect(service.createUser({ email: 'dup@test.com' }))
        .rejects.toThrow(DuplicateEmailError);
    });
  });
});`}
  language="typescript"
  filename="test-generation.md"
/>

---

## 마이그레이션 프롬프트

### migration.md — 마이그레이션

코드, 데이터, 의존성, 플랫폼 마이그레이션을 위한 계획을 수립합니다. 위험 평가, 단계별 실행 가이드, 롤백 계획을 포함합니다.

**필수 입력:** 마이그레이션 대상, 현재 환경, 목표 환경, 제약 조건

<CodeBlock
  code={`# 출력 예시 (MySQL 5.7 → PostgreSQL 15 마이그레이션)

## 마이그레이션 계획

### 위험 평가
| 항목 | 위험도 | 설명 |
|------|--------|------|
| 데이터 타입 차이 | 높음 | TINYINT, ENUM 등 변환 필요 |
| 저장 프로시저 | 중간 | 문법 차이 수동 변환 |
| 다운타임 | 높음 | 데이터 이관 시간 |

### 실행 단계
1. 스키마 변환 (DDL 호환성 검증)
2. 데이터 마이그레이션 (pgloader 사용)
3. 애플리케이션 코드 수정 (쿼리 호환성)
4. 성능 테스트
5. 스위치오버

### 롤백 계획
- Point-in-time: 원본 DB 유지 (2주간)
- 애플리케이션: 환경 변수로 DB 전환`}
  language="markdown"
  filename="migration.md"
/>

### upgrade-dependency.md — 의존성 업그레이드

라이브러리 버전 업그레이드를 체계적으로 수행합니다. Breaking changes, 마이그레이션 단계, 코드 변경, 테스트 및 롤백 계획을 포함합니다.

**필수 입력:** 대상 라이브러리, 현재 버전, 목표 버전, 업그레이드 이유

<CodeBlock
  code={`# 출력 예시 (React 17 → 18 업그레이드)

## Breaking Changes
1. ReactDOM.render → createRoot (필수)
2. TypeScript: children prop 자동 포함 제거
3. Strict Mode 동작 변경 (useEffect 2번 실행)

## 마이그레이션 단계
### Step 1: createRoot 마이그레이션
// Before (React 17)
ReactDOM.render(<App />, document.getElementById('root'));

// After (React 18)
const root = createRoot(document.getElementById('root')!);
root.render(<App />);

### Step 2: TypeScript children prop 명시
// Before — 암시적 children
const Card: FC = ({ children }) => ...

// After — 명시적 PropsWithChildren
const Card: FC<PropsWithChildren> = ({ children }) => ...

## 점진적 마이그레이션 전략
- Phase 1: createRoot 전환 (즉시)
- Phase 2: Concurrent Features 도입 (선택적)
- Phase 3: Suspense for Data Fetching (향후)`}
  language="typescript"
  filename="upgrade-dependency.md"
/>

---

## 문서 프롬프트

### api-docs.md — API 문서

OpenAPI/Swagger/Markdown 형식으로 API 문서를 생성합니다. 엔드포인트 설명, 스키마, 인증 정보, 에러 코드, 다국어 예시 코드(JavaScript, Python, cURL)를 포함합니다.

**필수 입력:** API 엔드포인트, 인증 방식, 응답 형식

<CodeBlock
  code={`# 출력 예시 (사용자 관리 API 문서)

## POST /api/v1/users
사용자를 생성합니다.

### Request
Content-Type: application/json
Authorization: Bearer <token>

{
  "email": "user@example.com",
  "name": "홍길동",
  "role": "user"
}

### Response (201 Created)
{
  "id": "usr_abc123",
  "email": "user@example.com",
  "name": "홍길동",
  "created_at": "2024-01-15T10:30:00Z"
}

### 에러 코드
| 코드 | 설명 |
|------|------|
| 400 | 유효성 검증 실패 (이메일 형식 등) |
| 401 | 인증 토큰 없음 또는 만료 |
| 409 | 이메일 중복 |

### 예시 코드 (cURL)
curl -X POST https://api.example.com/v1/users \\
  -H "Authorization: Bearer TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"email":"user@example.com","name":"홍길동"}'`}
  language="markdown"
  filename="api-docs.md"
/>

### readme-gen.md — README 생성

프로젝트의 구조화된 README를 생성합니다. 배지, 주요 기능, 설치/실행 방법, 환경 변수, 프로젝트 구조, 기여 방법, 라이선스를 포함합니다.

**필수 입력:** 프로젝트명, 설명, 기술 스택, 포함할 섹션

<CodeBlock
  code={`# 출력 예시 (TaskFlow 프로젝트)

# TaskFlow
> 팀 협업을 위한 태스크 관리 플랫폼

![Build](https://img.shields.io/badge/build-passing-brightgreen)
![License](https://img.shields.io/badge/license-MIT-blue)

## 주요 기능
- 드래그 앤 드롭 칸반 보드
- 실시간 협업 (WebSocket)
- GitHub/Slack 통합

## 빠른 시작
git clone https://github.com/team/taskflow.git
cd taskflow
npm install
cp .env.example .env
npm run dev

## 환경 변수
| 변수 | 설명 | 기본값 |
|------|------|--------|
| DATABASE_URL | PostgreSQL 연결 | - |
| JWT_SECRET | JWT 서명 키 | - |
| REDIS_URL | Redis 연결 | localhost:6379 |

## 프로젝트 구조
src/
├── domain/        # 비즈니스 로직
├── application/   # 유스케이스
├── infrastructure/ # DB, 외부 API
└── presentation/  # HTTP 레이어`}
  language="markdown"
  filename="readme-gen.md"
/>

---

## 프롬프트 활용 팁

<Callout type="tip" title="효과적인 활용법">
  1. **그대로 사용하지 말고 커스터마이즈**: 프로젝트 특성에 맞게 수정하세요
  2. **컨텍스트를 충분히 제공**: 관련 파일 경로, 기존 패턴 명시
  3. **제약사항을 명확히**: "~하지 마라"를 명시하면 품질이 올라갑니다
  4. **출력 형식을 지정**: 원하는 결과물의 형태를 구체적으로 요구하세요
</Callout>


<ChapterNav
  prev={{ title: '슬래시 커맨드', path: '/docs/part-3--ai-agent-워크플로우-슬래시-커맨드' }}
  next={{ title: '스킬', path: '/docs/part-3--ai-agent-워크플로우-스킬' }}
/>
