import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { DataTable } from '../../components/DataTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 3: AI Agent 워크플로우/Hooks" />

# Hooks

> Claude Code의 도구 실행 전후에 자동으로 실행되는 셸 스크립트

## 개요

Hooks는 Claude Code의 **이벤트 기반 자동화 시스템**입니다. 도구 실행 전후, 세션 시작/종료, 알림 발생 등 다양한 시점에 셸 커맨드, 프롬프트, 서브에이전트를 자동 실행할 수 있습니다. 린트, 보안 스캔, 포맷팅 등을 자동화하여 일관된 코드 품질을 유지하는 핵심 기능입니다.

<Callout type="info" title="슬래시 커맨드 vs Hooks">
  슬래시 커맨드는 개발자가 **직접 호출**하는 반면,
  Hooks는 특정 이벤트 발생 시 **자동으로 실행**됩니다.
  둘을 조합하면 강력한 워크플로우 자동화가 가능합니다.
</Callout>

## 설정 위치

| 위치 | 범위 | 공유 |
|------|------|------|
| `~/.claude/settings.json` | 모든 프로젝트 | 아니오 (개인) |
| `.claude/settings.json` | 단일 프로젝트 | 예 (저장소 커밋) |
| `.claude/settings.local.json` | 단일 프로젝트 | 아니오 (gitignore) |
| Managed Settings | 조직 전체 | 예 (관리자 제어) |

## 이벤트 타입

<DataTable
  title="Hook 이벤트 전체 목록"
  searchable={true}
  columns={[
    { key: 'event', header: '이벤트' },
    { key: 'timing', header: '발생 시점' },
    { key: 'blockable', header: '차단 가능' },
    { key: 'matcher', header: 'Matcher 대상' },
  ]}
  data={[
    { event: 'PreToolUse', timing: '도구 실행 전', blockable: '예', matcher: '도구 이름 (Bash, Edit 등)' },
    { event: 'PostToolUse', timing: '도구 실행 성공 후', blockable: '아니오', matcher: '도구 이름' },
    { event: 'PostToolUseFailure', timing: '도구 실행 실패 후', blockable: '아니오', matcher: '도구 이름' },
    { event: 'PermissionRequest', timing: '권한 다이얼로그 표시 시', blockable: '예', matcher: '도구 이름' },
    { event: 'UserPromptSubmit', timing: '프롬프트 제출 후, 처리 전', blockable: '예', matcher: '(없음)' },
    { event: 'Stop', timing: 'Claude 응답 완료 시', blockable: '예', matcher: '(없음)' },
    { event: 'SessionStart', timing: '세션 시작/재개', blockable: '아니오', matcher: 'startup, resume, clear, compact' },
    { event: 'SessionEnd', timing: '세션 종료', blockable: '아니오', matcher: 'clear, logout, prompt_input_exit 등' },
    { event: 'SubagentStart', timing: '서브에이전트 생성 시', blockable: '아니오', matcher: '에이전트 타입' },
    { event: 'SubagentStop', timing: '서브에이전트 완료 시', blockable: '예', matcher: '에이전트 타입' },
    { event: 'Notification', timing: '알림 발생 시', blockable: '아니오', matcher: '알림 유형' },
    { event: 'PreCompact', timing: '컨텍스트 압축 전', blockable: '아니오', matcher: 'manual, auto' },
  ]}
/>

## 설정 구조

<CodeBlock
  code={`// .claude/settings.json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/block-dangerous-commands.sh",
            "timeout": 600
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '.tool_input.file_path' | xargs npx prettier --write",
            "timeout": 30
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename=".claude/settings.json"
/>

### 핵심 필드

| 필드 | 타입 | 설명 |
|------|------|------|
| `matcher` | 정규식 | 이벤트 매칭 패턴 (도구 이름, 세션 타입 등) |
| `type` | `"command"` \| `"prompt"` \| `"agent"` | 핸들러 유형 |
| `command` | string | 실행할 셸 명령 (`type: "command"`) |
| `prompt` | string | LLM에 전달할 프롬프트 (`type: "prompt"` / `"agent"`) |
| `timeout` | number | 타임아웃 초 (command: 600, prompt: 30, agent: 60) |
| `async` | boolean | 비동기 실행 여부 (기본 false) |

### 핸들러 타입 3가지

<ComparisonTable
  title="Hook 핸들러 비교"
  headers={['타입', '실행 방식', '용도', '기본 timeout']}
  rows={[
    { feature: 'command', values: ['셸 명령 실행', '린트, 포맷팅, 스크립트', '600초'] },
    { feature: 'prompt', values: ['LLM 단일 턴 평가', '코드 리뷰, 검증', '30초'] },
    { feature: 'agent', values: ['도구 접근 가능한 서브에이전트', '테스트 실행, 복잡한 검증', '60초'] },
  ]}
/>

## Matcher 패턴

Matcher는 **정규식**으로 작성합니다. 도구 기반 이벤트에서 매칭 가능한 내장 도구 이름:

<CodeBlock
  code={`# 내장 도구
Bash, Edit, Write, Read, Glob, Grep, Task, WebFetch, WebSearch

# MCP 도구 (mcp__서버명__도구명 형식)
mcp__memory__create_entities
mcp__filesystem__read_file
mcp__github__search_repositories

# 정규식 매칭 예시
"matcher": "Bash"              # Bash 도구만
"matcher": "Edit|Write"        # Edit 또는 Write
"matcher": "mcp__.*"           # 모든 MCP 도구
"matcher": ".*"                # 모든 도구`}
  language="text"
  filename="Matcher 패턴 예시"
/>

## Exit Code 규칙

Hook의 exit code에 따라 Claude Code의 동작이 달라집니다.

| Exit Code | 의미 | 동작 |
|-----------|------|------|
| **0** | 성공 | stdout의 JSON 출력 처리 |
| **2** | 차단 오류 | 해당 동작을 차단하고 stderr를 Claude에게 피드백 |
| **기타** | 비차단 오류 | stderr는 verbose 모드에서만 표시 |

## 실전 예제

### 1. 위험한 명령 차단 (PreToolUse)

<CodeBlock
  code={`#!/bin/bash
# .claude/hooks/block-dangerous-commands.sh
COMMAND=$(jq -r '.tool_input.command')

if echo "$COMMAND" | grep -qE 'rm -rf|DROP TABLE|format |mkfs'; then
  echo "Destructive command blocked: $COMMAND" >&2
  exit 2
fi

exit 0`}
  language="bash"
  filename=".claude/hooks/block-dangerous-commands.sh"
/>

<CodeBlock
  code={`// .claude/settings.json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/block-dangerous-commands.sh"
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename="위험 명령 차단 설정"
/>

### 2. 파일 저장 후 자동 포맷팅 (PostToolUse)

<CodeBlock
  code={`// .claude/settings.json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "jq -r '.tool_input.file_path' | xargs npx prettier --write"
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename="자동 포맷팅 설정"
/>

### 3. 보호 파일 수정 차단 (PreToolUse)

<CodeBlock
  code={`#!/bin/bash
# .claude/hooks/protect-files.sh
FILE_PATH=$(jq -r '.tool_input.file_path // .tool_input.file')

PROTECTED_FILES=("package-lock.json" "yarn.lock" ".env" ".env.production")

for protected in "\${PROTECTED_FILES[@]}"; do
  if [[ "$FILE_PATH" == *"$protected" ]]; then
    echo "Protected file cannot be modified: $FILE_PATH" >&2
    exit 2
  fi
done

exit 0`}
  language="bash"
  filename=".claude/hooks/protect-files.sh"
/>

### 4. 비동기 테스트 실행 (PostToolUse)

<CodeBlock
  code={`// 코드 변경 후 백그라운드에서 테스트 실행
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/run-tests-async.sh",
            "async": true,
            "timeout": 300
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename="비동기 테스트 설정"
/>

### 5. 응답 완료 시 테스트 검증 (Stop + agent)

<CodeBlock
  code={`// Claude가 작업을 마칠 때마다 서브에이전트가 테스트 검증
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "agent",
            "prompt": "모든 유닛 테스트를 실행하고 결과를 확인하세요.",
            "timeout": 120
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename="Stop 이벤트 테스트 검증"
/>

### 6. 컴팩션 후 컨텍스트 재주입 (SessionStart)

<CodeBlock
  code={`// /compact 실행 후 중요한 컨텍스트를 다시 주입
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "compact",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Reminder: npm 대신 Bun을 사용하세요. 커밋 전 bun test를 실행하세요.'"
          }
        ]
      }
    ]
  }
}`}
  language="json"
  filename="컴팩션 후 컨텍스트 재주입"
/>

## 입출력 스키마

Hook은 stdin으로 JSON을 받고 stdout으로 JSON을 출력합니다.

### 입력 (stdin)

<CodeBlock
  code={`{
  "session_id": "abc123",
  "transcript_path": "/path/to/transcript.jsonl",
  "cwd": "/path/to/project",
  "hook_event_name": "PreToolUse",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test"
  }
}`}
  language="json"
  filename="Hook 입력 예시"
/>

### 출력 (stdout) - PreToolUse 차단

<CodeBlock
  code={`{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Destructive command blocked"
  }
}`}
  language="json"
  filename="PreToolUse 차단 출력"
/>

### 출력 (stdout) - PreToolUse 입력 수정

<CodeBlock
  code={`{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow",
    "updatedInput": {
      "command": "npm test -- --coverage"
    }
  }
}`}
  language="json"
  filename="PreToolUse 입력 수정 출력"
/>

## 환경 변수

| 변수 | 설명 |
|------|------|
| `$CLAUDE_PROJECT_DIR` | 프로젝트 루트 경로 |
| `$CLAUDE_ENV_FILE` | SessionStart에서만 사용, 환경 변수 영속화 파일 |

## CI/CD 통합 패턴

Hooks는 CI/CD 파이프라인과 결합하면 더 강력해집니다.

### GitHub Actions에서 Headless Mode + Hooks

<CodeBlock
  code={`# .github/workflows/claude-review.yml
name: Claude Code Review
on: [pull_request]
jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Claude Code
        run: curl -fsSL https://claude.ai/install.sh | bash
      - name: Run Claude Review
        env:
          ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          git diff origin/main...HEAD | claude -p \\
            "이 PR의 변경사항을 보안, 성능, 코드 품질 관점에서 리뷰해줘. 결과를 markdown으로 출력해줘." \\
            --output-format json > review.json`}
  language="yaml"
  filename=".github/workflows/claude-review.yml"
/>

### Pre-commit Hook 통합

<CodeBlock
  code={`#!/bin/bash
# .git/hooks/pre-commit
# Claude Code로 커밋 전 자동 검증

# 변경된 파일 목록 추출
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -n "$CHANGED_FILES" ]; then
  echo "Claude Code: 커밋 전 보안 검사 중..."
  echo "$CHANGED_FILES" | claude -p \\
    "다음 파일들의 변경사항에서 하드코딩된 시크릿, SQL 인젝션, XSS 취약점이 있는지 검사해줘. 문제가 있으면 exit code 1로 종료해줘."

  if [ $? -ne 0 ]; then
    echo "보안 검사 실패. 커밋이 차단되었습니다."
    exit 1
  fi
fi`}
  language="bash"
  filename=".git/hooks/pre-commit"
/>

### 복합 Hook 구성 예시

여러 Hook을 조합하여 완전 자동화된 워크플로우를 구성할 수 있습니다.

<CodeBlock
  code={`{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {"type": "command", "command": ".claude/hooks/block-dangerous-commands.sh"}
        ]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [
          {"type": "command", "command": ".claude/hooks/protect-files.sh"}
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {"type": "command", "command": "jq -r '.tool_input.file_path' | xargs npx prettier --write"},
          {"type": "command", "command": "jq -r '.tool_input.file_path' | xargs npx eslint --fix", "async": true}
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "agent",
            "prompt": "변경된 파일의 테스트를 실행하고, 실패하면 수정 방안을 제시하세요.",
            "timeout": 180
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {"type": "command", "command": "echo '프로젝트 규칙: npm 대신 bun 사용. 모든 커밋은 Conventional Commits 형식.'"}
        ]
      }
    ]
  }
}`}
  language="json"
  filename="복합 Hook 구성 예시"
/>

<Callout type="tip" title="Best Practices">
  이 구성은 Anthropic 엔지니어링 블로그에서 권장하는 Best Practices 패턴입니다: PreToolUse로 위험 차단, PostToolUse로 자동 포맷팅, Stop으로 자동 테스트 검증.
</Callout>

<Callout type="warning" title="주의사항">
  - Hook 스크립트에 **실행 권한**(`chmod +x`)이 필요합니다
  - `exit 2`는 차단 가능한 이벤트에서만 의미가 있습니다 (PostToolUse에서는 차단 불가)
  - `async: true` 훅은 결과를 기다리지 않으므로 차단 용도로 사용할 수 없습니다
  - MCP 도구의 matcher는 `mcp__서버명__도구명` 형식을 사용합니다
</Callout>

<ChapterNav
  prev={{ title: '서브에이전트', path: '/docs/part-3--ai-agent-워크플로우-서브에이전트' }}
  next={{ title: 'MCP 개요', path: '/docs/part-4--mcp와-통합-mcp-개요' }}
/>
