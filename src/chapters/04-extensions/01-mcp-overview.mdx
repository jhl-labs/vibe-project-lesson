import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { TemplateFileViewer } from '../../components/TemplateFileViewer';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { Timeline } from '../../components/Timeline';
import { ChapterNav } from '../../components/ChapterNav';
import { templateFiles } from '../../data/template-files';

<Meta title="Part 4: 확장과 자동화/MCP 개요" />

# MCP (Model Context Protocol) 개요

> AI 에이전트의 기능을 확장하는 표준 프로토콜

## MCP란?

**MCP(Model Context Protocol)**는 Anthropic이 **2024년 11월 25일** 공개한 **개방형 표준 프로토콜**로, AI 에이전트가 외부 도구 및 서비스와 **JSON-RPC 2.0** 기반으로 양방향 통신합니다 ([Anthropic Announcement](https://www.anthropic.com/news/model-context-protocol)). 처음부터 MIT 라이선스 하에 오픈소스로 공개되었으며, 2025년 12월 9일 Anthropic은 MCP를 Linux Foundation 산하 **Agentic AI Foundation (AAIF)**에 기부하여 오픈 거버넌스로 전환했습니다 ([Linux Foundation](https://www.linuxfoundation.org/press/linux-foundation-announces-the-formation-of-the-agentic-ai-foundation)). 현재 스펙 버전은 **2025-11-25**이며, Claude Code, VS Code, Cursor, GitHub Copilot, JetBrains IDE 등 주요 AI 코딩 도구가 MCP를 지원합니다.

<Callout type="info" title="비유">
  MCP는 AI 에이전트의 "USB 포트"와 같습니다.
  다양한 도구(MCP 서버)를 꽂아서 AI의 능력을 확장할 수 있습니다.
  USB가 키보드, 마우스, 외장하드 등 다양한 장치를 하나의 표준으로 연결하듯이,
  MCP는 데이터베이스, GitHub, Slack 등 다양한 외부 시스템을 하나의 프로토콜로 연결합니다.
</Callout>

## MCP 발전 타임라인

MCP는 2024년 말 공개 이후 빠르게 발전하며 업계 표준으로 자리잡아 가고 있습니다.

<Timeline
  title="MCP 발전 로드맵"
  events={[
    {
      date: '2024-11-25',
      title: 'MCP 최초 공개',
      description: 'Anthropic이 MCP를 MIT 라이선스로 오픈소스 공개. 초기 스펙과 레퍼런스 서버 제공.',
      highlight: true,
    },
    {
      date: '2025-03-26',
      title: 'Streamable HTTP 전송 도입',
      description: 'SSE를 대체하는 Streamable HTTP 전송 방식 추가. 원격 서버 연결이 더 간편해짐.',
    },
    {
      date: '2025-03-26',
      title: 'OAuth 2.1 인증 도입',
      description: '2025-03-26 스펙에서 MCP 서버의 인증 흐름에 OAuth 2.1이 도입됨. 2025-06-18 스펙에서 대폭 개선.',
    },
    {
      date: '2025-06',
      title: 'Elicitation 기능 추가',
      description: 'MCP 서버가 실행 중 사용자에게 추가 정보를 요청할 수 있는 elicitation 기능 도입.',
    },
    {
      date: '2025-09',
      title: 'MCP Registry 프리뷰 출시',
      description: '공식 MCP 서버 레지스트리가 프리뷰로 출시. 검증된 서버를 쉽게 발견하고 설치 가능.',
    },
    {
      date: '2025-11-25',
      title: '스펙 버전 2025-11-25 릴리스',
      description: '최신 스펙 버전. 비동기 Tasks, 향상된 OAuth(CIMD), Extensions 프레임워크, URL 모드 Elicitation 포함.',
      highlight: true,
    },
    {
      date: '2025-12-09',
      title: 'AAIF 기부 (Linux Foundation)',
      description: 'Anthropic이 MCP를 Agentic AI Foundation에 기부. OpenAI, Google, Microsoft 등 참여.',
      highlight: true,
    },
  ]}
/>

---

## JSON-RPC 2.0 프로토콜 아키텍처

MCP는 **JSON-RPC 2.0** 프로토콜 위에 구축되어 있습니다. 이는 가볍고 표준화된 원격 프로시저 호출(RPC) 프로토콜로, 요청-응답 패턴과 알림(notification) 패턴을 모두 지원합니다.

### 메시지 구조

MCP의 모든 통신은 JSON-RPC 2.0 메시지 형식을 따릅니다. 세 가지 메시지 유형이 있습니다.

<CodeBlock
  code={`// 1. 요청 (Request) — 클라이언트 → 서버 또는 서버 → 클라이언트
{
  "jsonrpc": "2.0",
  "id": 1,                          // 요청 식별자 (응답과 매칭)
  "method": "tools/call",           // 호출할 메서드
  "params": {                       // 메서드 파라미터
    "name": "read_file",
    "arguments": {
      "path": "/src/index.ts"
    }
  }
}

// 2. 응답 (Response) — 요청에 대한 결과
{
  "jsonrpc": "2.0",
  "id": 1,                          // 요청의 id와 동일
  "result": {                       // 성공 시 result
    "content": [
      {
        "type": "text",
        "text": "// index.ts 파일 내용..."
      }
    ]
  }
}

// 3. 에러 응답 (Error Response) — 실패 시
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,                  // JSON-RPC 표준 에러 코드
    "message": "Invalid params",
    "data": "File not found: /src/missing.ts"
  }
}

// 4. 알림 (Notification) — 응답을 기대하지 않는 일방향 메시지
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100
  }
}`}
  language="json"
  filename="JSON-RPC 2.0 메시지 구조"
/>

### 연결 수명주기

MCP 클라이언트와 서버 간의 연결은 초기화(initialize), 작업(operation), 종료(shutdown) 3단계로 이루어집니다.

<MermaidDiagram
  chart={`sequenceDiagram
    participant C as MCP Client
    participant S as MCP Server
    Note over C,S: 1. 초기화 단계
    C->>S: initialize (프로토콜 버전, 클라이언트 정보)
    S-->>C: initialize 응답 (서버 정보, 지원 기능)
    C->>S: notifications/initialized
    Note over C,S: 2. 기능 탐색 단계
    C->>S: tools/list
    S-->>C: 사용 가능한 도구 목록
    C->>S: resources/list
    S-->>C: 사용 가능한 리소스 목록
    C->>S: prompts/list
    S-->>C: 사용 가능한 프롬프트 목록
    Note over C,S: 3. 작업 단계 (반복)
    C->>S: tools/call (도구 실행 요청)
    S-->>C: 도구 실행 결과
    C->>S: resources/read (리소스 읽기)
    S-->>C: 리소스 데이터
    Note over C,S: 4. 종료
    C->>S: shutdown
    S-->>C: 종료 확인`}
  title="MCP 연결 수명주기"
  caption="클라이언트와 서버가 초기화, 기능 탐색, 작업 수행, 종료 단계를 거칩니다"
/>

### Capability Negotiation (기능 협상)

초기화 단계에서 클라이언트와 서버는 서로 지원하는 기능(capabilities)을 교환합니다. 이를 통해 양쪽이 상대방이 지원하는 기능만 사용하도록 보장합니다.

<CodeBlock
  code={`// 클라이언트가 보내는 initialize 요청
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "roots": { "listChanged": true },      // 루트 디렉토리 변경 알림 지원
      "sampling": {},                          // 샘플링(모델 호출) 지원
      "elicitation": {}                        // 사용자에게 추가 정보 요청 지원
    },
    "clientInfo": {
      "name": "claude-code",
      "version": "1.0.0"
    }
  }
}

// 서버의 initialize 응답
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "tools": { "listChanged": true },        // 도구 목록 제공 + 변경 알림 지원
      "resources": { "subscribe": true },       // 리소스 제공 + 구독 지원
      "prompts": { "listChanged": true },       // 프롬프트 제공 + 변경 알림 지원
      "logging": {}                             // 로깅 지원
    },
    "serverInfo": {
      "name": "github-mcp-server",
      "version": "2.0.0"
    }
  }
}`}
  language="json"
  filename="Capability Negotiation 예시"
/>

---

## 핵심 기능 (Primitives) 상세

MCP는 단순히 "도구 호출"만 지원하는 것이 아닙니다. 세 가지 핵심 기능을 제공합니다:

<ComparisonTable
  title="MCP 핵심 기능"
  headers={['기능', '방향', '설명', '예시']}
  rows={[
    { feature: 'Resources', values: ['서버 → 클라이언트', 'AI 컨텍스트에 데이터를 주입', '파일 내용, DB 스키마, 설정 문서'] },
    { feature: 'Tools', values: ['클라이언트 → 서버', 'AI가 외부 시스템에서 액션을 실행', 'Git 커밋, API 호출, 쿼리 실행'] },
    { feature: 'Prompts', values: ['서버 → 클라이언트', '재사용 가능한 프롬프트 템플릿 제공', '코드 리뷰 프롬프트, SQL 생성 프롬프트'] },
  ]}
/>

### Tools (도구)

Tools는 MCP에서 가장 핵심적인 기능입니다. AI 모델이 외부 시스템에서 **액션을 실행**할 수 있게 해주며, 함수 호출(Function Calling)과 유사한 개념입니다. 각 도구는 이름, 설명, 입력 스키마(JSON Schema)를 가지며, AI가 자율적으로 어떤 도구를 사용할지 결정합니다.

<CodeBlock
  code={`// tools/list 응답 — 서버가 제공하는 도구 목록
{
  "tools": [
    {
      "name": "create_issue",
      "description": "GitHub 저장소에 새 이슈를 생성합니다",
      "inputSchema": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "description": "저장소 소유자 (사용자 또는 조직명)"
          },
          "repo": {
            "type": "string",
            "description": "저장소 이름"
          },
          "title": {
            "type": "string",
            "description": "이슈 제목"
          },
          "body": {
            "type": "string",
            "description": "이슈 본문 (마크다운 지원)"
          },
          "labels": {
            "type": "array",
            "items": { "type": "string" },
            "description": "이슈에 추가할 라벨 목록"
          }
        },
        "required": ["owner", "repo", "title"]
      }
    }
  ]
}

// tools/call 요청 — AI가 도구를 실행
{
  "method": "tools/call",
  "params": {
    "name": "create_issue",
    "arguments": {
      "owner": "my-org",
      "repo": "my-project",
      "title": "로그인 페이지 500 에러 수정",
      "body": "## 증상\\n로그인 시 500 에러 발생...",
      "labels": ["bug", "P1"]
    }
  }
}

// tools/call 응답 — 도구 실행 결과
{
  "content": [
    {
      "type": "text",
      "text": "이슈 #142가 성공적으로 생성되었습니다."
    }
  ],
  "isError": false
}`}
  language="json"
  filename="Tools 정의 및 호출 예시"
/>

<Callout type="tip" title="도구 설계 팁">
  좋은 MCP 도구는 명확한 이름, 상세한 설명, 정확한 JSON Schema를 가집니다.
  AI 모델은 도구의 이름과 설명을 보고 어떤 도구를 사용할지 결정하므로,
  설명이 모호하면 잘못된 도구를 선택하거나 올바른 도구를 놓칠 수 있습니다.
</Callout>

### Resources (리소스)

Resources는 MCP 서버가 AI의 컨텍스트에 **데이터를 주입**하는 메커니즘입니다. 파일 내용, 데이터베이스 스키마, API 응답 등 읽기 전용 데이터를 AI가 참조할 수 있게 해줍니다. 리소스는 URI로 식별되며, 정적(static) 리소스와 동적(dynamic) 리소스 템플릿이 있습니다.

<CodeBlock
  code={`// resources/list 응답 — 서버가 제공하는 리소스 목록
{
  "resources": [
    {
      "uri": "file:///project/src/schema.prisma",
      "name": "Prisma 스키마",
      "description": "프로젝트의 데이터베이스 스키마 정의",
      "mimeType": "text/plain"
    },
    {
      "uri": "db://main/tables",
      "name": "데이터베이스 테이블 목록",
      "description": "메인 데이터베이스의 모든 테이블과 컬럼 정보",
      "mimeType": "application/json"
    }
  ],
  // 동적 리소스 템플릿 — URI 파라미터로 다양한 리소스 접근
  "resourceTemplates": [
    {
      "uriTemplate": "db://main/tables/{tableName}/schema",
      "name": "테이블 스키마",
      "description": "특정 테이블의 상세 스키마 정보"
    }
  ]
}

// resources/read 요청 — 리소스 읽기
{
  "method": "resources/read",
  "params": {
    "uri": "db://main/tables"
  }
}

// resources/read 응답
{
  "contents": [
    {
      "uri": "db://main/tables",
      "mimeType": "application/json",
      "text": "[{\\"name\\":\\"users\\",\\"columns\\":[\\"id\\",\\"email\\",\\"name\\"]}]"
    }
  ]
}`}
  language="json"
  filename="Resources 정의 및 읽기 예시"
/>

### Prompts (프롬프트)

Prompts는 MCP 서버가 제공하는 **재사용 가능한 프롬프트 템플릿**입니다. 사용자가 슬래시 명령어(/)처럼 선택할 수 있으며, 매개변수를 받아 맞춤형 프롬프트를 생성합니다. 반복적인 작업에 일관된 프롬프트를 제공하는 데 유용합니다.

<CodeBlock
  code={`// prompts/list 응답 — 서버가 제공하는 프롬프트 목록
{
  "prompts": [
    {
      "name": "code-review",
      "description": "코드 변경사항에 대한 체계적인 리뷰를 수행합니다",
      "arguments": [
        {
          "name": "language",
          "description": "프로그래밍 언어",
          "required": true
        },
        {
          "name": "focus",
          "description": "리뷰 중점 영역 (security, performance, readability)",
          "required": false
        }
      ]
    },
    {
      "name": "sql-query",
      "description": "자연어 설명을 SQL 쿼리로 변환합니다",
      "arguments": [
        {
          "name": "description",
          "description": "쿼리하고 싶은 내용을 자연어로 설명",
          "required": true
        }
      ]
    }
  ]
}

// prompts/get 요청 — 프롬프트 내용 가져오기
{
  "method": "prompts/get",
  "params": {
    "name": "code-review",
    "arguments": {
      "language": "TypeScript",
      "focus": "security"
    }
  }
}

// prompts/get 응답 — 생성된 프롬프트 메시지
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "다음 TypeScript 코드를 보안 관점에서 리뷰해주세요.\\n\\n주요 확인 사항:\\n- SQL 인젝션 취약점\\n- XSS 가능성\\n- 인증/인가 로직 검증\\n- 민감 데이터 노출 여부"
      }
    }
  ]
}`}
  language="json"
  filename="Prompts 정의 및 사용 예시"
/>

### 세 가지 기능의 관계

<MermaidDiagram
  chart={`flowchart TB
    subgraph SERVER["MCP Server"]
      R["Resources\n(데이터 제공)"]
      T["Tools\n(액션 실행)"]
      P["Prompts\n(템플릿 제공)"]
    end
    subgraph CLIENT["MCP Client (Claude Code)"]
      CTX["컨텍스트\n(AI가 참조하는 정보)"]
      ACT["액션 실행\n(AI가 수행하는 작업)"]
      UI["사용자 인터페이스\n(슬래시 명령 등)"]
    end
    R -->|"데이터 주입"| CTX
    T -->|"함수 호출"| ACT
    P -->|"프롬프트 생성"| UI
    CTX -->|"정보 참조"| ACT
    UI -->|"작업 시작"| ACT
    style SERVER fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style CLIENT fill:#f0ece5,stroke:#8c857c,color:#2d2a26`}
  title="MCP 핵심 기능 간 관계"
  caption="Resources는 컨텍스트를 제공하고, Tools는 액션을 실행하며, Prompts는 사용자 인터페이스를 확장합니다"
/>

---

## 아키텍처

<MermaidDiagram
  chart={`flowchart LR
    CC["Claude Code\n(MCP Client)"]
    FS["Filesystem\nServer"]
    GIT["Git\nServer"]
    GH["GitHub\nServer"]
    DB["Database\nServer"]
    FE["Fetch\nServer"]
    CC <-->|MCP Protocol| FS
    CC <-->|MCP Protocol| GIT
    CC <-->|MCP Protocol| GH
    CC <-->|MCP Protocol| DB
    CC <-->|MCP Protocol| FE
    style CC fill:#da7756,stroke:#c4613e,color:#fff
    style FS fill:#fdf2ee,stroke:#16a34a,color:#2d2a26
    style GIT fill:#fdf2ee,stroke:#16a34a,color:#2d2a26
    style GH fill:#fdf2ee,stroke:#d97706,color:#2d2a26
    style DB fill:#fdf2ee,stroke:#dc2626,color:#2d2a26
    style FE fill:#fdf2ee,stroke:#2563eb,color:#2d2a26`}
  title="MCP 아키텍처"
  caption="Claude Code가 MCP 프로토콜을 통해 다양한 외부 도구 서버와 양방향 통신합니다"
/>

<MermaidDiagram
  chart={`sequenceDiagram
    participant U as 사용자
    participant CC as Claude Code
    participant MCP as MCP Server
    participant EXT as 외부 시스템
    U->>CC: 작업 요청
    CC->>CC: 컨텍스트 분석
    CC->>MCP: Tool 호출 (JSON-RPC)
    MCP->>EXT: API 호출 / 명령 실행
    EXT-->>MCP: 결과 반환
    MCP-->>CC: Tool 결과 (JSON-RPC)
    CC->>CC: 결과 기반 추론
    CC-->>U: 응답 (코드/설명)`}
  title="MCP 통신 흐름"
  caption="사용자 요청 -> Claude Code 분석 -> MCP 서버 호출 -> 외부 시스템 작업 -> 결과 반환"
/>

### 전송 방식 (Transport)

MCP 서버와 클라이언트가 통신하는 방식에는 크게 두 가지가 있습니다.

<ComparisonTable
  title="MCP 전송 방식 비교"
  headers={['방식', '통신 방법', '용도', '상태']}
  rows={[
    { feature: 'stdio', values: ['표준 입출력 (stdin/stdout)', '로컬 프로세스, CLI 도구', '활성'] },
    { feature: 'Streamable HTTP', values: ['단일 HTTP 엔드포인트', '원격 서버, 클라우드 서비스', '활성 (권장)'] },
    { feature: 'SSE (레거시)', values: ['Server-Sent Events', '원격 서버 (구버전)', '사용 중단됨'] },
  ]}
/>

**stdio 전송**: 서버가 로컬 프로세스로 실행되며, 표준 입출력(stdin/stdout)을 통해 JSON-RPC 메시지를 교환합니다. `npx`, `python`, `node` 등으로 실행되는 로컬 서버에 사용됩니다.

**Streamable HTTP 전송**: 서버가 원격에서 호스팅되며, 단일 HTTP 엔드포인트를 통해 통신합니다. SaaS 서비스가 제공하는 MCP 서버에 주로 사용되며, OAuth 인증이 자연스럽게 통합됩니다.

<Callout type="warning" title="SSE는 사용 중단됨">
  SSE(Server-Sent Events) 전송 방식은 2025-03-26 MCP 스펙부터 Streamable HTTP로 대체되었습니다.
  기존 SSE 서버는 하위 호환성을 위해 동작하지만, 새 서버를 개발할 때는 반드시 Streamable HTTP를 사용하세요.
</Callout>

---

## .mcp.json 설정

MCP 서버 설정은 프로젝트 루트의 `.mcp.json` 파일에서 관리합니다.

<TemplateFileViewer
  filename=".mcp.json.example"
  content={templateFiles['.mcp.json.example']}
  language="json"
  annotations={[
    { lineStart: 1, lineEnd: 2, text: '설정 파일은 .mcp.json.example로 제공됩니다. 실제 사용 시 .mcp.json으로 복사하고 프로젝트에 맞게 수정합니다.' },
    { lineStart: 3, lineEnd: 9, text: 'Filesystem MCP 서버입니다. 프로젝트 디렉토리 내 파일을 읽고 쓸 수 있게 합니다.' },
    { lineStart: 10, lineEnd: 14, text: 'Git MCP 서버입니다. 커밋, 브랜치, 히스토리 등 Git 작업을 수행합니다.' },
    { lineStart: 15, lineEnd: 23, text: 'GitHub MCP 서버(stdio)입니다. 현재는 HTTP 방식(https://api.githubcopilot.com/mcp/)이 권장됩니다. stdio 패키지는 archived 상태입니다.' },
    { lineStart: 24, lineEnd: 32, text: 'PostgreSQL MCP 서버입니다. 이 패키지는 archived 상태이며, @bytebase/dbhub 사용을 권장합니다. disabled: true로 기본 비활성화되어 있습니다.' },
    { lineStart: 40, lineEnd: 45, text: 'Fetch MCP 서버입니다. 외부 API 호출이나 웹 콘텐츠를 가져올 수 있습니다.' },
  ]}
/>

---

## 인기 MCP 서버와 활용 사례

### 공식 레퍼런스 서버

| 서버 | 용도 | 필수 환경 변수 |
|------|------|---------------|
| **filesystem** | 파일 읽기/쓰기 | 없음 |
| **git** | Git 작업 | 없음 |
| **github** | GitHub API (PR, 이슈) | OAuth (HTTP) |
| **fetch** | HTTP 요청 | 없음 |
| **memory** | 세션 간 지식 유지 | 없음 |
| **sequential-thinking** | 체계적 추론 | 없음 |

<Callout type="info" title="Archived 서버와 대안">
  postgres, sqlite, puppeteer, slack 등 일부 레퍼런스 서버는 `modelcontextprotocol/servers-archived`로 이동되어 더 이상 유지보수되지 않습니다.
  DB 연동은 **DBHub**(`@bytebase/dbhub`), GitHub는 **HTTP 방식**(`https://api.githubcopilot.com/mcp/`), Slack은 커뮤니티 서버 사용을 권장합니다.
</Callout>

### 서버별 활용 사례 상세

**filesystem** -- 프로젝트 외부의 디렉토리에 안전하게 접근합니다. 허용 디렉토리를 인자로 명시하여 접근 범위를 제한합니다.

<CodeBlock
  code={`# 설치 및 설정
claude mcp add --transport stdio files -- \\
  npx -y @modelcontextprotocol/server-filesystem \\
  /path/to/docs /path/to/config

# 활용 예시
# "docs 디렉토리의 API 명세서를 읽어서 TypeScript 인터페이스를 생성해줘"
# "config 디렉토리의 설정 파일들을 분석해서 환경별 차이점을 정리해줘"`}
  language="bash"
  filename="Filesystem 서버"
/>

**github** -- GitHub의 이슈, PR, 코드 검색, 리포지토리 관리 등 전체 API에 접근합니다.

<CodeBlock
  code={`# HTTP 전송 방식 (OAuth 자동 인증, 권장)
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# 활용 예시
# "이 프로젝트의 열린 이슈 중 bug 라벨이 붙은 것을 보여줘"
# "최근 머지된 PR 5개의 변경사항을 요약해줘"
# "이 버그에 대한 이슈를 생성하고 P1 라벨을 붙여줘"`}
  language="bash"
  filename="GitHub 서버"
/>

**postgres / sqlite** -- 데이터베이스에 직접 쿼리를 실행합니다. 스키마를 분석하고, 데이터를 조회하며, 이를 기반으로 코드를 생성할 수 있습니다.

<CodeBlock
  code={`# PostgreSQL (DBHub 사용 권장)
claude mcp add --transport stdio db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "postgresql://readonly:pass@localhost:5432/mydb"

# SQLite
claude mcp add --transport stdio sqlite -- \\
  npx -y @modelcontextprotocol/server-sqlite \\
  --db-path ./data/app.sqlite

# 활용 예시
# "users 테이블의 스키마를 확인하고 TypeORM 엔티티를 생성해줘"
# "지난 7일간 가입한 사용자 수를 일별로 조회해줘"
# "주문 테이블과 상품 테이블의 관계를 분석해줘"`}
  language="bash"
  filename="Database 서버"
/>

**slack** -- Slack 워크스페이스와 연동하여 메시지 전송, 채널 관리, 대화 검색 등을 수행합니다. (`@modelcontextprotocol/server-slack`은 현재 archived 상태이며, 커뮤니티 서버를 사용할 수도 있습니다.)

<CodeBlock
  code={`# Slack MCP 서버 설정 (환경 변수 필요)
claude mcp add --transport stdio \\
  --env SLACK_BOT_TOKEN=xoxb-your-token \\
  --env SLACK_TEAM_ID=T0123456789 \\
  slack -- npx -y @modelcontextprotocol/server-slack

# 활용 예시
# "배포 완료 알림을 #deployments 채널에 보내줘"
# "#bugs 채널에서 최근 논의된 이슈를 요약해줘"
# "팀원에게 코드 리뷰 요청 DM을 보내줘"`}
  language="bash"
  filename="Slack 서버"
/>

**memory** -- 세션 간 정보를 유지하는 지식 그래프 기반 영속 메모리입니다.

<CodeBlock
  code={`# Memory 서버 설정
claude mcp add --transport stdio memory -- \\
  npx -y @modelcontextprotocol/server-memory

# 활용 예시 (세션 1)
# "이 프로젝트의 아키텍처 결정사항과 주요 패턴을 Memory에 저장해줘"

# 활용 예시 (세션 2 - 나중에)
# "Memory에서 이전에 저장한 아키텍처 정보를 불러와줘.
#  새 모듈을 추가할 때 기존 패턴과 일관성을 유지하고 싶어"`}
  language="bash"
  filename="Memory 서버"
/>

---

## MCP 서버 발견과 설치

### Tool Search를 통한 자동 발견

Claude Code에서 MCP 서버를 설치하는 가장 쉬운 방법은 **Tool Search**를 활용하는 것입니다. 필요한 기능을 자연어로 설명하면 Claude Code가 적합한 MCP 서버를 찾아 설치를 안내합니다.

### MCP Registry

2025년 9월에 출시된 공식 MCP Registry ([registry.modelcontextprotocol.io](https://registry.modelcontextprotocol.io/))는 검증된 MCP 서버를 발견하고 설치하는 중앙 허브입니다.

<CodeBlock
  code={`# MCP Registry에서 서버 검색
# 웹: https://registry.modelcontextprotocol.io/

# CLI로 서버 추가 (레지스트리에서 제공하는 명령어 사용)
# npx 기반 서버
claude mcp add --transport stdio <name> -- npx -y <package-name>

# Docker 기반 서버
claude mcp add --transport stdio <name> -- \\
  docker run -i --rm <image-name>

# HTTP 기반 서버 (원격)
claude mcp add --transport http <name> <url>`}
  language="bash"
  filename="MCP 서버 설치 방법"
/>

### 설치 방법별 비교

<ComparisonTable
  title="MCP 서버 설치 방법 비교"
  headers={['방법', '장점', '단점', '적합한 상황']}
  rows={[
    { feature: 'npx', values: ['설치 불필요, 항상 최신 버전', '첫 실행 시 다운로드 시간', '빠른 시작, 개발 환경'] },
    { feature: 'npm install -g', values: ['빠른 실행 (사전 설치)', '수동 업데이트 필요', '자주 사용하는 서버'] },
    { feature: 'Docker', values: ['격리된 환경, 의존성 충돌 없음', '이미지 크기, Docker 필요', '프로덕션, 보안 중요'] },
    { feature: 'HTTP (원격)', values: ['설치 불필요, 서비스 제공자 관리', '네트워크 의존, 지연시간', 'SaaS 서비스 연동'] },
  ]}
/>

---

## Tool Search Tool -- 토큰 85% 절감 (2025년 하반기~)

MCP 서버가 50개 이상의 도구를 노출할 수 있고, 사용자가 7개 이상의 서버를 동시에 실행하면 67,000+ 토큰이 도구 정의에만 소비됩니다. **Tool Search Tool**은 이 문제를 해결합니다.

### 작동 방식

도구 설명이 사용 가능한 컨텍스트의 10%를 초과하면 자동으로 **검색 인덱스 모드**로 전환합니다:

<CodeBlock
  code={`[기존 방식] 모든 도구 정의 미리 로드
→ 134,000 토큰 소비, 정확도 49% (Opus 4)

[Tool Search] 필요한 도구만 동적 검색
→ ~5,000 토큰 소비, 정확도 74% (Opus 4)
→ 토큰 85% 감소 + 정확도 +25%p 향상`}
  language="text"
  filename="Tool Search 성능 비교"
/>

### 성능 개선 데이터

<ComparisonTable
  title="Tool Search 사용 전후 비교"
  headers={['모델', 'Tool Search 미사용', 'Tool Search 사용', '정확도 향상']}
  rows={[
    { model: 'Opus 4', values: ['49%', '74%', '+25%p'] },
    { model: 'Opus 4.5', values: ['79.5%', '88.1%', '+8.6%p'] },
  ]}
/>

<Callout type="info" title="자동 활성화">
  Tool Search는 Claude Code에서 자동으로 활성화됩니다. MCP 서버가 많아질수록 효과가 커지며, API에서는 defer_loading 옵션으로 도구별 지연 로딩을 설정할 수 있습니다.
</Callout>

### 코드 실행 샌드박스

Anthropic은 MCP 서버의 코드 실행을 안전하게 격리하기 위한 **sandbox-runtime**을 오픈소스로 공개했습니다.

<CodeBlock
  code={`# 네이티브 OS 샌드박싱 사용
# macOS: sandbox-exec, Linux: bubblewrap
# 컨테이너 없이 파일 시스템 및 네트워크 접근 제어

# 오픈소스: github.com/anthropic-experimental/sandbox-runtime`}
  language="bash"
  filename="Sandbox Runtime"
/>

---

## MCP 보안 모델

MCP는 외부 시스템에 대한 접근 권한을 부여하므로, 보안이 핵심 설계 원칙 중 하나입니다.

<Callout type="warning" title="MCP 보안 주의사항">
  MCP 서버는 외부 시스템에 접근 권한을 부여하므로 보안에 주의해야 합니다.
  신뢰할 수 없는 MCP 서버는 사용자 데이터를 유출하거나 시스템을 손상시킬 수 있습니다.
</Callout>

### 승인 프로세스

Claude Code는 MCP 도구가 호출될 때 사용자에게 **명시적 승인**을 요청합니다. 이 승인 체계는 여러 단계로 구성됩니다.

<MermaidDiagram
  chart={`flowchart TD
    REQ["AI가 MCP 도구 호출 요청"] --> CHECK{"사전 승인된\n도구인가?"}
    CHECK -->|"예"| EXEC["도구 실행"]
    CHECK -->|"아니오"| ASK["사용자에게 승인 요청"]
    ASK --> CHOICE{"사용자 선택"}
    CHOICE -->|"이번만 허용"| EXEC
    CHOICE -->|"항상 허용"| SAVE["승인 기록 저장"] --> EXEC
    CHOICE -->|"거부"| DENY["도구 실행 차단"]
    EXEC --> RESULT["결과 반환"]
    style REQ fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style CHECK fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style ASK fill:#fff3e0,stroke:#d97706,color:#2d2a26
    style EXEC fill:#e8f5e9,stroke:#16a34a,color:#2d2a26
    style DENY fill:#ffebee,stroke:#dc2626,color:#2d2a26
    style SAVE fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26
    style CHOICE fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style RESULT fill:#f0ece5,stroke:#8c857c,color:#2d2a26`}
  title="MCP 도구 승인 흐름"
  caption="AI가 도구를 호출하면 사전 승인 여부를 확인하고, 미승인 도구는 사용자에게 승인을 요청합니다"
/>

### 보안 계층

<ComparisonTable
  title="MCP 보안 계층"
  headers={['계층', '보호 대상', '메커니즘', '설정 방법']}
  rows={[
    { feature: '도구 승인', values: ['개별 도구 실행', '사용자 명시적 승인', '실행 시 프롬프트'] },
    { feature: '프로젝트 승인', values: ['.mcp.json 서버', '프로젝트별 서버 승인', '최초 실행 시 확인'] },
    { feature: '샌드박스 격리', values: ['코드 실행 환경', 'OS 수준 샌드박싱', 'sandbox-runtime'] },
    { feature: '환경 변수', values: ['인증 정보', '코드에 시크릿 미노출', '${VAR} 참조'] },
    { feature: 'Managed Settings', values: ['조직 정책', '허용/차단 서버 목록', 'allowedMcpServers'] },
    { feature: '최소 권한', values: ['접근 범위', '읽기 전용, 디렉토리 제한', '서버 인자로 설정'] },
  ]}
/>

### 보안 필수 수칙

1. **환경 변수로 시크릿 관리**: 토큰/키를 .mcp.json에 직접 작성하지 마세요
2. **최소 권한 원칙**: 필요한 서버만 활성화하세요 (`disabled: true` 활용)
3. **.mcp.json은 .gitignore에 추가**: 실제 설정 파일은 Git에 커밋하지 마세요
4. **DB 접근 제한**: 프로덕션 DB에 직접 연결하지 마세요
5. **읽기 전용 우선**: 가능하면 읽기 전용 권한만 부여하세요
6. **서드파티 서버 검증**: 소스 코드를 확인하고 어떤 데이터에 접근하는지 파악 후 사용하세요

<CodeBlock
  code={`# .gitignore에 추가
.mcp.json

# .mcp.json.example은 커밋 (템플릿으로 제공)
!.mcp.json.example`}
  language="bash"
  filename=".gitignore 설정"
/>

---

## MCP vs REST API vs GraphQL

MCP가 기존의 API 통합 방식과 어떻게 다른지 비교합니다.

<ComparisonTable
  title="MCP vs REST API vs GraphQL 비교"
  headers={['항목', 'MCP', 'REST API', 'GraphQL']}
  rows={[
    { feature: '주요 목적', values: ['AI 에이전트-도구 통신', '클라이언트-서버 데이터 교환', '유연한 데이터 쿼리'] },
    { feature: '프로토콜', values: ['JSON-RPC 2.0', 'HTTP (GET/POST/PUT/DELETE)', 'HTTP (POST)'] },
    { feature: '기능 탐색', values: ['자동 (tools/list, resources/list)', '별도 문서 필요 (OpenAPI 등)', '내장 (Introspection)'] },
    { feature: '양방향 통신', values: ['지원 (알림, 진행 상황)', '미지원 (폴링 필요)', '미지원 (Subscription으로 부분 지원)'] },
    { feature: 'AI 최적화', values: ['네이티브 (AI가 도구 선택)', '추가 통합 필요', '추가 통합 필요'] },
    { feature: '인증', values: ['OAuth 2.1, 환경 변수', '다양 (API Key, OAuth 등)', '다양 (토큰, 세션)'] },
    { feature: '타입 시스템', values: ['JSON Schema', '별도 정의 필요', '내장 (SDL)'] },
    { feature: '스트리밍', values: ['Streamable HTTP', 'SSE, WebSocket 별도', 'Subscription'] },
    { feature: '상태 관리', values: ['세션 기반 (상태 유지)', '무상태 (Stateless)', '무상태'] },
    { feature: '사용 사례', values: ['AI 에이전트 도구 통합', '범용 웹 API', '프론트엔드 데이터 쿼리'] },
  ]}
/>

<Callout type="info" title="MCP는 API를 대체하지 않습니다">
  MCP는 기존 REST API나 GraphQL을 대체하는 것이 아닙니다.
  MCP 서버 내부에서 REST API나 GraphQL을 호출하여 외부 시스템과 통신합니다.
  MCP는 AI 에이전트와 도구 사이의 "표준 인터페이스 계층"으로, 기존 API 위에 AI 친화적인 추상화를 제공합니다.
</Callout>

---

## 커스텀 MCP 서버 개발 가이드

프로젝트에 특화된 도구가 필요할 때 직접 MCP 서버를 개발할 수 있습니다. Anthropic은 TypeScript와 Python용 공식 SDK를 제공합니다.

### TypeScript SDK로 MCP 서버 개발

<CodeBlock
  code={`// 1. 프로젝트 초기화
// npm init -y
// npm install @modelcontextprotocol/sdk zod

// 2. 서버 구현 (src/server.ts)
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// MCP 서버 인스턴스 생성
const server = new McpServer({
  name: "my-custom-server",
  version: "1.0.0",
});

// Tool 정의 — AI가 호출할 수 있는 함수
server.tool(
  "search_codebase",                          // 도구 이름
  "코드베이스에서 특정 패턴을 검색합니다",       // 설명 (AI가 참조)
  {
    pattern: z.string().describe("검색할 정규식 패턴"),
    fileType: z.string().optional().describe("파일 확장자 필터 (예: .ts, .py)"),
    maxResults: z.number().default(10).describe("최대 결과 수"),
  },
  async ({ pattern, fileType, maxResults }) => {
    // 실제 검색 로직 구현
    const results = await performSearch(pattern, fileType, maxResults);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(results, null, 2),
        },
      ],
    };
  }
);

// Resource 정의 — AI 컨텍스트에 데이터 주입
server.resource(
  "project-config",                            // 리소스 이름
  "config://project",                          // URI
  async (uri) => ({
    contents: [
      {
        uri: uri.href,
        mimeType: "application/json",
        text: JSON.stringify(await loadProjectConfig()),
      },
    ],
  })
);

// Prompt 정의 — 재사용 가능한 프롬프트 템플릿
server.prompt(
  "analyze-module",
  { modulePath: z.string().describe("분석할 모듈 경로") },
  ({ modulePath }) => ({
    messages: [
      {
        role: "user",
        content: {
          type: "text",
          text: \`다음 모듈을 분석해주세요: \${modulePath}

1. 의존성 관계를 파악하세요
2. 잠재적인 순환 의존성을 찾으세요
3. 리팩토링 제안을 해주세요\`,
        },
      },
    ],
  })
);

// 서버 시작
const transport = new StdioServerTransport();
await server.connect(transport);`}
  language="typescript"
  filename="TypeScript MCP 서버 구현"
/>

### Python SDK로 MCP 서버 개발

<CodeBlock
  code={`# 1. 프로젝트 초기화
# pip install mcp

# 2. 서버 구현 (server.py)
from mcp.server.fastmcp import FastMCP

# MCP 서버 인스턴스 생성
mcp = FastMCP("my-python-server")

# Tool 정의
@mcp.tool()
async def query_database(
    sql: str,
    database: str = "main"
) -> str:
    """데이터베이스에 SQL 쿼리를 실행합니다.

    Args:
        sql: 실행할 SQL 쿼리 (SELECT만 허용)
        database: 대상 데이터베이스 이름
    """
    if not sql.strip().upper().startswith("SELECT"):
        return "보안상 SELECT 쿼리만 허용됩니다."

    result = await execute_query(database, sql)
    return format_results(result)

# Resource 정의
@mcp.resource("schema://tables")
async def get_table_schema() -> str:
    """모든 테이블의 스키마 정보를 반환합니다."""
    schemas = await load_all_schemas()
    return json.dumps(schemas, indent=2, ensure_ascii=False)

# Dynamic Resource Template
@mcp.resource("schema://tables/{table_name}")
async def get_specific_table(table_name: str) -> str:
    """특정 테이블의 상세 스키마를 반환합니다."""
    schema = await load_table_schema(table_name)
    return json.dumps(schema, indent=2, ensure_ascii=False)

# Prompt 정의
@mcp.prompt()
async def optimize_query(slow_query: str) -> str:
    """느린 SQL 쿼리를 최적화하는 프롬프트를 생성합니다."""
    return f"""다음 SQL 쿼리를 분석하고 최적화해주세요:

\`\`\`sql
{slow_query}
\`\`\`

확인 사항:
1. 인덱스 활용 여부
2. 불필요한 JOIN 제거
3. 서브쿼리 최적화
4. EXPLAIN ANALYZE 결과 해석"""

# 서버 실행
if __name__ == "__main__":
    mcp.run()`}
  language="python"
  filename="Python MCP 서버 구현"
/>

### 커스텀 서버 등록

개발한 MCP 서버를 Claude Code에 등록합니다.

<CodeBlock
  code={`# TypeScript 서버 등록 (로컬 개발)
claude mcp add --transport stdio my-server -- \\
  npx ts-node /path/to/src/server.ts

# Python 서버 등록
claude mcp add --transport stdio my-python-server -- \\
  python /path/to/server.py

# 팀 공유를 위해 .mcp.json에 추가
{
  "mcpServers": {
    "my-server": {
      "command": "npx",
      "args": ["ts-node", "./tools/mcp-server/src/server.ts"]
    }
  }
}`}
  language="bash"
  filename="커스텀 MCP 서버 등록"
/>

<Callout type="tip" title="커스텀 서버 개발 팁">
  커스텀 MCP 서버를 개발할 때는 공식 레퍼런스 서버(modelcontextprotocol/servers)의 코드를 참고하세요.
  특히 에러 처리, 입력 검증, 타임아웃 처리에 대한 모범 사례를 확인할 수 있습니다.
  도구 설명은 AI가 이해할 수 있도록 명확하고 구체적으로 작성하는 것이 중요합니다.
</Callout>

---

## Agentic AI Foundation (AAIF)

2025년 12월 9일, Anthropic은 MCP를 Linux Foundation 산하 **Agentic AI Foundation**에 기부했습니다. 이는 MCP가 특정 기업에 종속되지 않는 중립적인 업계 표준으로 성장하기 위한 중요한 이정표입니다.

<ComparisonTable
  title="MCP 거버넌스 변화"
  headers={['항목', '이전 (2024.11~2025.12)', '이후 (2025.12~)']}
  rows={[
    { item: '관리 주체', values: ['Anthropic 단독', 'Agentic AI Foundation (Linux Foundation)'] },
    { item: '거버넌스', values: ['Anthropic 결정', '오픈 거버넌스 (다수 기업 참여)'] },
    { item: '참여 기업', values: ['Anthropic', 'Anthropic + OpenAI + Google + Microsoft + Block 등'] },
    { item: '라이선스', values: ['MIT', 'MIT (변경 없음)'] },
    { item: '스펙 발전', values: ['Anthropic 주도', '커뮤니티 RFC 프로세스'] },
  ]}
/>

### AAIF의 목표와 구조

<MermaidDiagram
  chart={`flowchart TB
    AAIF["Agentic AI Foundation\n(Linux Foundation 산하)"]
    subgraph PROJECTS["프로젝트"]
      MCP["MCP\n(Model Context Protocol)"]
      GOOSE["goose\n(AI Agent Framework)"]
      AGENTSMD["AGENTS.md\n(Agent Guidance Standard)"]
    end
    subgraph MEMBERS["참여 기업"]
      ANT["Anthropic"]
      OAI["OpenAI"]
      GOOG["Google"]
      MS["Microsoft"]
      BLOCK["Block"]
      MORE["기타 기업..."]
    end
    subgraph GOVERNANCE["거버넌스"]
      TSC["기술 운영 위원회\n(TSC)"]
      WG["작업 그룹"]
      RFC["RFC 프로세스"]
    end
    AAIF --> PROJECTS
    MEMBERS --> AAIF
    AAIF --> GOVERNANCE
    TSC --> MCP
    TSC --> GOOSE
    TSC --> AGENTSMD
    WG --> RFC
    style AAIF fill:#da7756,stroke:#c4613e,color:#fff
    style PROJECTS fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style MEMBERS fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style GOVERNANCE fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26`}
  title="AAIF 구조"
  caption="Linux Foundation 산하에서 MCP, goose, AGENTS.md를 포함한 에이전트 AI 표준을 관리합니다"
/>

<Callout type="tip" title="업계 표준으로 자리잡는 MCP">
  MCP가 Linux Foundation으로 이관됨에 따라, AI 에이전트의 도구 통합이 업계 표준으로 자리잡고 있습니다. OpenAI, Google도 MCP 지원을 발표했으며, Block의 goose와 OpenAI의 AGENTS.md도 함께 AAIF의 창립 프로젝트로 기부되어 에이전트 AI 생태계가 빠르게 발전하고 있습니다.
</Callout>

---

## 엔터프라이즈 환경에서의 MCP 활용 전략

대규모 조직에서 MCP를 효과적으로 도입하고 관리하기 위한 전략을 소개합니다.

### 단계적 도입 전략

<MermaidDiagram
  chart={`flowchart LR
    P1["1단계: 파일럿\n(1~2개 팀)"]
    P2["2단계: 확대\n(부서 단위)"]
    P3["3단계: 전사 적용\n(Managed Settings)"]
    P1 -->|"성과 검증"| P2
    P2 -->|"표준화"| P3
    P1_D["- 읽기 전용 서버만\n- GitHub, Fetch\n- 성과 지표 수집"]
    P2_D["- DB, Slack 추가\n- .mcp.json 표준화\n- 보안 가이드라인"]
    P3_D["- Managed MCP 배포\n- 사내 커스텀 서버\n- 감사 로그 연동"]
    P1 --- P1_D
    P2 --- P2_D
    P3 --- P3_D
    style P1 fill:#e3f2fd,stroke:#3b82f6,color:#2d2a26
    style P2 fill:#fff3e0,stroke:#d97706,color:#2d2a26
    style P3 fill:#e8f5e9,stroke:#16a34a,color:#2d2a26
    style P1_D fill:#f0ece5,stroke:#d4cdc4,color:#2d2a26
    style P2_D fill:#f0ece5,stroke:#d4cdc4,color:#2d2a26
    style P3_D fill:#f0ece5,stroke:#d4cdc4,color:#2d2a26`}
  title="MCP 엔터프라이즈 도입 단계"
  caption="파일럿 -> 확대 -> 전사 적용 순서로 단계적으로 도입합니다"
/>

### Managed MCP로 조직 전체 관리

조직 관리자는 Managed MCP 설정 파일로 모든 사용자에게 MCP 서버를 **강제 배포**할 수 있습니다.

<CodeBlock
  code={`// Linux: /etc/claude-code/managed-mcp.json
// macOS: /Library/Application Support/ClaudeCode/managed-mcp.json
{
  "mcpServers": {
    "company-internal-api": {
      "type": "http",
      "url": "https://mcp.internal.company.com/api",
      "headers": {
        "Authorization": "Bearer \${COMPANY_MCP_TOKEN}"
      }
    },
    "audit-logger": {
      "type": "http",
      "url": "https://audit.internal.company.com/mcp",
      "headers": {
        "X-Employee-ID": "\${EMPLOYEE_ID}"
      }
    }
  }
}`}
  language="json"
  filename="Managed MCP 설정"
/>

### Managed Settings로 서버 제한

<CodeBlock
  code={`// Managed Settings에서 허용/차단 서버 제어
{
  "permissions": {
    "allowedMcpServers": [
      "github",
      "company-internal-api",
      "memory",
      "fetch"
    ],
    "deniedMcpServers": [
      "puppeteer",
      "*-unofficial-*"
    ]
  }
}

// allowedMcpServers: 화이트리스트 방식 (목록에 있는 서버만 허용)
// deniedMcpServers: 블랙리스트 방식 (목록에 있는 서버 차단)
// 와일드카드(*) 패턴 지원`}
  language="json"
  filename="Managed Settings 서버 제한"
/>

### 엔터프라이즈 보안 체크리스트

<ComparisonTable
  title="엔터프라이즈 MCP 보안 체크리스트"
  headers={['항목', '권장 사항', '구현 방법']}
  rows={[
    { feature: '서버 허용 목록', values: ['승인된 서버만 사용 허용', 'Managed Settings의 allowedMcpServers'] },
    { feature: '인증 정보 관리', values: ['중앙화된 시크릿 관리', 'Vault, AWS Secrets Manager 등 연동'] },
    { feature: 'DB 접근', values: ['읽기 전용, 개발 환경만', '별도 읽기 전용 계정 생성'] },
    { feature: '감사 로그', values: ['모든 MCP 호출 기록', '커스텀 감사 로그 MCP 서버 배포'] },
    { feature: '네트워크 격리', values: ['내부 네트워크에서만 접근', 'VPN, 프록시 설정'] },
    { feature: '정기 검토', values: ['분기별 서버 목록 및 권한 검토', '보안팀 주도 리뷰 프로세스'] },
  ]}
/>

---

## MCP 설정 방법

<CodeBlock
  code={`# 1. 템플릿 복사
cp .mcp.json.example .mcp.json

# 2. 필요한 서버 활성화 (disabled: false로 변경)
# 3. 환경 변수 설정
export GITHUB_TOKEN="ghp_your_token_here"

# 4. Claude Code 실행
claude`}
  language="bash"
  filename="MCP 설정 순서"
/>

<Callout type="info" title="MCP 설정 범위">
  Claude Code에서 MCP 서버는 **프로젝트 레벨**(`.mcp.json`)과 **사용자 레벨**(`~/.claude.json`)로 구분하여 관리할 수 있습니다.
  엔터프라이즈에서는 Managed Settings의 `allowedMcpServers`/`deniedMcpServers`로 허용 서버를 제한할 수 있습니다.
</Callout>

---

## 트러블슈팅 가이드

MCP 서버 연결에 문제가 생겼을 때 체계적으로 진단하고 해결하는 방법입니다.

### 일반적인 문제와 해결법

<ComparisonTable
  title="MCP 트러블슈팅 가이드"
  headers={['증상', '원인', '해결 방법']}
  rows={[
    { feature: '서버 시작 타임아웃', values: ['npx 다운로드 느림 / 초기화 지연', 'MCP_TIMEOUT을 30000 이상으로 설정'] },
    { feature: '도구 실행 타임아웃', values: ['DB 쿼리나 웹 요청이 5분 초과', 'MCP_TOOL_TIMEOUT 증가 또는 쿼리 최적화'] },
    { feature: '서버가 목록에 없음', values: ['다른 스코프에 설정됨', 'claude mcp list로 확인, 올바른 스코프에 재추가'] },
    { feature: '승인 요청 반복', values: ['.mcp.json 변경으로 재승인 필요', '승인 프롬프트에서 허용 선택'] },
    { feature: 'HTTP 서버 인증 실패', values: ['OAuth 토큰 만료', '서버 제거 후 재추가하여 재인증'] },
    { feature: '출력이 잘림', values: ['MAX_MCP_OUTPUT_TOKENS 초과', 'MAX_MCP_OUTPUT_TOKENS 증가 또는 쿼리 범위 축소'] },
    { feature: 'stdio 서버 충돌', values: ['Node.js 버전 불일치 / 의존성 문제', 'npx 캐시 정리: npx clear-npx-cache'] },
    { feature: '도구가 검색되지 않음', values: ['도구 설명이 불명확', '도구 이름과 설명을 더 구체적으로 수정'] },
  ]}
/>

### 디버깅 순서

<CodeBlock
  code={`# 1. 현재 MCP 서버 상태 확인
claude mcp list

# 2. 특정 서버의 상세 정보 확인
claude mcp get <name>

# 3. 문제가 있는 서버 제거 후 재추가
claude mcp remove <name>
claude mcp add --transport <type> <name> <url-or-command>

# 4. 프로젝트 승인 상태 초기화
claude mcp reset-project-choices

# 5. 타임아웃 조정 (필요 시)
export MCP_TIMEOUT=30000         # 서버 시작 타임아웃 (30초)
export MCP_TOOL_TIMEOUT=600000   # 도구 실행 타임아웃 (10분)
export MAX_MCP_OUTPUT_TOKENS=50000  # 출력 토큰 제한 증가

# 6. npx 캐시 문제 해결
npx clear-npx-cache
# 또는 전역 설치로 전환
npm install -g @modelcontextprotocol/server-<name>`}
  language="bash"
  filename="MCP 디버깅 순서"
/>

### 로그 확인

<CodeBlock
  code={`# Claude Code 디버그 모드로 실행 (상세 로그 출력)
claude --debug

# MCP 서버 프로세스 직접 실행하여 에러 확인
# stdio 서버의 경우
npx -y @modelcontextprotocol/server-filesystem /tmp/test 2>&1

# 서버가 정상적으로 JSON-RPC 메시지를 주고받는지 확인
# 초기화 메시지를 stdin으로 직접 전송
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-11-25","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}' | npx -y @modelcontextprotocol/server-filesystem /tmp/test`}
  language="bash"
  filename="MCP 로그 확인"
/>

<Callout type="tip" title="문제가 지속될 때">
  위 단계로 해결되지 않으면 다음을 시도하세요:
  1. Claude Code를 최신 버전으로 업데이트 (`claude update`)
  2. MCP 서버 패키지를 최신 버전으로 업데이트
  3. GitHub Issues에서 동일한 문제가 보고되었는지 확인
  4. `claude mcp serve`로 Claude Code 자체를 MCP 서버로 실행하여 프로토콜 호환성 테스트
</Callout>

---

## 핵심 정리

<ComparisonTable
  title="MCP 핵심 요약"
  headers={['항목', '내용']}
  rows={[
    { feature: '정의', values: ['AI 에이전트와 외부 도구를 연결하는 개방형 표준 프로토콜'] },
    { feature: '프로토콜', values: ['JSON-RPC 2.0 기반, 양방향 통신'] },
    { feature: '핵심 기능', values: ['Tools (액션 실행), Resources (데이터 주입), Prompts (템플릿)'] },
    { feature: '전송 방식', values: ['stdio (로컬), Streamable HTTP (원격)'] },
    { feature: '보안', values: ['사용자 승인, 샌드박스, 최소 권한, Managed Settings'] },
    { feature: '거버넌스', values: ['Agentic AI Foundation (Linux Foundation)'] },
    { feature: '지원 클라이언트', values: ['Claude Code, VS Code, Cursor, GitHub Copilot, JetBrains 등'] },
    { feature: '설정 파일', values: ['.mcp.json (프로젝트), ~/.claude.json (사용자)'] },
  ]}
/>

<ChapterNav
  prev={{ title: 'Plugins', path: '/docs/part-3--핵심-기능-plugins' }}
  next={{ title: 'MCP 서버 활용', path: '/docs/part-4--확장과-자동화-mcp-서버-활용' }}
/>
