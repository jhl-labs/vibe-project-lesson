import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { DataTable } from '../../components/DataTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 4: 확장과 자동화/MCP 서버 활용" />

# MCP 서버 활용

> 실전 MCP 서버 연동으로 Claude Code의 능력 확장하기

## MCP 서버 생태계

MCP 서버는 Claude Code에 **외부 도구와 데이터 소스를 연결**하는 플러그인입니다. Claude Code는 기본적으로 파일 읽기/쓰기, Bash 명령 실행 등의 도구를 내장하고 있지만, MCP 서버를 추가하면 GitHub API, 데이터베이스 쿼리, 웹 검색, 프로젝트 관리 도구 등 훨씬 넓은 범위의 외부 시스템과 직접 상호작용할 수 있습니다.

2025년 9월에 공식 MCP Registry가 프리뷰로 출시되었고, 2025년 12월 9일 Anthropic은 MCP를 Linux Foundation 산하 **Agentic AI Foundation (AAIF)**에 기부하여 오픈 거버넌스 체제로 전환했습니다. 이로 인해 MCP 생태계는 특정 기업에 종속되지 않는 중립적인 표준으로 성장하고 있습니다.

<Callout type="info" title="MCP 서버를 찾는 곳">
  - **공식 Registry**: [registry.modelcontextprotocol.io](https://registry.modelcontextprotocol.io/) — 검증된 서버 목록, 설치 명령 제공
  - **GitHub Reference Servers**: [github.com/modelcontextprotocol/servers](https://github.com/modelcontextprotocol/servers) — Anthropic 공식 레퍼런스 구현
  - **커뮤니티 목록**: [github.com/punkpeye/awesome-mcp-servers](https://github.com/punkpeye/awesome-mcp-servers) — 커뮤니티가 관리하는 서버 모음
</Callout>

## 주요 공식 MCP 서버

아래는 `modelcontextprotocol/servers` 저장소에서 제공하는 공식 레퍼런스 서버입니다. 이 서버들은 Anthropic이 직접 개발하고 유지보수하며, MCP 프로토콜의 표준 구현 참조로 사용됩니다.

<DataTable
  title="Reference MCP 서버 (modelcontextprotocol/servers)"
  searchable={true}
  columns={[
    { key: 'name', header: '서버', width: '140px' },
    { key: 'description', header: '설명' },
    { key: 'useCase', header: '활용 사례' },
  ]}
  data={[
    { name: 'Filesystem', description: '보안 파일 작업 (접근 제어 설정 가능)', useCase: '외부 디렉토리 파일 읽기/쓰기' },
    { name: 'Git', description: 'Git 리포지토리 읽기, 검색, 조작', useCase: '다른 저장소 코드 참조' },
    { name: 'Memory', description: '지식 그래프 기반 영속 메모리', useCase: '세션 간 정보 유지' },
    { name: 'Fetch', description: '웹 콘텐츠 가져오기 및 LLM용 변환', useCase: 'API 문서, 웹 페이지 참조' },
    { name: 'Sequential Thinking', description: '동적 문제 해결 사고 시퀀스', useCase: '복잡한 추론 작업' },
    { name: 'Time', description: '시간 및 타임존 변환', useCase: '시간대 변환, 날짜 계산' },
    { name: 'Everything', description: '레퍼런스/테스트 서버', useCase: 'MCP 서버 개발 참고' },
  ]}
/>

### 주요 서버 상세 설명

**Filesystem** — Claude Code는 기본적으로 프로젝트 디렉토리 내 파일에 접근할 수 있지만, Filesystem MCP 서버를 사용하면 **프로젝트 외부의 특정 디렉토리**에 대한 접근을 안전하게 허용할 수 있습니다. 허용 디렉토리를 인자로 지정하여 접근 범위를 제한합니다.

**Memory** — Claude Code는 세션이 끝나면 대화 내용을 잊어버립니다. Memory 서버는 **지식 그래프** 형태로 정보를 저장하여 다음 세션에서도 이전에 학습한 내용을 기억할 수 있게 합니다. 프로젝트의 아키텍처 결정, 팀원 선호도, 반복적인 작업 패턴 등을 기억시키는 데 유용합니다.

**Fetch** — 외부 웹 페이지나 API 문서를 가져와서 LLM이 처리하기 좋은 형태로 변환합니다. HTML을 마크다운으로 변환하고, 불필요한 요소를 제거합니다. 라이브러리 공식 문서를 참조하면서 코드를 작성할 때 특히 유용합니다.

**Sequential Thinking** — 복잡한 문제를 단계별로 분해하여 사고하는 도구입니다. 각 사고 단계를 기록하고, 이전 단계를 수정하거나 분기할 수 있습니다. 아키텍처 설계, 디버깅, 복잡한 비즈니스 로직 구현 시 더 체계적인 추론을 가능하게 합니다.

### 주요 서드파티 서버

아래는 각 서비스 제공사가 공식적으로 개발하고 유지보수하는 MCP 서버입니다. 공식 서버이므로 API 변경에 빠르게 대응하며, 인증 흐름도 최적화되어 있습니다.

<DataTable
  title="주요 서드파티 MCP 서버"
  searchable={true}
  columns={[
    { key: 'server', header: '서버', width: '120px' },
    { key: 'provider', header: '제공', width: '100px' },
    { key: 'description', header: '설명' },
    { key: 'transport', header: '전송', width: '80px' },
  ]}
  data={[
    { server: 'GitHub', provider: 'GitHub', description: '이슈, PR, 코드 검색, 리포지토리 관리', transport: 'HTTP' },
    { server: 'Sentry', provider: 'Sentry', description: '에러 모니터링, 이슈 조회, 스택트레이스 분석', transport: 'HTTP' },
    { server: 'Notion', provider: 'Notion', description: '문서 읽기/쓰기, 데이터베이스 쿼리', transport: 'HTTP' },
    { server: 'Atlassian', provider: 'Atlassian', description: 'Jira 이슈/Confluence 문서 연동', transport: 'HTTP' },
    { server: 'Linear', provider: 'Linear', description: '프로젝트 관리, 이슈 추적', transport: 'HTTP' },
    { server: 'Prisma', provider: 'Prisma', description: '데이터베이스 스키마 관리, 마이그레이션', transport: 'stdio' },
    { server: 'DBHub', provider: 'Bytebase', description: 'DB 쿼리 실행 (PostgreSQL, MySQL, SQLite 등 6개 DB 지원)', transport: 'stdio' },
    { server: 'Puppeteer', provider: 'Anthropic', description: '브라우저 자동화, 스크린샷, 웹 스크래핑', transport: 'stdio' },
  ]}
/>

## 전송 방식 (Transport)

MCP 서버와 클라이언트가 통신하는 방식에는 두 가지가 있습니다. 어떤 전송 방식을 사용할지는 서버의 실행 환경에 따라 결정됩니다.

<ComparisonTable
  title="MCP 전송 방식 비교"
  headers={['방식', '통신 방법', '용도', '상태']}
  rows={[
    { feature: 'stdio', values: ['표준 입출력 (stdin/stdout)', '로컬 프로세스, CLI 도구', '활성'] },
    { feature: 'Streamable HTTP', values: ['단일 HTTP 엔드포인트', '원격 서버, 클라우드 서비스', '활성 (권장)'] },
    { feature: 'SSE', values: ['Server-Sent Events', '원격 서버 (구버전)', '사용 중단됨'] },
  ]}
/>

### stdio vs HTTP 선택 기준

**stdio**를 사용하는 경우:
- 서버가 `npx`, `python`, `node` 등 로컬 명령으로 실행되는 경우
- 서버가 사용자의 로컬 파일 시스템에 접근해야 하는 경우
- 인증이 환경 변수로 처리되는 경우

**HTTP**를 사용하는 경우:
- 서버가 원격에서 호스팅되는 경우 (SaaS 서비스의 MCP 엔드포인트)
- OAuth 등 웹 기반 인증 흐름이 필요한 경우
- 여러 클라이언트가 하나의 서버를 공유하는 경우

<Callout type="warning" title="SSE는 사용 중단됨">
  SSE(Server-Sent Events) 전송 방식은 2025-03-26 MCP 스펙부터 Streamable HTTP로 대체되었습니다 ([MCP Spec](https://spec.modelcontextprotocol.io/history)).
  기존 SSE 서버는 하위 호환성을 위해 동작하지만, 새 서버는 Streamable HTTP를 사용하세요.
</Callout>

## 설정 방법

MCP 서버를 Claude Code에 연결하는 방법은 크게 세 가지입니다: CLI 명령, JSON 직접 편집, `.mcp.json` 파일 사용.

### CLI로 추가 (`claude mcp add`)

가장 간편한 방법입니다. Claude Code CLI에서 직접 서버를 추가합니다.

<CodeBlock
  code={`# stdio 서버 (로컬 프로세스)
claude mcp add <name> -- <command> [args...]

# HTTP 서버 (원격, 권장)
claude mcp add --transport http <name> <url>

# 주요 옵션
# --transport: stdio | http | sse
# --scope: local(기본) | project | user
# --env KEY=value: 환경 변수 설정
# --header "Key: value": HTTP 헤더 설정`}
  language="bash"
  filename="claude mcp add 구문"
/>

### 실전 설정 예시

아래는 실무에서 자주 사용하는 MCP 서버 설정 예시입니다. 각 서버의 역할과 필요한 인자를 주석으로 설명합니다.

<CodeBlock
  code={`# ═══════════════════════════════════════════
# HTTP 전송 방식 서버 (원격, 인증 자동 처리)
# ═══════════════════════════════════════════

# GitHub MCP — PR, 이슈, 코드 검색 등 GitHub 전체 API 접근
# 브라우저에서 OAuth 인증 흐름이 자동으로 진행됨
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# Notion MCP — 워크스페이스 문서 검색, 페이지 읽기/쓰기
# Notion 앱에서 연동 승인 필요
claude mcp add --transport http notion https://mcp.notion.com/mcp

# Sentry MCP — 에러 이슈 조회, 스택트레이스 분석
# Sentry 계정 연동 후 사용
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp

# ═══════════════════════════════════════════
# stdio 전송 방식 서버 (로컬 프로세스)
# ═══════════════════════════════════════════

# Database (DBHub) — PostgreSQL, MySQL, SQLite 등 6개 DB 쿼리 실행
# --dsn으로 접속 정보 지정 (읽기 전용 계정 권장)
claude mcp add --transport stdio db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "postgresql://readonly:pass@db.example.com:5432/analytics"

# Filesystem — 프로젝트 외부 디렉토리 접근 허용
# 인자로 허용할 디렉토리 경로를 명시 (이 외에는 접근 불가)
claude mcp add --transport stdio files -- \\
  npx -y @modelcontextprotocol/server-filesystem \\
  /path/to/allowed/directory

# Memory — 세션 간 지식 그래프 유지
# 별도 인자 없이 실행, 로컬 파일에 데이터 저장
claude mcp add --transport stdio memory -- \\
  npx -y @modelcontextprotocol/server-memory

# ═══════════════════════════════════════════
# 인증이 필요한 HTTP 서버 (수동 헤더 설정)
# ═══════════════════════════════════════════

# Bearer 토큰으로 인증하는 커스텀 서버
claude mcp add --transport http secure-api \\
  https://api.example.com/mcp \\
  --header "Authorization: Bearer \${API_TOKEN}"`}
  language="bash"
  filename="MCP 서버 추가 예시"
/>

<Callout type="tip" title="HTTP 서버의 OAuth 인증">
  GitHub, Notion, Sentry 같은 HTTP MCP 서버는 처음 사용할 때 브라우저가 자동으로 열리며 OAuth 인증이 진행됩니다.
  한 번 인증하면 토큰이 로컬에 저장되어 이후에는 자동으로 연결됩니다.
  별도의 API 키 설정이 필요 없어 stdio 방식보다 설정이 간편합니다.
</Callout>

### JSON으로 직접 추가

복잡한 설정이 필요하거나 스크립트로 자동화할 때 JSON 형식을 사용합니다.

<CodeBlock
  code={`# JSON 형식으로 한번에 설정
claude mcp add-json weather-api '{
  "type": "http",
  "url": "https://api.weather.com/mcp",
  "headers": {
    "Authorization": "Bearer \${WEATHER_API_KEY}"
  }
}'`}
  language="bash"
  filename="JSON으로 MCP 서버 추가"
/>

### .mcp.json 파일 (팀 공유용)

팀 전체가 동일한 MCP 설정을 사용해야 할 때, 프로젝트 루트에 `.mcp.json` 파일을 생성하고 저장소에 커밋합니다. 이 파일은 `claude mcp add --scope project` 명령으로도 생성할 수 있습니다.

<CodeBlock
  code={`// 프로젝트 루트의 .mcp.json (저장소에 커밋하여 팀 공유)
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "github": {
      "type": "http",
      "url": "https://api.githubcopilot.com/mcp/"
    },
    "internal-api": {
      "type": "http",
      "url": "\${API_BASE_URL:-https://api.internal.com}/mcp",
      "headers": {
        "Authorization": "Bearer \${INTERNAL_API_KEY}"
      }
    }
  }
}`}
  language="json"
  filename=".mcp.json"
/>

<Callout type="tip" title="환경 변수 확장">
  `.mcp.json`에서 `$&#123;VAR&#125;` 형식으로 환경 변수를 참조할 수 있습니다.
  `$&#123;VAR:-default&#125;` 형식으로 기본값도 설정 가능합니다.
  `command`, `args`, `env`, `url`, `headers` 필드 모두에서 사용할 수 있습니다.
</Callout>

## 스코프 관리

MCP 서버 설정은 세 가지 스코프(범위)로 관리됩니다. 같은 이름의 서버가 여러 스코프에 정의되어 있으면, 더 좁은 범위의 설정이 우선 적용됩니다.

<MermaidDiagram
  chart={`flowchart TB
    U["User scope\n~/.claude.json\n모든 프로젝트, 개인"]
    P["Project scope\n.mcp.json\n팀 공유 (커밋)"]
    L["Local scope\n~/.claude.json 내 프로젝트별\n개인, 기본값"]
    M["Managed MCP\n관리자 제어\n조직 전체"]
    M --> L
    P --> L
    U --> L
    L --> R["최종 설정\n(Local 우선)"]
    style M fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style P fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style U fill:#f0ece5,stroke:#d4cdc4,color:#2d2a26
    style L fill:#f0ece5,stroke:#d4cdc4,color:#2d2a26
    style R fill:#faf9f7,stroke:#8c857c,color:#2d2a26`}
  title="MCP 설정 우선순위"
  caption="Local > Project > User 순으로 우선순위가 적용됩니다"
/>

| 스코프 | 저장 위치 | 용도 | 명령어 |
|--------|----------|------|--------|
| **local** (기본) | `~/.claude.json` 내 프로젝트 경로 | 개인 프로젝트 설정 | `claude mcp add` |
| **project** | `.mcp.json` (프로젝트 루트) | 팀 공유 | `claude mcp add --scope project` |
| **user** | `~/.claude.json` | 전역 개인 설정 | `claude mcp add --scope user` |

### 스코프 선택 가이드

- **모든 프로젝트에서 항상 쓰는 서버** (Memory, Fetch 등) → `user` 스코프
- **팀원 전체가 사용해야 하는 서버** (GitHub, 사내 API 등) → `project` 스코프 (`.mcp.json` 커밋)
- **특정 프로젝트에서 내가만 쓰는 서버** (개인 DB, 테스트 서버 등) → `local` 스코프 (기본값)
- **조직 전체에 강제 배포할 서버** → Managed MCP (관리자 전용)

## MCP 서버 관리

<CodeBlock
  code={`# 서버 목록 확인 — 현재 활성화된 모든 MCP 서버 표시
claude mcp list

# 특정 서버 상세 정보 — 설정값, 상태, 제공 도구 확인
claude mcp get <name>

# 서버 제거
claude mcp remove <name>

# Claude Desktop 설정 가져오기 — Desktop에서 설정한 서버를 CLI로 복사
claude mcp add-from-claude-desktop

# 프로젝트 승인 상태 초기화 — .mcp.json의 서버 승인 다시 요청
claude mcp reset-project-choices

# Claude Code를 MCP 서버로 실행 — 다른 MCP 클라이언트에서 사용
claude mcp serve`}
  language="bash"
  filename="MCP 관리 명령어"
/>

<Callout type="info" title="프로젝트 승인 프로세스">
  `.mcp.json`에 새로운 MCP 서버가 추가되면 Claude Code가 처음 실행될 때 **승인 확인**을 요청합니다.
  이는 보안을 위한 장치로, 악성 저장소가 사용자 모르게 MCP 서버를 실행하는 것을 방지합니다.
  한 번 승인하면 해당 프로젝트에서는 다시 묻지 않으며, `reset-project-choices`로 초기화할 수 있습니다.
</Callout>

## 환경 변수

MCP 서버의 동작을 제어하는 환경 변수입니다. 대부분의 경우 기본값으로 충분하지만, 네트워크 환경이나 서버 응답 시간에 따라 조정이 필요할 수 있습니다.

| 변수 | 설명 | 기본값 | 조정이 필요한 경우 |
|------|------|--------|-------------------|
| `MCP_TIMEOUT` | MCP 서버 시작 타임아웃 (밀리초) | `10000` (10초) | 무거운 서버(Puppeteer 등) 시작이 느릴 때 |
| `MCP_TOOL_TIMEOUT` | MCP 도구 실행 타임아웃 (밀리초) | `300000` (5분) | 대용량 DB 쿼리 등 오래 걸리는 작업 시 |
| `MAX_MCP_OUTPUT_TOKENS` | MCP 출력 토큰 최대값 | `25000` | 큰 데이터셋을 반환하는 도구 사용 시 |

## 실전 활용 시나리오

MCP 서버를 조합하면 Claude Code의 활용 범위가 크게 넓어집니다. 아래는 실무에서 자주 사용되는 시나리오입니다.

### 시나리오 1: 버그 분석 + 이슈 생성

Sentry에서 에러를 확인하고, 원인을 분석한 후, GitHub 이슈를 자동으로 생성합니다.

<CodeBlock
  code={`# 필요한 MCP 서버
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# Claude Code에서 사용 예시:
# "Sentry에서 최근 24시간 내 발생한 미해결 에러를 확인하고,
#  가장 빈도가 높은 에러 3개에 대해 원인을 분석한 후
#  각각 GitHub 이슈를 생성해줘. 라벨은 bug로 설정하고
#  에러 스택트레이스와 재현 조건을 이슈 본문에 포함해줘."`}
  language="bash"
  filename="버그 분석 + 이슈 생성"
/>

### 시나리오 2: 데이터베이스 기반 코드 생성

데이터베이스 스키마를 읽어서 이에 맞는 코드를 자동으로 생성합니다.

<CodeBlock
  code={`# 필요한 MCP 서버
claude mcp add --transport stdio db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "postgresql://readonly:pass@localhost:5432/mydb"

# Claude Code에서 사용 예시:
# "데이터베이스의 users, orders, products 테이블 스키마를 확인하고,
#  이에 맞는 TypeScript 엔티티 클래스와 Repository 패턴 코드를 생성해줘.
#  기존 프로젝트의 코딩 컨벤션을 따라줘."`}
  language="bash"
  filename="DB 스키마 기반 코드 생성"
/>

### 시나리오 3: 문서 참조하며 코드 작성

외부 라이브러리의 공식 문서를 참조하면서 코드를 작성합니다.

<CodeBlock
  code={`# 필요한 MCP 서버
claude mcp add --transport stdio fetch -- \\
  npx -y @modelcontextprotocol/server-fetch

# Claude Code에서 사용 예시:
# "Tanstack Query v5의 공식 문서에서 useSuspenseQuery 사용법을 확인하고,
#  현재 프로젝트의 API 호출을 React Suspense 패턴으로 리팩토링해줘.
#  공식 문서: https://tanstack.com/query/latest/docs/react/guides/suspense"`}
  language="bash"
  filename="문서 참조 코드 작성"
/>

### 시나리오 4: 프로젝트 관리 도구 연동

Notion이나 Linear에서 태스크를 확인하고, 해당 작업을 바로 수행합니다.

<CodeBlock
  code={`# 필요한 MCP 서버
claude mcp add --transport http notion https://mcp.notion.com/mcp
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# Claude Code에서 사용 예시:
# "Notion 스프린트 보드에서 이번 스프린트의 TODO 태스크 목록을 확인하고,
#  각 태스크에 대응하는 GitHub 이슈가 있는지 확인해줘.
#  이슈가 없는 태스크는 새로 생성해줘."`}
  language="bash"
  filename="프로젝트 관리 연동"
/>

### 시나리오 5: 세션 간 컨텍스트 유지

Memory 서버로 프로젝트 지식을 누적하여 세션이 바뀌어도 컨텍스트를 유지합니다.

<CodeBlock
  code={`# 필요한 MCP 서버
claude mcp add --transport stdio memory -- \\
  npx -y @modelcontextprotocol/server-memory

# Claude Code에서 사용 예시 (첫 번째 세션):
# "이 프로젝트의 아키텍처를 분석하고 주요 결정 사항들을
#  Memory에 저장해줘. 특히 인증 흐름, 데이터 모델,
#  API 구조에 대한 정보를 기록해줘."

# Claude Code에서 사용 예시 (이후 세션):
# "Memory에서 이 프로젝트의 아키텍처 정보를 불러와줘.
#  새로운 결제 모듈을 추가할 때 기존 인증 흐름과
#  데이터 모델을 어떻게 연동해야 하는지 알려줘."`}
  language="bash"
  filename="세션 간 컨텍스트 유지"
/>

<MermaidDiagram
  chart={`flowchart LR
    subgraph INPUT["📥 입력 소스"]
      SENTRY["Sentry\n에러 모니터링"]
      DB["Database\n스키마/데이터"]
      NOTION["Notion\n태스크 관리"]
      WEB["Web\n공식 문서"]
    end
    subgraph CLAUDE["🤖 Claude Code"]
      ANALYZE["분석 & 추론"]
      CODE["코드 생성/수정"]
      REPORT["리포트 생성"]
    end
    subgraph OUTPUT["📤 출력 대상"]
      GH["GitHub\n이슈/PR"]
      FS["Filesystem\n코드 파일"]
      MEM["Memory\n지식 저장"]
    end
    SENTRY --> ANALYZE
    DB --> ANALYZE
    NOTION --> ANALYZE
    WEB --> ANALYZE
    ANALYZE --> CODE
    ANALYZE --> REPORT
    CODE --> FS
    CODE --> GH
    REPORT --> GH
    REPORT --> MEM
    style INPUT fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style CLAUDE fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style OUTPUT fill:#f0ece5,stroke:#16a34a,color:#2d2a26`}
  title="MCP 서버 조합 활용 패턴"
  caption="다양한 입력 소스에서 정보를 수집하고, 분석 결과를 여러 출력 대상에 전달합니다"
/>

## 보안 고려사항

<Callout type="warning" title="MCP 보안 주의사항">
  MCP 서버는 외부 시스템에 접근 권한을 부여하므로 보안에 주의해야 합니다.
  신뢰할 수 없는 MCP 서버는 사용자 데이터를 유출하거나 시스템을 손상시킬 수 있습니다.
</Callout>

### 필수 보안 수칙

1. **환경 변수로 시크릿 관리**: 토큰/키를 `.mcp.json`에 직접 작성하지 마세요. `${VAR}` 형식으로 환경 변수를 참조하세요.

2. **최소 권한 원칙**: 필요한 서버만 활성화하세요. 사용하지 않는 서버는 `disabled: true`로 비활성화합니다.

3. **.mcp.json은 .gitignore에 추가**: 실제 설정 파일에 민감한 정보가 포함될 수 있으므로 Git에 커밋하지 마세요. 대신 `.mcp.json.example`을 템플릿으로 제공합니다.

4. **DB 접근 제한**: 프로덕션 DB에 직접 연결하지 마세요. 반드시 **읽기 전용 계정**을 사용하고, 가능하면 개발/스테이징 환경의 DB를 사용합니다.

5. **읽기 전용 우선**: 가능하면 읽기 전용 권한만 부여하세요. 쓰기 권한이 필요한 경우에만 명시적으로 허용합니다.

6. **서드파티 서버 검증**: 커뮤니티 서버를 사용할 때는 소스 코드를 확인하고, 어떤 데이터에 접근하는지 파악한 후 사용하세요.

<CodeBlock
  code={`# .gitignore에 추가
.mcp.json

# .mcp.json.example은 커밋 (템플릿으로 제공)
!.mcp.json.example`}
  language="bash"
  filename=".gitignore 설정"
/>

### 보안 설정 예시

<CodeBlock
  code={`// 보안을 고려한 .mcp.json 설정 예시
{
  "mcpServers": {
    "db": {
      "command": "npx",
      "args": [
        "-y", "@bytebase/dbhub",
        "--dsn", "\${DB_READONLY_URL}"
      ],
      "disabled": true  // 필요할 때만 활성화
    },
    "github": {
      "type": "http",
      "url": "https://api.githubcopilot.com/mcp/"
      // OAuth 사용 — 별도 토큰 설정 불필요
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y", "@modelcontextprotocol/server-filesystem",
        "./docs",
        "./src"
      ]
      // 프로젝트 내 특정 디렉토리만 허용
    }
  }
}`}
  language="json"
  filename="보안을 고려한 .mcp.json"
/>

## 엔터프라이즈: Managed MCP

조직 관리자는 Managed MCP 설정 파일로 모든 사용자에게 MCP 서버를 **강제 배포**할 수 있습니다. 이 설정은 사용자가 변경하거나 제거할 수 없으며, 조직의 내부 API 서버, 보안 도구, 감사 로그 서버 등을 일괄 적용하는 데 사용됩니다.

<CodeBlock
  code={`// Linux: /etc/claude-code/managed-mcp.json
// macOS: /Library/Application Support/ClaudeCode/managed-mcp.json
{
  "mcpServers": {
    "company-internal-api": {
      "type": "http",
      "url": "https://mcp.internal.company.com/api",
      "headers": {
        "Authorization": "Bearer \${COMPANY_MCP_TOKEN}"
      }
    },
    "audit-logger": {
      "type": "http",
      "url": "https://audit.internal.company.com/mcp",
      "headers": {
        "X-Employee-ID": "\${EMPLOYEE_ID}"
      }
    }
  }
}`}
  language="json"
  filename="Managed MCP 설정"
/>

Managed Settings에서 `allowedMcpServers`와 `deniedMcpServers`를 사용하면 사용자가 설치할 수 있는 MCP 서버를 제한할 수도 있습니다. 보안이 중요한 환경에서는 허용 목록(allowlist) 방식을 권장합니다.

## Claude Code를 MCP 서버로 사용

<Callout type="tip" title="claude mcp serve">
  `claude mcp serve` 명령으로 Claude Code 자체를 MCP 서버로 노출할 수 있습니다.
  Claude Desktop이나 다른 MCP 클라이언트에서 Claude Code의 코드 편집 능력을 활용할 수 있습니다.
</Callout>

이 기능은 다음과 같은 경우에 유용합니다:
- **Claude Desktop에서 코드 편집**: 대화형 UI에서 코드 작업 요청
- **커스텀 에이전트 시스템**: 여러 AI 에이전트가 Claude Code를 도구로 사용
- **자동화 파이프라인**: 외부 시스템에서 Claude Code의 코드 분석/수정 능력 호출

<CodeBlock
  code={`# Claude Code를 MCP 서버로 실행
claude mcp serve

# 다른 MCP 클라이언트에서 연결 설정 예시
{
  "mcpServers": {
    "claude-code": {
      "command": "claude",
      "args": ["mcp", "serve"]
    }
  }
}`}
  language="bash"
  filename="Claude Code를 MCP 서버로"
/>

## 트러블슈팅

MCP 서버 연결에 문제가 생겼을 때 확인할 사항들입니다.

<DataTable
  title="자주 발생하는 문제와 해결 방법"
  searchable={true}
  columns={[
    { key: 'symptom', header: '증상', width: '200px' },
    { key: 'cause', header: '원인' },
    { key: 'solution', header: '해결 방법' },
  ]}
  data={[
    { symptom: '서버 시작 타임아웃', cause: 'npx 패키지 다운로드가 느리거나 서버 초기화가 오래 걸림', solution: 'MCP_TIMEOUT 환경변수를 30000(30초) 이상으로 설정' },
    { symptom: '도구 실행 타임아웃', cause: 'DB 쿼리나 웹 요청이 5분을 초과', solution: 'MCP_TOOL_TIMEOUT을 늘리거나 쿼리/요청을 최적화' },
    { symptom: '서버가 목록에 없음', cause: '스코프가 다른 프로젝트에 설정되어 있음', solution: 'claude mcp list로 확인하고 올바른 스코프에 재추가' },
    { symptom: '승인 요청 반복', cause: '.mcp.json이 변경되어 재승인 필요', solution: 'Claude Code 재시작 시 승인 프롬프트에서 허용 선택' },
    { symptom: 'HTTP 서버 인증 실패', cause: 'OAuth 토큰 만료 또는 권한 부족', solution: '서버 제거 후 다시 추가하여 재인증' },
    { symptom: '출력이 잘림', cause: 'MCP 출력이 MAX_MCP_OUTPUT_TOKENS 초과', solution: 'MAX_MCP_OUTPUT_TOKENS 값을 늘리거나 쿼리 범위를 줄임' },
  ]}
/>

<CodeBlock
  code={`# 디버깅 순서

# 1. 서버 목록 확인
claude mcp list

# 2. 특정 서버 상태 확인
claude mcp get <name>

# 3. 서버 제거 후 다시 추가
claude mcp remove <name>
claude mcp add --transport <type> <name> <url-or-command>

# 4. 프로젝트 승인 초기화
claude mcp reset-project-choices

# 5. 타임아웃 조정 (필요 시)
export MCP_TIMEOUT=30000
export MCP_TOOL_TIMEOUT=600000`}
  language="bash"
  filename="MCP 디버깅 순서"
/>

## MCP 서버 개발 심화

직접 MCP 서버를 개발해야 하는 경우, 공식 SDK를 활용하면 빠르게 시작할 수 있습니다. TypeScript SDK와 Python SDK가 가장 널리 사용됩니다.

### TypeScript SDK로 MCP 서버 만들기

TypeScript SDK(`@modelcontextprotocol/sdk`)는 MCP 서버 개발의 표준 도구입니다. 도구(Tool), 리소스(Resource), 프롬프트(Prompt)를 선언적으로 정의할 수 있으며, stdio와 HTTP 전송 모두 지원합니다.

<CodeBlock
  code={`// src/server.ts — TypeScript MCP 서버 기본 구조
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// 서버 인스턴스 생성
const server = new McpServer({
  name: "my-custom-server",
  version: "1.0.0",
  capabilities: {
    tools: {},
    resources: {},
  },
});

// 도구 정의 — AI가 호출할 수 있는 함수
server.tool(
  "search_internal_docs",
  "사내 문서를 검색합니다",
  {
    query: z.string().describe("검색 키워드"),
    category: z.enum(["api", "guide", "faq"]).optional()
      .describe("문서 카테고리 필터"),
    limit: z.number().min(1).max(50).default(10)
      .describe("최대 결과 수"),
  },
  async ({ query, category, limit }) => {
    // 실제 검색 로직 구현
    const results = await searchDocuments(query, { category, limit });

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(results, null, 2),
        },
      ],
    };
  }
);

// 리소스 정의 — AI가 읽을 수 있는 데이터 소스
server.resource(
  "docs://api-spec",
  "내부 API 스펙 문서",
  async (uri) => {
    const spec = await loadApiSpec();
    return {
      contents: [
        {
          uri: uri.href,
          mimeType: "application/json",
          text: JSON.stringify(spec),
        },
      ],
    };
  }
);

// stdio 전송으로 서버 시작
const transport = new StdioServerTransport();
await server.connect(transport);`}
  language="typescript"
  filename="TypeScript MCP 서버 기본 구조"
/>

### Python SDK로 MCP 서버 만들기

Python SDK(`mcp`)는 데코레이터 기반의 간결한 API를 제공합니다. 데이터 분석, ML 모델 연동, 내부 시스템 통합에 적합합니다.

<CodeBlock
  code={`# server.py — Python MCP 서버 기본 구조
from mcp.server.fastmcp import FastMCP

# 서버 인스턴스 생성
mcp = FastMCP("internal-analytics")

@mcp.tool()
async def query_analytics(
    metric: str,
    start_date: str,
    end_date: str,
    granularity: str = "daily"
) -> str:
    """사내 분석 데이터를 조회합니다.

    Args:
        metric: 조회할 메트릭 (예: page_views, signups, revenue)
        start_date: 시작일 (YYYY-MM-DD)
        end_date: 종료일 (YYYY-MM-DD)
        granularity: 집계 단위 (hourly, daily, weekly, monthly)
    """
    results = await fetch_analytics_data(
        metric=metric,
        start=start_date,
        end=end_date,
        granularity=granularity,
    )
    return format_analytics_response(results)

@mcp.tool()
async def run_ab_test_analysis(experiment_id: str) -> str:
    """A/B 테스트 결과를 분석합니다.

    Args:
        experiment_id: 실험 ID
    """
    result = await analyze_experiment(experiment_id)
    return result.to_json()

@mcp.resource("analytics://dashboards")
async def list_dashboards() -> str:
    """사용 가능한 대시보드 목록을 반환합니다."""
    dashboards = await get_dashboard_list()
    return json.dumps(dashboards, ensure_ascii=False)

# 서버 실행
if __name__ == "__main__":
    mcp.run()`}
  language="python"
  filename="Python MCP 서버 기본 구조"
/>

<ComparisonTable
  title="MCP SDK 비교"
  headers={['항목', 'TypeScript SDK', 'Python SDK']}
  rows={[
    { feature: '패키지', values: ['@modelcontextprotocol/sdk', 'mcp (PyPI)'] },
    { feature: 'API 스타일', values: ['메서드 체이닝', '데코레이터 기반'] },
    { feature: '스키마 검증', values: ['Zod', 'Pydantic / 타입 힌트'] },
    { feature: '전송 지원', values: ['stdio, HTTP', 'stdio, HTTP (SSE 포함)'] },
    { feature: '적합한 용도', values: ['웹 서비스, API 연동', '데이터 분석, ML 연동'] },
    { feature: '배포', values: ['npx, Docker', 'pip, Docker, uvx'] },
  ]}
/>

### 프로젝트 초기화

<CodeBlock
  code={`# TypeScript 프로젝트 초기화
mkdir my-mcp-server && cd my-mcp-server
npm init -y
npm install @modelcontextprotocol/sdk zod
npm install -D typescript @types/node

# tsconfig.json 생성
npx tsc --init --target ES2022 --module NodeNext \\
  --moduleResolution NodeNext --outDir dist

# package.json에 bin 필드 추가
# "bin": { "my-mcp-server": "./dist/server.js" }
# "scripts": { "build": "tsc", "start": "node dist/server.js" }

# ─────────────────────────────────────────

# Python 프로젝트 초기화
mkdir my-mcp-server && cd my-mcp-server
python -m venv .venv && source .venv/bin/activate
pip install mcp

# 또는 uv 사용 (권장)
uv init my-mcp-server && cd my-mcp-server
uv add mcp`}
  language="bash"
  filename="MCP 서버 프로젝트 초기화"
/>

## 인기 MCP 서버 상세 가이드

가장 많이 사용되는 MCP 서버들의 심층 활용법을 알아봅니다.

### Filesystem 서버 심화

Filesystem 서버는 단순 파일 읽기/쓰기를 넘어 디렉토리 탐색, 파일 검색, 메타데이터 조회 등 다양한 기능을 제공합니다.

<CodeBlock
  code={`# 여러 디렉토리를 동시에 허용
claude mcp add --transport stdio files -- \\
  npx -y @modelcontextprotocol/server-filesystem \\
  /path/to/project-a/docs \\
  /path/to/project-b/src \\
  /path/to/shared-libs

# Filesystem 서버가 제공하는 주요 도구:
# - read_file: 파일 내용 읽기
# - read_multiple_files: 여러 파일 동시 읽기
# - write_file: 파일 쓰기
# - create_directory: 디렉토리 생성
# - list_directory: 디렉토리 목록 조회
# - move_file: 파일 이동/이름 변경
# - search_files: 패턴으로 파일 검색
# - get_file_info: 파일 메타데이터 조회
# - list_allowed_directories: 허용된 디렉토리 확인

# 활용 예시 (Claude Code 프롬프트):
# "files 서버를 통해 project-a의 docs 디렉토리에서
#  API 관련 문서를 모두 찾아서 현재 프로젝트의
#  API 설계에 참고해줘."`}
  language="bash"
  filename="Filesystem 서버 심화 활용"
/>

### GitHub 서버 심화

GitHub MCP 서버는 OAuth 기반으로 동작하며, 리포지토리 관리, 이슈/PR 처리, 코드 검색 등 GitHub API의 거의 모든 기능에 접근할 수 있습니다.

<CodeBlock
  code={`# GitHub MCP 서버 설정
claude mcp add --transport http github https://api.githubcopilot.com/mcp/

# 제공되는 주요 도구 (30개 이상):
# 리포지토리: create_repository, fork_repository, list_commits
# 이슈: create_issue, list_issues, update_issue, add_issue_comment
# PR: create_pull_request, list_pull_requests, merge_pull_request
# 브랜치: create_branch, list_branches
# 파일: get_file_contents, create_or_update_file, push_files
# 검색: search_code, search_issues, search_repositories, search_users
# 리뷰: create_pull_request_review

# 고급 활용 예시:
# "GitHub에서 우리 조직의 모든 리포지토리 중
#  지난 1주일간 머지되지 않은 PR을 찾아서
#  각 PR의 상태와 리뷰어 배정 현황을 정리해줘.
#  리뷰어가 없는 PR은 코드 변경 내용을 보고
#  적절한 리뷰어를 추천해줘."`}
  language="bash"
  filename="GitHub 서버 심화 활용"
/>

### Postgres 서버 (DBHub) 심화

DBHub은 단순 쿼리 실행 외에도 스키마 탐색, 테이블 관계 분석 등 데이터베이스 구조를 이해하는 데 유용한 기능을 제공합니다.

<CodeBlock
  code={`# PostgreSQL 연결 (읽기 전용 계정 필수)
claude mcp add --transport stdio db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "postgresql://readonly_user:pass@db.example.com:5432/mydb"

# MySQL 연결
claude mcp add --transport stdio mysql-db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "mysql://readonly:pass@db.example.com:3306/mydb"

# SQLite 연결 (로컬 파일)
claude mcp add --transport stdio sqlite-db -- \\
  npx -y @bytebase/dbhub \\
  --dsn "sqlite:///path/to/database.db"

# DBHub이 제공하는 주요 도구:
# - run_query: SQL 쿼리 실행 (SELECT만 권장)
# - list_tables: 데이터베이스 테이블 목록
# - describe_table: 테이블 스키마 상세 정보

# 고급 활용 예시:
# "DB에서 orders 테이블의 스키마를 확인하고,
#  지난 30일간 일별 주문 수와 매출 추이를 조회해줘.
#  이상치가 있으면 해당 날짜의 상세 데이터도 확인하고,
#  분석 결과를 차트로 표현할 수 있는 코드를 작성해줘."`}
  language="bash"
  filename="DBHub 서버 심화 활용"
/>

### Memory 서버 심화

Memory 서버는 엔티티(Entity), 관계(Relation), 관찰(Observation)로 구성된 지식 그래프를 관리합니다.

<CodeBlock
  code={`# Memory 서버 설정
claude mcp add --transport stdio memory -- \\
  npx -y @modelcontextprotocol/server-memory

# Memory 서버가 제공하는 도구:
# - create_entities: 새 엔티티 생성
# - create_relations: 엔티티 간 관계 생성
# - add_observations: 엔티티에 관찰 사항 추가
# - search_nodes: 지식 그래프 검색
# - open_nodes: 특정 노드 상세 조회
# - delete_entities: 엔티티 삭제
# - delete_relations: 관계 삭제
# - delete_observations: 관찰 삭제
# - read_graph: 전체 그래프 읽기

# 지식 그래프 구축 예시:
# "이 프로젝트의 주요 모듈 간 의존 관계를 분석해서
#  Memory에 저장해줘. 각 모듈의 역할, 주요 인터페이스,
#  담당 팀 정보를 엔티티로 만들고 의존 관계를
#  relation으로 표현해줘."

# 지식 활용 예시 (다음 세션):
# "Memory에서 이 프로젝트의 모듈 의존 관계를 불러와.
#  payment 모듈을 리팩토링할 때 영향받는 모듈을 알려주고,
#  안전한 리팩토링 순서를 제안해줘."`}
  language="bash"
  filename="Memory 서버 심화 활용"
/>

### Slack 서버 활용

Slack MCP 서버는 채널 메시지 읽기/쓰기, 사용자 정보 조회, 파일 공유 등을 지원합니다.

<CodeBlock
  code={`# Slack MCP 서버 설정 (Bot Token 필요)
claude mcp add --transport stdio slack -- \\
  npx -y @modelcontextprotocol/server-slack \\
  --env SLACK_BOT_TOKEN=\${SLACK_BOT_TOKEN} \\
  --env SLACK_TEAM_ID=\${SLACK_TEAM_ID}

# 주요 도구:
# - list_channels: 채널 목록 조회
# - post_message: 메시지 전송
# - reply_to_thread: 스레드 답글
# - add_reaction: 이모지 반응 추가
# - get_channel_history: 채널 메시지 기록 조회
# - get_thread_replies: 스레드 답글 조회
# - search_messages: 메시지 검색
# - get_users: 사용자 목록

# 활용 예시:
# "Slack의 #backend-alerts 채널에서 오늘 발생한
#  에러 메시지들을 확인하고, 각 에러의 원인을 코드에서
#  찾아서 수정 방안을 #dev-discussion에 정리해서 올려줘."`}
  language="bash"
  filename="Slack 서버 활용"
/>

## MCP 서버 배포 전략

MCP 서버를 운영 환경에서 안정적으로 배포하는 방법을 알아봅니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph LOCAL["로컬 배포"]
      L1["npx 실행\n가장 간단"]
      L2["글로벌 설치\nnpm install -g"]
      L3["로컬 바이너리\n빌드 후 직접 실행"]
    end
    subgraph DOCKER["Docker 배포"]
      D1["단일 컨테이너\nDockerfile"]
      D2["Docker Compose\n다중 서비스"]
      D3["Kubernetes\n대규모 운영"]
    end
    subgraph CLOUD["클라우드 배포"]
      C1["Streamable HTTP\nHTTP 엔드포인트"]
      C2["서버리스\nLambda, Cloud Run"]
      C3["관리형 서비스\nMCP 호스팅 플랫폼"]
    end
    L1 --> D1
    D1 --> C1
    L2 --> D2
    D2 --> C2
    L3 --> D3
    D3 --> C3
    style LOCAL fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style DOCKER fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style CLOUD fill:#f0ece5,stroke:#16a34a,color:#2d2a26`}
  title="MCP 서버 배포 전략"
  caption="로컬 개발에서 시작하여 Docker를 거쳐 클라우드로 확장할 수 있습니다"
/>

### 로컬 배포

개발 및 개인 사용에 적합합니다. `npx`로 실행하면 별도 설치 없이 바로 사용할 수 있습니다.

<CodeBlock
  code={`# 방법 1: npx로 실행 (가장 간단, 매번 최신 버전)
claude mcp add my-server -- npx -y my-mcp-server

# 방법 2: 글로벌 설치 후 실행 (빠른 시작, 버전 고정)
npm install -g my-mcp-server
claude mcp add my-server -- my-mcp-server

# 방법 3: 로컬 빌드 후 실행 (커스텀 서버)
cd /path/to/my-mcp-server
npm run build
claude mcp add my-server -- node /path/to/my-mcp-server/dist/server.js

# 방법 4: Python 서버 (uvx로 실행)
claude mcp add analytics -- uvx my-analytics-server

# 방법 5: Python 가상 환경에서 실행
claude mcp add analytics -- \\
  /path/to/venv/bin/python /path/to/server.py`}
  language="bash"
  filename="로컬 배포 방법"
/>

### Docker 배포

팀 환경이나 CI/CD에서 일관된 실행 환경을 보장합니다.

<CodeBlock
  code={`# Dockerfile 예시 — TypeScript MCP 서버
FROM node:20-slim

WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY dist/ ./dist/

# MCP 서버는 stdio로 통신하므로 ENTRYPOINT 사용
ENTRYPOINT ["node", "dist/server.js"]

# ─────────────────────────────────────────

# Docker로 빌드 및 Claude Code에서 사용
docker build -t my-mcp-server .

# Docker 컨테이너를 MCP 서버로 등록
claude mcp add my-server -- \\
  docker run --rm -i \\
  -e DB_URL=\${DB_URL} \\
  my-mcp-server

# ─────────────────────────────────────────

# docker-compose.yml — 여러 MCP 서버를 함께 관리
# version: "3.8"
# services:
#   docs-server:
#     build: ./servers/docs
#     stdin_open: true
#     environment:
#       - DOCS_API_KEY=\${DOCS_API_KEY}
#   analytics-server:
#     build: ./servers/analytics
#     stdin_open: true
#     environment:
#       - ANALYTICS_DB_URL=\${ANALYTICS_DB_URL}`}
  language="dockerfile"
  filename="Docker 배포"
/>

<Callout type="warning" title="Docker stdio 주의사항">
  Docker에서 MCP 서버를 실행할 때는 반드시 `-i` (interactive) 플래그를 사용해야 합니다.
  MCP는 stdin/stdout으로 통신하므로 표준 입력이 열려 있어야 합니다.
  또한 `--rm` 플래그로 컨테이너 종료 시 자동 정리되도록 설정하는 것을 권장합니다.
</Callout>

### 클라우드 배포 (Streamable HTTP)

원격 서버로 배포하면 여러 사용자가 동일한 MCP 서버를 공유할 수 있습니다. Streamable HTTP 전송 방식을 사용합니다.

<CodeBlock
  code={`// src/http-server.ts — HTTP 전송 기반 MCP 서버
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from
  "@modelcontextprotocol/sdk/server/streamableHttp.js";
import express from "express";

const app = express();
app.use(express.json());

// MCP 서버 생성 (도구 정의는 동일)
const server = new McpServer({
  name: "cloud-analytics",
  version: "1.0.0",
});

// ... 도구, 리소스 정의 ...

// HTTP 전송 설정
const transport = new StreamableHTTPServerTransport({
  sessionIdGenerator: undefined, // stateless 모드
});

app.post("/mcp", async (req, res) => {
  await transport.handleRequest(req, res, req.body);
});

// 헬스체크 엔드포인트
app.get("/health", (_, res) => res.json({ status: "ok" }));

await server.connect(transport);
app.listen(3000);
console.log("MCP server running on http://0.0.0.0:3000/mcp");

// ─────────────────────────────────────────
// Claude Code에서 연결
// claude mcp add --transport http analytics https://mcp.example.com/mcp`}
  language="typescript"
  filename="HTTP 전송 기반 클라우드 MCP 서버"
/>

## MCP 서버 보안 심화

엔터프라이즈 환경에서 MCP 서버를 안전하게 운영하기 위한 고급 보안 전략입니다.

### 인증과 권한 관리

<CodeBlock
  code={`// HTTP MCP 서버에 OAuth 2.1 인증 적용
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
  StreamableHTTPServerTransport
} from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import express from "express";

const app = express();

// 인증 미들웨어 — Bearer 토큰 검증
function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Authentication required" });
  }

  const token = authHeader.slice(7);
  try {
    const payload = verifyJWT(token);
    req.user = payload;
    req.permissions = payload.permissions || [];
    next();
  } catch (err) {
    return res.status(403).json({ error: "Invalid token" });
  }
}

// 권한 기반 도구 접근 제어
server.tool(
  "execute_query",
  "데이터베이스 쿼리를 실행합니다",
  { query: z.string(), database: z.string() },
  async ({ query, database }, { meta }) => {
    // 사용자 권한 확인
    const userPermissions = meta?.permissions || [];
    if (!userPermissions.includes("db:read")) {
      return {
        content: [{
          type: "text",
          text: "권한 부족: db:read 권한이 필요합니다."
        }],
        isError: true,
      };
    }

    // 읽기 전용 쿼리만 허용
    if (!isReadOnlyQuery(query)) {
      return {
        content: [{
          type: "text",
          text: "보안 정책: SELECT 쿼리만 허용됩니다."
        }],
        isError: true,
      };
    }

    const result = await executeQuery(database, query);
    return { content: [{ type: "text", text: JSON.stringify(result) }] };
  }
);

app.post("/mcp", authMiddleware, async (req, res) => {
  await transport.handleRequest(req, res, req.body);
});`}
  language="typescript"
  filename="MCP 서버 인증 및 권한 관리"
/>

### 감사 로그 (Audit Log)

MCP 서버의 모든 도구 호출을 기록하면, 누가 언제 어떤 작업을 수행했는지 추적할 수 있습니다. 이는 보안 사고 발생 시 핵심적인 증거가 됩니다.

<CodeBlock
  code={`// 감사 로그 미들웨어
interface AuditLogEntry {
  timestamp: string;
  userId: string;
  toolName: string;
  parameters: Record<string, unknown>;
  result: "success" | "error" | "denied";
  duration: number;
  clientInfo?: string;
}

class AuditLogger {
  private logStore: AuditLogEntry[] = [];

  async log(entry: AuditLogEntry): Promise<void> {
    // 구조화된 로그 출력
    console.log(JSON.stringify({
      level: "audit",
      ...entry,
    }));

    // 영속적 저장 (DB, S3 등)
    await this.persistLog(entry);
  }

  private async persistLog(entry: AuditLogEntry): Promise<void> {
    // 실제 구현에서는 DB나 외부 서비스에 저장
    await db.insert("audit_logs", entry);
  }
}

// 도구 실행 시 감사 로그 기록
function withAuditLog(
  toolFn: ToolHandler,
  toolName: string,
  logger: AuditLogger
): ToolHandler {
  return async (params, context) => {
    const start = Date.now();
    try {
      const result = await toolFn(params, context);
      await logger.log({
        timestamp: new Date().toISOString(),
        userId: context.meta?.userId || "unknown",
        toolName,
        parameters: params,
        result: "success",
        duration: Date.now() - start,
      });
      return result;
    } catch (error) {
      await logger.log({
        timestamp: new Date().toISOString(),
        userId: context.meta?.userId || "unknown",
        toolName,
        parameters: params,
        result: "error",
        duration: Date.now() - start,
      });
      throw error;
    }
  };
}`}
  language="typescript"
  filename="MCP 감사 로그 구현"
/>

### 입력 검증과 SQL 인젝션 방지

<CodeBlock
  code={`// SQL 인젝션 방지 — 읽기 전용 쿼리 검증
function isReadOnlyQuery(query: string): boolean {
  const normalizedQuery = query.trim().toUpperCase();

  // 허용되는 명령어 (SELECT만)
  const allowedPrefixes = ["SELECT", "WITH", "EXPLAIN"];
  const startsWithAllowed = allowedPrefixes.some(
    prefix => normalizedQuery.startsWith(prefix)
  );

  if (!startsWithAllowed) return false;

  // 위험한 키워드 차단
  const dangerousKeywords = [
    "INSERT", "UPDATE", "DELETE", "DROP", "ALTER",
    "CREATE", "TRUNCATE", "EXEC", "EXECUTE",
    "GRANT", "REVOKE", "CALL",
  ];

  return !dangerousKeywords.some(
    keyword => normalizedQuery.includes(keyword)
  );
}

// 파일 경로 검증 — 경로 탈출 방지
function isAllowedPath(
  requestedPath: string,
  allowedDirs: string[]
): boolean {
  const resolvedPath = path.resolve(requestedPath);

  return allowedDirs.some(dir => {
    const resolvedDir = path.resolve(dir);
    return resolvedPath.startsWith(resolvedDir + path.sep)
      || resolvedPath === resolvedDir;
  });
}`}
  language="typescript"
  filename="입력 검증 패턴"
/>

## 커스텀 MCP 서버 디버깅

MCP 서버 개발 중 발생하는 문제를 효과적으로 진단하는 방법입니다.

### MCP Inspector 활용

MCP Inspector는 MCP 서버를 대화식으로 테스트할 수 있는 공식 디버깅 도구입니다. 서버의 도구, 리소스, 프롬프트를 직접 호출하고 응답을 확인할 수 있습니다.

<CodeBlock
  code={`# MCP Inspector 실행 — 웹 기반 디버깅 UI 제공
npx @modelcontextprotocol/inspector

# 특정 서버를 직접 연결하여 테스트
npx @modelcontextprotocol/inspector \\
  npx -y my-mcp-server

# Python 서버 테스트
npx @modelcontextprotocol/inspector \\
  python server.py

# Inspector가 제공하는 기능:
# 1. 서버 정보 확인 (name, version, capabilities)
# 2. 도구 목록 및 스키마 확인
# 3. 도구 직접 호출 및 응답 확인
# 4. 리소스 목록 및 내용 조회
# 5. 프롬프트 템플릿 테스트
# 6. JSON-RPC 메시지 로그 확인
# 7. 에러 응답 디버깅`}
  language="bash"
  filename="MCP Inspector 사용법"
/>

### 로그 기반 디버깅

<CodeBlock
  code={`// stdio 서버에서의 디버깅 — stderr 활용
// 주의: stdout은 MCP 프로토콜 통신에 사용되므로
// 디버그 로그는 반드시 stderr로 출력해야 합니다.

function debugLog(message: string, data?: unknown): void {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    message,
    ...(data !== undefined && { data }),
  };
  // stderr로 출력 — MCP 통신에 영향 없음
  console.error(JSON.stringify(logEntry));
}

// 도구 실행 디버깅
server.tool(
  "my_tool",
  "도구 설명",
  { param: z.string() },
  async ({ param }) => {
    debugLog("my_tool 호출됨", { param });

    try {
      const result = await doSomething(param);
      debugLog("my_tool 성공", { resultSize: result.length });
      return { content: [{ type: "text", text: result }] };
    } catch (error) {
      debugLog("my_tool 에러", {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
);

// 로그 확인 방법:
// MCP Inspector에서 자동으로 stderr 로그를 표시하거나,
// 직접 실행 시 2>&1로 리다이렉트하여 확인`}
  language="typescript"
  filename="MCP 서버 디버깅 패턴"
/>

## MCP 서버 테스트 전략

안정적인 MCP 서버를 위한 체계적인 테스트 방법입니다.

### 단위 테스트

<CodeBlock
  code={`// 도구 로직 단위 테스트 — Jest 사용
import { describe, it, expect, jest } from "@jest/globals";
import { searchDocuments } from "../tools/search-documents";

describe("searchDocuments 도구", () => {
  it("키워드로 문서를 검색한다", async () => {
    const mockDb = {
      query: jest.fn().mockResolvedValue([
        { id: "1", title: "API 가이드", content: "REST API 사용법..." },
        { id: "2", title: "인증 가이드", content: "JWT 토큰..." },
      ]),
    };

    const result = await searchDocuments(
      { query: "API", category: "guide", limit: 10 },
      { db: mockDb }
    );

    expect(result).toHaveLength(2);
    expect(result[0].title).toContain("API");
    expect(mockDb.query).toHaveBeenCalledWith(
      expect.stringContaining("API"),
      expect.objectContaining({ category: "guide" })
    );
  });

  it("빈 검색어에 대해 에러를 반환한다", async () => {
    await expect(
      searchDocuments({ query: "", limit: 10 }, { db: mockDb })
    ).rejects.toThrow("검색어를 입력해주세요");
  });

  it("SQL 인젝션 시도를 차단한다", async () => {
    const result = await searchDocuments(
      { query: "'; DROP TABLE docs; --", limit: 10 },
      { db: mockDb }
    );

    // 파라미터화된 쿼리 사용으로 안전하게 처리됨
    expect(mockDb.query).toHaveBeenCalledWith(
      expect.any(String),
      expect.objectContaining({
        query: "'; DROP TABLE docs; --"
      })
    );
  });
});`}
  language="typescript"
  filename="MCP 서버 단위 테스트"
/>

### 통합 테스트

<CodeBlock
  code={`// MCP 프로토콜 수준의 통합 테스트
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { InMemoryTransport } from
  "@modelcontextprotocol/sdk/inMemory.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

describe("MCP 서버 통합 테스트", () => {
  let server: McpServer;
  let client: Client;

  beforeEach(async () => {
    server = createMyServer(); // 테스트용 서버 생성

    // 인메모리 전송으로 서버-클라이언트 연결
    const [clientTransport, serverTransport] =
      InMemoryTransport.createLinkedPair();

    await server.connect(serverTransport);

    client = new Client({
      name: "test-client",
      version: "1.0.0",
    });
    await client.connect(clientTransport);
  });

  afterEach(async () => {
    await client.close();
    await server.close();
  });

  it("도구 목록을 반환한다", async () => {
    const tools = await client.listTools();
    expect(tools.tools).toContainEqual(
      expect.objectContaining({
        name: "search_internal_docs",
      })
    );
  });

  it("도구를 호출하고 결과를 받는다", async () => {
    const result = await client.callTool({
      name: "search_internal_docs",
      arguments: { query: "authentication", limit: 5 },
    });

    expect(result.content).toBeDefined();
    expect(result.content[0].type).toBe("text");
    const parsed = JSON.parse(result.content[0].text);
    expect(parsed).toBeInstanceOf(Array);
  });

  it("잘못된 파라미터에 대해 에러를 반환한다", async () => {
    await expect(
      client.callTool({
        name: "search_internal_docs",
        arguments: { limit: -1 }, // query 누락, 잘못된 limit
      })
    ).rejects.toThrow();
  });
});`}
  language="typescript"
  filename="MCP 서버 통합 테스트"
/>

<Callout type="tip" title="InMemoryTransport">
  `InMemoryTransport.createLinkedPair()`는 MCP SDK가 제공하는 테스트용 전송 계층입니다.
  네트워크나 프로세스 없이 서버와 클라이언트를 메모리에서 직접 연결하므로
  빠르고 안정적인 테스트가 가능합니다.
</Callout>

## 엔터프라이즈 MCP 서버 관리

대규모 조직에서 MCP 서버를 체계적으로 관리하는 방법입니다.

### Managed MCP 심화

<CodeBlock
  code={`// /etc/claude-code/managed-mcp.json — 엔터프라이즈 설정
{
  "mcpServers": {
    // 사내 API 게이트웨이 — 모든 내부 서비스 접근
    "internal-gateway": {
      "type": "http",
      "url": "https://mcp-gateway.internal.company.com/v1",
      "headers": {
        "Authorization": "Bearer \${COMPANY_SSO_TOKEN}",
        "X-Department": "\${DEPARTMENT_ID}"
      }
    },
    // 보안 감사 서버 — 모든 AI 작업 로깅
    "security-audit": {
      "type": "http",
      "url": "https://audit.security.company.com/mcp",
      "headers": {
        "X-Employee-ID": "\${EMPLOYEE_ID}",
        "X-Audit-Context": "claude-code"
      }
    },
    // 사내 문서 검색 — Confluence, Wiki 통합
    "docs-search": {
      "type": "http",
      "url": "https://docs-mcp.internal.company.com/mcp",
      "headers": {
        "Authorization": "Bearer \${COMPANY_SSO_TOKEN}"
      }
    }
  }
}

// ─────────────────────────────────────────
// /etc/claude-code/managed-settings.json — 서버 제한
{
  "allowedMcpServers": [
    "internal-gateway",
    "security-audit",
    "docs-search",
    "github",
    "memory"
  ],
  "deniedMcpServers": [
    "*"  // 허용 목록에 없는 서버는 모두 차단
  ]
}`}
  language="json"
  filename="엔터프라이즈 Managed MCP 설정"
/>

### 조직 MCP 서버 운영 체크리스트

| 항목 | 설명 | 담당 |
|------|------|------|
| **SSO 통합** | 사내 SSO로 MCP 서버 인증 통합 | 보안팀 |
| **접근 제어** | 부서/역할별 도구 접근 권한 관리 | 인프라팀 |
| **감사 로그** | 모든 도구 호출 기록 및 보관 | 보안팀 |
| **모니터링** | 서버 가용성, 응답 시간, 에러율 모니터링 | SRE팀 |
| **버전 관리** | MCP 서버 버전 업데이트 정책 | DevOps팀 |
| **비상 차단** | 보안 사고 시 서버 즉시 비활성화 절차 | 보안팀 |
| **온보딩** | 신규 팀원 MCP 서버 설정 자동화 | DevOps팀 |
| **비용 관리** | 외부 API 호출 비용 모니터링 및 한도 설정 | 관리팀 |

## MCP 서버 체이닝

여러 MCP 서버를 연결하여 복잡한 워크플로우를 구성할 수 있습니다. 하나의 서버 출력이 다른 서버의 입력이 되는 파이프라인 패턴입니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph CHAIN1["1단계: 데이터 수집"]
      JIRA["Jira MCP\n이슈 조회"]
      GH["GitHub MCP\nPR 목록"]
      SENTRY["Sentry MCP\n에러 현황"]
    end
    subgraph CHAIN2["2단계: 분석"]
      CLAUDE["Claude Code\n상관관계 분석"]
    end
    subgraph CHAIN3["3단계: 실행"]
      GH2["GitHub MCP\n이슈 생성"]
      SLACK["Slack MCP\n알림 발송"]
      MEM["Memory MCP\n결과 저장"]
    end
    JIRA --> CLAUDE
    GH --> CLAUDE
    SENTRY --> CLAUDE
    CLAUDE --> GH2
    CLAUDE --> SLACK
    CLAUDE --> MEM
    style CHAIN1 fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style CHAIN2 fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style CHAIN3 fill:#f0ece5,stroke:#16a34a,color:#2d2a26`}
  title="MCP 서버 체이닝 패턴"
  caption="여러 서버에서 데이터를 수집하고, 분석 후, 결과를 다시 여러 서버에 전달합니다"
/>

<CodeBlock
  code={`# MCP 서버 체이닝을 위한 설정
# 1단계: 데이터 수집 서버들
claude mcp add --transport http jira https://mcp.atlassian.com/mcp
claude mcp add --transport http github https://api.githubcopilot.com/mcp/
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp

# 2단계: 분석 결과 전달 서버들
claude mcp add --transport http slack https://mcp.slack.com/mcp
claude mcp add --transport stdio memory -- \\
  npx -y @modelcontextprotocol/server-memory

# 체이닝 활용 예시 (Claude Code 프롬프트):
# "다음 작업을 순서대로 수행해줘:
#  1. Jira에서 현재 스프린트의 미완료 이슈를 조회해
#  2. GitHub에서 각 이슈에 연결된 PR의 상태를 확인해
#  3. Sentry에서 관련 에러가 있는지 확인해
#  4. 분석 결과를 종합하여:
#     - 위험 요소가 있는 이슈에 GitHub 코멘트 추가
#     - 스프린트 상태 요약을 Slack #sprint-review에 전송
#     - 분석 결과를 Memory에 저장해서 다음에 참조할 수 있게 해"`}
  language="bash"
  filename="MCP 서버 체이닝 활용"
/>

### 게이트웨이 패턴

여러 내부 서비스를 하나의 MCP 서버 뒤에 통합하여 관리를 단순화하는 패턴입니다.

<CodeBlock
  code={`// MCP 게이트웨이 서버 — 여러 내부 서비스를 하나로 통합
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

const gateway = new McpServer({
  name: "internal-gateway",
  version: "1.0.0",
});

// 사내 Wiki 검색
gateway.tool(
  "search_wiki",
  "사내 Wiki에서 문서를 검색합니다",
  { query: z.string(), space: z.string().optional() },
  async ({ query, space }) => {
    const results = await confluenceClient.search(query, { space });
    return { content: [{ type: "text", text: JSON.stringify(results) }] };
  }
);

// 사내 HR 시스템 조회
gateway.tool(
  "lookup_team_member",
  "팀원 정보를 조회합니다",
  { name: z.string(), department: z.string().optional() },
  async ({ name, department }) => {
    const member = await hrClient.findEmployee(name, { department });
    return { content: [{ type: "text", text: JSON.stringify(member) }] };
  }
);

// 사내 인프라 상태 확인
gateway.tool(
  "check_service_health",
  "내부 서비스 상태를 확인합니다",
  { service: z.string() },
  async ({ service }) => {
    const health = await infraClient.getServiceHealth(service);
    return { content: [{ type: "text", text: JSON.stringify(health) }] };
  }
);

// 사내 배포 이력 조회
gateway.tool(
  "get_deploy_history",
  "서비스 배포 이력을 조회합니다",
  {
    service: z.string(),
    limit: z.number().default(10),
  },
  async ({ service, limit }) => {
    const history = await deployClient.getHistory(service, limit);
    return { content: [{ type: "text", text: JSON.stringify(history) }] };
  }
);`}
  language="typescript"
  filename="MCP 게이트웨이 패턴"
/>

## 실전 예시: 사내 도구 MCP 서버 구축

실제 엔터프라이즈 환경에서 사내 도구를 MCP 서버로 통합하는 전체 과정을 안내합니다.

### 요구사항 분석

사내 개발팀이 다음과 같은 도구를 사용한다고 가정합니다:

| 도구 | 용도 | 접근 방법 |
|------|------|----------|
| Confluence | 기술 문서 | REST API |
| Jenkins | CI/CD 파이프라인 | REST API |
| Grafana | 모니터링 대시보드 | REST API |
| 사내 인증 시스템 | SSO 토큰 발급 | OAuth 2.0 |

<MermaidDiagram
  chart={`flowchart TB
    subgraph CLIENT["MCP 클라이언트"]
      CC["Claude Code"]
    end
    subgraph GATEWAY["사내 MCP 게이트웨이"]
      AUTH["인증 레이어\nSSO 토큰 검증"]
      ROUTER["도구 라우터"]
      AUDIT["감사 로그"]
    end
    subgraph SERVICES["사내 서비스"]
      CONF["Confluence API"]
      JENKINS["Jenkins API"]
      GRAFANA["Grafana API"]
    end
    CC -->|"Streamable HTTP"| AUTH
    AUTH --> ROUTER
    ROUTER --> CONF
    ROUTER --> JENKINS
    ROUTER --> GRAFANA
    ROUTER --> AUDIT
    style CLIENT fill:#f0ece5,stroke:#8c857c,color:#2d2a26
    style GATEWAY fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style SERVICES fill:#f0ece5,stroke:#16a34a,color:#2d2a26`}
  title="사내 도구 MCP 서버 아키텍처"
  caption="하나의 게이트웨이 MCP 서버가 여러 사내 서비스를 통합합니다"
/>

### 구현 예시

<CodeBlock
  code={`// src/internal-mcp-server.ts — 사내 도구 통합 MCP 서버
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from
  "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { z } from "zod";
import express from "express";

const app = express();
app.use(express.json());

const server = new McpServer({
  name: "internal-devtools",
  version: "2.0.0",
  capabilities: { tools: {} },
});

// ─── Confluence 도구 ─────────────────────────

server.tool(
  "search_confluence",
  "Confluence에서 기술 문서를 검색합니다",
  {
    query: z.string().describe("검색 키워드"),
    space: z.string().optional().describe("위키 스페이스 키"),
    limit: z.number().default(5).describe("최대 결과 수"),
  },
  async ({ query, space, limit }) => {
    const cql = space
      ? \`text ~ "\${query}" AND space = "\${space}"\`
      : \`text ~ "\${query}"\`;

    const response = await fetch(
      \`\${CONFLUENCE_URL}/rest/api/content/search?cql=\${encodeURIComponent(cql)}&limit=\${limit}\`,
      { headers: { Authorization: \`Bearer \${CONFLUENCE_TOKEN}\` } }
    );

    const data = await response.json();
    const results = data.results.map(page => ({
      title: page.title,
      url: \`\${CONFLUENCE_URL}\${page._links.webui}\`,
      excerpt: page.excerpt,
      lastUpdated: page.version.when,
    }));

    return {
      content: [{
        type: "text",
        text: JSON.stringify(results, null, 2),
      }],
    };
  }
);

// ─── Jenkins 도구 ─────────────────────────

server.tool(
  "get_build_status",
  "Jenkins 빌드 상태를 확인합니다",
  {
    job: z.string().describe("Jenkins 작업 이름"),
    count: z.number().default(5).describe("조회할 빌드 수"),
  },
  async ({ job, count }) => {
    const response = await fetch(
      \`\${JENKINS_URL}/job/\${job}/api/json?tree=builds[number,status,timestamp,duration]{0,\${count}}\`,
      { headers: { Authorization: \`Basic \${JENKINS_AUTH}\` } }
    );

    const data = await response.json();
    return {
      content: [{
        type: "text",
        text: JSON.stringify(data.builds, null, 2),
      }],
    };
  }
);

server.tool(
  "trigger_build",
  "Jenkins 빌드를 트리거합니다",
  {
    job: z.string().describe("Jenkins 작업 이름"),
    parameters: z.record(z.string()).optional()
      .describe("빌드 파라미터"),
  },
  async ({ job, parameters }) => {
    const url = parameters
      ? \`\${JENKINS_URL}/job/\${job}/buildWithParameters\`
      : \`\${JENKINS_URL}/job/\${job}/build\`;

    const response = await fetch(url, {
      method: "POST",
      headers: { Authorization: \`Basic \${JENKINS_AUTH}\` },
      body: parameters
        ? new URLSearchParams(parameters)
        : undefined,
    });

    return {
      content: [{
        type: "text",
        text: response.ok
          ? \`빌드가 트리거되었습니다: \${job}\`
          : \`빌드 트리거 실패: \${response.statusText}\`,
      }],
    };
  }
);

// ─── Grafana 도구 ─────────────────────────

server.tool(
  "query_metrics",
  "Grafana에서 메트릭을 조회합니다",
  {
    query: z.string().describe("PromQL 쿼리"),
    from: z.string().default("now-1h").describe("시작 시간"),
    to: z.string().default("now").describe("종료 시간"),
  },
  async ({ query: promql, from, to }) => {
    const response = await fetch(
      \`\${GRAFANA_URL}/api/ds/query\`,
      {
        method: "POST",
        headers: {
          Authorization: \`Bearer \${GRAFANA_TOKEN}\`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          queries: [{
            datasourceId: 1,
            expr: promql,
          }],
          from,
          to,
        }),
      }
    );

    const data = await response.json();
    return {
      content: [{
        type: "text",
        text: JSON.stringify(data.results, null, 2),
      }],
    };
  }
);

// ─── 서버 시작 ─────────────────────────

const transport = new StreamableHTTPServerTransport({
  sessionIdGenerator: undefined,
});

app.post("/mcp", authMiddleware, async (req, res) => {
  await transport.handleRequest(req, res, req.body);
});

app.get("/health", (_, res) => res.json({ status: "ok" }));
await server.connect(transport);
app.listen(3000);`}
  language="typescript"
  filename="사내 도구 통합 MCP 서버 전체 구현"
/>

### 배포 및 연결

<CodeBlock
  code={`# 1. Docker 이미지 빌드
docker build -t internal-devtools-mcp:latest .

# 2. 환경 변수 설정 (실제 값은 시크릿 매니저에서 관리)
# CONFLUENCE_URL, CONFLUENCE_TOKEN
# JENKINS_URL, JENKINS_AUTH
# GRAFANA_URL, GRAFANA_TOKEN

# 3. 컨테이너 실행 (Kubernetes 또는 Docker Compose)
docker run -d --name devtools-mcp \\
  -p 3000:3000 \\
  --env-file .env.production \\
  internal-devtools-mcp:latest

# 4. Claude Code에서 연결
claude mcp add --transport http devtools \\
  https://devtools-mcp.internal.company.com/mcp \\
  --header "Authorization: Bearer \${SSO_TOKEN}"

# 5. Managed MCP로 팀 전체에 배포
# /etc/claude-code/managed-mcp.json에 추가

# 6. 사용 예시:
# "Confluence에서 결제 시스템 관련 문서를 찾아서 읽고,
#  Jenkins에서 payment-service의 최근 빌드 상태를 확인해줘.
#  실패한 빌드가 있으면 Grafana에서 해당 시간대의
#  에러율 메트릭도 같이 확인해줘."`}
  language="bash"
  filename="사내 MCP 서버 배포 및 연결"
/>

## 모범 사례 요약

<ComparisonTable
  title="MCP 서버 설정 모범 사례"
  headers={['항목', '권장', '비권장']}
  rows={[
    { feature: '인증 정보', values: ['환경 변수 참조 (${VAR})', '.mcp.json에 직접 기입'] },
    { feature: '팀 설정 공유', values: ['.mcp.json을 저장소에 커밋', '각자 수동으로 설정'] },
    { feature: '민감한 설정', values: ['.mcp.json.example 템플릿 제공', '.mcp.json을 그대로 커밋'] },
    { feature: 'DB 접근', values: ['읽기 전용 계정, 개발 DB', '프로덕션 DB 직접 연결'] },
    { feature: '서버 범위', values: ['필요한 서버만 활성화', '모든 서버 상시 활성화'] },
    { feature: '파일 접근', values: ['허용 디렉토리 명시', '루트(/) 접근 허용'] },
    { feature: '서드파티 서버', values: ['소스 코드 확인 후 사용', '무분별하게 설치'] },
    { feature: '서버 개발', values: ['공식 SDK 사용, 테스트 포함', '프로토콜 직접 구현'] },
    { feature: '배포', values: ['Docker + Streamable HTTP', '로컬 프로세스만 의존'] },
    { feature: '감사', values: ['모든 도구 호출 로깅', '로그 없이 운영'] },
  ]}
/>

<ChapterNav
  prev={{ title: 'MCP 개요', path: '/docs/part-4--확장과-자동화-mcp-개요' }}
  next={{ title: 'CI/CD 통합', path: '/docs/part-4--확장과-자동화-ci-cd-통합' }}
/>
