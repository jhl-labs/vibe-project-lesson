import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { TemplateFileViewer } from '../../components/TemplateFileViewer';
import { ComparisonTable } from '../../components/ComparisonTable';
import { PlotlyChart } from '../../components/PlotlyChart';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';
import { templateFiles } from '../../data/template-files';

<Meta title="Part 3: 핵심 기능/커맨드와 스킬" />

# 커맨드와 스킬

> AI 에이전트에게 특정 작업을 빠르게 요청하는 단축 명령어와 전문 AI 스킬

## 개요

슬래시 커맨드는 AI 에이전트에서 자주 사용하는 작업을 **일관된 형식**으로 빠르게 실행하는 단축 명령어입니다.
Claude Code의 슬래시 커맨드는 크게 **내장 커맨드**와 **커스텀 커맨드** 두 가지로 나뉩니다. 내장 커맨드는 Claude Code가 기본 제공하는 시스템 명령어이고, 커스텀 커맨드는 프로젝트별로 `.claude/commands/` 디렉토리에 마크다운 파일로 정의하여 팀의 워크플로우에 맞게 확장할 수 있습니다.

### 내장 커맨드 vs 커스텀 커맨드

<ComparisonTable
  title="커맨드 유형 비교"
  headers={['항목', '내장 커맨드', '커스텀 커맨드']}
  rows={[
    { feature: '제공 주체', values: ['Claude Code 기본', '프로젝트/개인 정의'] },
    { feature: '설정 파일', values: ['없음 (내장)', '.claude/commands/*.md'] },
    { feature: '커스터마이징', values: ['no', 'yes'] },
    { feature: '인자 지원', values: ['커맨드별 상이', '$ARGUMENTS로 자유롭게'] },
    { feature: '프론트매터', values: ['해당 없음', 'description, allowed-tools, argument-hint, model 등'] },
    { feature: '예시', values: ['/init, /clear, /help', '/commit, /pr, /review'] },
  ]}
/>

---

## 내장 커맨드 완전 가이드

아래는 Claude Code에 **기본 내장**된 커맨드입니다. 별도 설정 없이 모든 프로젝트에서 바로 사용할 수 있습니다. Claude Code는 지속적으로 업데이트되므로, `/help`를 실행하면 현재 버전의 전체 커맨드 목록을 확인할 수 있습니다.

### 세션/컨텍스트 관리

| 커맨드 | 설명 | 주요 사용 시점 |
|--------|------|---------------|
| `/help` | 전체 커맨드 목록 및 도움말 표시 | 처음 사용 시, 커맨드 확인 시 |
| `/init` | CLAUDE.md 자동 생성 | 프로젝트 초기 설정 시 |
| `/clear` | 대화 기록 초기화 | 새 작업 시작 시, 컨텍스트 리셋 |
| `/compact` | 컨텍스트 압축 (긴 세션에서 메모리 효율화) | 토큰 한도 접근 시, 긴 대화 후 |
| `/cost` | 현재 세션의 토큰 사용량 및 비용 확인 | 비용 모니터링 시 |
| `/status` | 현재 git 상태 및 세션 정보 확인 | 작업 상태 점검 시 |
| `/context` | 컨텍스트 윈도우 사용량 시각화 | 컨텍스트 사용 현황 확인 시 |
| `/model` | 사용할 AI 모델 변경 | 모델 전환 시 (Sonnet, Opus 등) |
| `/resume` | 이전 세션 이어서 진행 | 세션 복원 시 |
| `/login` | Anthropic 계정 로그인 | 최초 설정 시 |
| `/logout` | Anthropic 계정 로그아웃 | 계정 전환 시 |

### 설정/환경

| 커맨드 | 설명 | 주요 사용 시점 |
|--------|------|---------------|
| `/config` | Claude Code 설정 관리 | 전역/프로젝트 설정 변경 시 |
| `/permissions` | 권한 규칙 확인 및 관리 | 보안 정책 조정 시 |
| `/memory` | 시스템 에디터에서 CLAUDE.md 직접 편집 | CLAUDE.md 수정 시 |
| `/mcp` | MCP 서버 상태 확인 및 관리 | 외부 도구 연동 시 |
| `/hooks` | Hook 설정을 인터랙티브하게 관리 | 자동화 규칙 설정 시 |
| `/doctor` | 설치 상태 진단 | 문제 발생 시 디버깅 |
| `/vim` | Vim 키 바인딩 모드 전환 | 에디터 키바인딩 변경 시 |
| `/terminal-setup` | 터미널 통합 설정 | 터미널 최초 설정 시 |
| `/install-github-app` | GitHub App 설치 (PR 자동 리뷰 등) | CI/CD 연동 시 |
| `/add-dir` | 추가 작업 디렉토리 등록 | 다중 디렉토리 작업 시 |
| `/agents` | 서브에이전트 관리 | 에이전트 생성/편집 시 |

### 개발 지원

| 커맨드 | 설명 | 주요 사용 시점 |
|--------|------|---------------|
| `/review` | 코드 리뷰 (내장) | 코드 검토 시 |
| `/bug` | 버그 리포트 제출 | Claude Code 버그 발견 시 |
| `/export` | 대화 내용 내보내기 | 대화 저장 시 |

### 주요 내장 커맨드 상세

#### /init — 프로젝트 초기화

프로젝트 루트에 `CLAUDE.md` 파일을 자동 생성합니다. 기존 코드베이스를 분석하여 기술 스택, 빌드 명령어, 프로젝트 구조를 자동으로 파악하고 문서화합니다.

<CodeBlock
  code={`# 프로젝트 루트에서 실행
/init

# 생성되는 CLAUDE.md 예시 구조
# - 프로젝트 개요
# - 기술 스택
# - 빌드/테스트 명령어
# - 프로젝트 디렉토리 구조
# - 코딩 컨벤션`}
  language="bash"
  filename="/init 사용 예시"
/>

<Callout type="tip" title="/init 활용 팁">
  이미 CLAUDE.md가 있어도 `/init`을 실행하면 기존 내용을 덮어쓰지 않고, 빠진 부분을 보완하거나 업데이트를 제안합니다.
  프로젝트가 성장하면서 정기적으로 `/init`을 실행하여 문서를 최신 상태로 유지하세요.
</Callout>

#### /compact — 컨텍스트 압축

긴 대화 세션에서 컨텍스트 창이 가득 차면, `/compact`로 이전 대화를 요약하여 토큰을 절약합니다. 핵심 정보는 유지하면서 불필요한 중간 과정을 압축합니다.

<CodeBlock
  code={`# 기본 사용
/compact

# 커스텀 요약 지시와 함께 사용
/compact 현재 작업 중인 인증 모듈 리팩토링에 집중하여 요약해줘

# 사용 시점 판단
# - 세션이 길어져 응답 속도가 느려질 때
# - "컨텍스트 한도에 근접" 경고가 나올 때
# - 새로운 하위 작업을 시작할 때`}
  language="bash"
  filename="/compact 사용 예시"
/>

#### /doctor — 설치 상태 진단

Claude Code의 설치 상태, 인증, 네트워크 연결, MCP 서버 등 전반적인 환경을 진단합니다. 문제가 있을 때 가장 먼저 실행해야 할 커맨드입니다.

<CodeBlock
  code={`# 진단 실행
/doctor

# 출력 예시
# Authentication: OK
# Network: OK
# MCP Servers: 2/2 connected
# Node.js: v20.11.0
# Claude Code: v2.1.3`}
  language="bash"
  filename="/doctor 사용 예시"
/>

#### /model — 모델 변경

세션 중에 사용할 AI 모델을 변경합니다. 간단한 작업에는 빠른 모델(Sonnet)을, 복잡한 작업에는 강력한 모델(Opus)을 선택적으로 사용하여 비용과 성능을 최적화할 수 있습니다.

<CodeBlock
  code={`# 모델 변경
/model

# 모델 선택 화면에서 원하는 모델 지정
# - claude-sonnet-4-20250514: Sonnet 4, 빠른 응답
# - claude-sonnet-4-5-20250929: Sonnet 4.5, 균형잡힌 성능 (기본 모델)
# - claude-opus-4-5-20251101: Opus 4.5, 복잡한 추론
# - claude-opus-4-6: Opus 4.6, 최신 최상위 모델
# 또는 별칭 사용: sonnet, opus, haiku`}
  language="bash"
  filename="/model 사용 예시"
/>

#### /cost — 비용 확인

현재 세션에서 사용한 토큰 수와 예상 비용을 확인합니다. API 사용량을 모니터링하고 예산을 관리하는 데 유용합니다.

---

## 커스텀 커맨드 작성법 심화

커스텀 커맨드는 `.claude/commands/` 디렉토리에 마크다운(`.md`) 파일로 정의합니다. 파일명이 곧 커맨드 이름이 됩니다.

### 커맨드 파일 구조와 프론트매터 옵션

<CodeBlock
  code={`---
description: "코드 변경사항을 분석하여 Conventional Commits 형식의 커밋 메시지를 생성합니다"
allowed-tools: Bash, Read, Glob, Grep
---

## 참조 규칙
- 컨벤션: @.claude/rules/conventions.md
- 현재 변경사항: !\`git diff --staged\`

스테이징된 변경사항을 분석하여 커밋 메시지를 생성합니다.

대상: $ARGUMENTS

## 작업 절차

1. 위 컨텍스트를 기반으로 변경사항 확인
2. 변경 유형 분류 (feat, fix, docs 등)
3. 영향 범위(scope) 식별
4. Conventional Commits 형식으로 메시지 생성`}
  language="markdown"
  filename=".claude/commands/commit.md"
/>

### 프론트매터 옵션 상세

| 옵션 | 타입 | 설명 |
|------|------|------|
| `description` | string | 커맨드 설명. `/` 입력 시 목록에 표시됨. Claude가 자동 매칭에도 활용 |
| `allowed-tools` | string (쉼표 구분) | 커맨드 실행 중 사용할 수 있는 도구 제한. 미지정 시 모든 도구 허용 |
| `model` | string | 커맨드 실행 시 사용할 모델 지정 (opus, sonnet, haiku) |
| `argument-hint` | string | 자동완성 시 인자 형식 힌트 (예: `[issue-number]`) |
| `context` | string | `"fork"` 지정 시 독립된 서브에이전트에서 실행 (메인 컨텍스트 오염 방지) |

### $ARGUMENTS — 커맨드 인자 활용

`$ARGUMENTS`는 슬래시 커맨드 호출 시 전달되는 인자 문자열입니다. 커맨드 파일 본문 어디서든 사용할 수 있습니다.

<CodeBlock
  code={`# 커맨드 파일 (.claude/commands/test.md)
---
description: "지정된 파일에 대한 테스트 코드를 생성합니다"
allowed-tools: Bash, Read, Write, Glob, Grep
---

$ARGUMENTS 파일에 대한 테스트 코드를 생성합니다.

## 단계
1. 대상 파일 읽기: $ARGUMENTS
2. 함수/클래스 구조 분석
3. 테스트 프레임워크 감지 (jest, vitest, pytest 등)
4. 테스트 코드 생성 및 저장

---

# 사용법
# /test src/services/user-service.ts
# → $ARGUMENTS = "src/services/user-service.ts"

# /test src/api/ --type integration
# → $ARGUMENTS = "src/api/ --type integration"`}
  language="markdown"
  filename="$ARGUMENTS 활용 예시"
/>

<Callout type="info" title="위치 인자 접근">
  Claude Code에서는 `$ARGUMENTS`로 전체 인자 문자열을 참조하고,
  `$1`, `$2`, `$3` 등으로 개별 위치 인자에 접근할 수 있습니다.
  예를 들어 `/fix-issue 123 high` 실행 시 `$1`은 "123", `$2`는 "high"를 참조합니다.
</Callout>

### 파일 참조와 명령 실행 — 자동 컨텍스트 로드

커맨드 본문에서 `@파일명`으로 파일 내용을 참조하고, `` !`명령어` ``로 셸 명령 결과를 포함할 수 있습니다. 커맨드가 항상 동일한 규칙이나 참조 문서를 필요로 할 때 유용합니다.

<CodeBlock
  code={`---
description: "코드 리뷰 수행"
allowed-tools: Read, Grep, Glob, Bash(git diff:*)
---

## 컨텍스트

- 코딩 컨벤션: @.claude/rules/conventions.md
- 현재 변경사항: !\`git diff --staged\`
- 변경된 파일 목록: !\`git diff --name-only HEAD~1\`

## 리뷰 규칙

위 컨텍스트를 기반으로 코드 리뷰를 수행합니다.
보안 취약점, 코드 품질, 컨벤션 준수 여부를 확인합니다.`}
  language="markdown"
  filename="파일 참조 및 명령 실행 예시"
/>

### allowed-tools — 도구 제한

커맨드가 사용할 수 있는 도구를 명시적으로 제한합니다. 보안이 중요한 커맨드에서 불필요한 도구 접근을 차단하는 데 유용합니다.

<CodeBlock
  code={`---
description: "보안 취약점 스캔 (읽기 전용)"
allowed-tools: Read, Glob, Grep
---

# allowed-tools를 Read, Glob, Grep으로 제한하면
# 이 커맨드 실행 중에는 Bash, Write, Edit 등의
# 파일 수정/명령 실행 도구를 사용할 수 없습니다.

코드베이스의 보안 취약점을 분석합니다.
절대 코드를 수정하지 마세요. 분석 결과만 보고합니다.`}
  language="markdown"
  filename="allowed-tools 제한 예시"
/>

---

## 팀용 커맨드 라이브러리 구축

### 디렉토리 구조

<CodeBlock
  code={`프로젝트/
├── .claude/
│   └── commands/              # 프로젝트 커스텀 커맨드 (git 커밋)
│       ├── commit.md          # 커밋 메시지 생성
│       ├── pr.md              # PR 설명 생성
│       ├── review.md          # 코드 리뷰
│       ├── test.md            # 테스트 생성
│       ├── doc.md             # 문서 생성
│       ├── refactor.md        # 리팩토링 제안
│       ├── security.md        # 보안 스캔
│       ├── changelog.md       # 변경 이력
│       ├── migrate.md         # DB 마이그레이션
│       ├── hotfix.md          # 핫픽스 가이드
│       └── deploy.md          # 배포 워크플로우
│
~/
└── .claude/
    └── commands/              # 개인 커스텀 커맨드 (git 미포함)
        ├── memo.md            # 개인 메모
        ├── learn.md           # 학습 도우미
        └── standup.md         # 스탠드업 리포트`}
  language="text"
  filename="커맨드 디렉토리 구조"
/>

<ComparisonTable
  title="프로젝트 커맨드 vs 개인 커맨드"
  headers={['항목', '프로젝트 커맨드', '개인 커맨드']}
  rows={[
    { feature: '위치', values: ['.claude/commands/', '~/.claude/commands/'] },
    { feature: '공유 범위', values: ['팀 전체 (git 커밋)', '개인만'] },
    { feature: '용도', values: ['팀 워크플로우 표준화', '개인 생산성 향상'] },
    { feature: '커맨드 충돌 시', values: ['프로젝트 커맨드 우선', '프로젝트에 없을 때 실행'] },
    { feature: '예시', values: ['/commit, /pr, /review', '/memo, /learn, /standup'] },
  ]}
/>

### 팀 커맨드 표준화 전략

<CodeBlock
  code={`# .claude/commands/README.md (팀 가이드)
# 이 디렉토리는 팀 공용 슬래시 커맨드를 정의합니다.
#
# 커맨드 추가 규칙:
# 1. 파일명은 kebab-case: check-types.md, run-e2e.md
# 2. 반드시 description 프론트매터 포함
# 3. allowed-tools로 최소 권한 원칙 적용
# 4. PR로 리뷰 후 머지
#
# 네이밍 컨벤션:
# - 동사로 시작: /check-*, /run-*, /generate-*
# - 약어 금지: /gen-doc (X) → /generate-doc (O)
# - 단수형: /test (O), /tests (X)`}
  language="markdown"
  filename="팀 커맨드 가이드"
/>

---

## 고급 커맨드 패턴

### 컨텍스트 포크 (context: fork)

`context: fork`를 지정하면 커맨드가 **독립된 서브에이전트**에서 실행됩니다. 메인 대화의 컨텍스트를 오염시키지 않으므로, 분석 작업이나 병렬 처리에 적합합니다.

<CodeBlock
  code={`---
description: "코드베이스 전체 보안 감사 (서브에이전트에서 실행)"
context: fork
allowed-tools: Read, Glob, Grep
---

코드베이스 전체에 대한 보안 감사를 수행합니다.

## 점검 항목
1. 하드코딩된 시크릿 탐지 (API 키, 비밀번호, 토큰)
2. SQL 인젝션 취약점
3. XSS 취약점
4. 안전하지 않은 의존성
5. 권한 검증 누락

## 출력 형식
심각도별로 분류된 보안 리포트를 생성합니다.`}
  language="markdown"
  filename=".claude/commands/security-audit.md (fork 모드)"
/>

<MermaidDiagram
  chart={`flowchart TB
    subgraph MAIN["메인 에이전트 컨텍스트"]
      U["사용자: /security-audit"] --> F["context: fork 감지"]
      F --> R["서브에이전트 결과 수신"]
      R --> N["메인 대화 계속"]
    end
    subgraph SUB["서브에이전트 (독립 컨텍스트)"]
      S1["보안 감사 시작"] --> S2["파일 스캔"]
      S2 --> S3["취약점 분석"]
      S3 --> S4["리포트 생성"]
    end
    F -.->|"포크"| S1
    S4 -.->|"결과 반환"| R
    style MAIN fill:#fdf2ee,stroke:#2563eb,color:#2d2a26
    style SUB fill:#fdf2ee,stroke:#9333ea,color:#2d2a26`}
  title="context: fork 실행 흐름"
  caption="서브에이전트는 독립된 컨텍스트에서 실행되어 메인 대화를 오염시키지 않습니다"
  maxWidth="600px"
/>

### 커맨드 체이닝과 워크플로우 자동화

여러 커맨드를 순차적으로 실행하는 **워크플로우 커맨드**를 만들 수 있습니다. 하나의 커맨드 파일에서 여러 단계를 정의하면 됩니다.

<CodeBlock
  code={`---
description: "코드 변경 → 리뷰 → 테스트 → 커밋까지 전체 워크플로우"
allowed-tools: Bash, Read, Write, Edit, Glob, Grep
---

전체 개발 워크플로우를 순차적으로 실행합니다.

대상: $ARGUMENTS

## 1단계: 코드 리뷰
변경된 파일에 대해 코드 리뷰를 수행합니다.
- 보안 취약점, 코드 품질, 컨벤션 준수 여부 확인
- Blocker가 있으면 여기서 중단하고 보고

## 2단계: 테스트 생성 및 실행
변경된 코드에 대한 테스트가 없으면 생성합니다.
- 기존 테스트 프레임워크와 패턴을 따름
- 테스트 실행 후 결과 확인

## 3단계: 커밋
모든 검증이 통과하면 커밋합니다.
- Conventional Commits 형식
- 변경 사항 요약을 본문에 포함`}
  language="markdown"
  filename=".claude/commands/ship.md (워크플로우 커맨드)"
/>

<Callout type="warning" title="워크플로우 커맨드 주의사항">
  워크플로우 커맨드는 여러 단계를 포함하므로 토큰 소비가 큽니다.
  각 단계에서 명확한 중단 조건을 정의하고, 실패 시 중간 결과를 보존하도록 설계하세요.
</Callout>

---

## CI/CD 환경에서 커맨드 활용 (Headless 모드)

Claude Code는 `--print` 플래그로 **headless 모드** 실행을 지원합니다. 이를 활용하면 CI/CD 파이프라인에서 슬래시 커맨드를 자동으로 실행할 수 있습니다.

<CodeBlock
  code={`# CI/CD에서 코드 리뷰 자동 실행
claude --print "/review" --output-format json

# PR 설명 자동 생성
claude --print "/pr --base main" > pr-description.md

# 보안 스캔 결과를 CI 아티팩트로 저장
claude --print "/security --severity high" > security-report.md

# 특정 파일에 대한 테스트 생성
claude --print "/test src/services/payment.ts" > tests/payment.test.ts`}
  language="bash"
  filename="CI/CD Headless 모드 예시"
/>

### GitHub Actions 통합 예시

<CodeBlock
  code={`# .github/workflows/ai-review.yml
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Run AI Code Review
        env:
          ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          claude --print "/review" --output-format json > review.json

      - name: Post Review Comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const review = fs.readFileSync('review.json', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: review
            });`}
  language="yaml"
  filename=".github/workflows/ai-review.yml"
/>

<MermaidDiagram
  chart={`flowchart LR
    subgraph CI["CI/CD 파이프라인"]
      PR["PR 생성"] --> REVIEW["/review<br/>코드 리뷰"]
      REVIEW --> TEST["/test<br/>테스트 생성"]
      TEST --> SEC["/security<br/>보안 스캔"]
      SEC --> REPORT["리포트 생성"]
    end
    subgraph OUT["출력"]
      REPORT --> COMMENT["PR 코멘트"]
      REPORT --> ARTIFACT["CI 아티팩트"]
    end
    style CI fill:#fdf2ee,stroke:#2563eb,color:#2d2a26
    style OUT fill:#fdf2ee,stroke:#16a34a,color:#2d2a26`}
  title="CI/CD에서 커맨드 활용 흐름"
  caption="Headless 모드로 CI/CD 파이프라인에 AI 리뷰, 테스트, 보안 스캔을 자동화합니다"
  maxWidth="650px"
/>

---

## 커맨드 디버깅과 테스트

### 커맨드 테스트 방법

<CodeBlock
  code={`# 1. 커맨드 파일 작성 후 직접 호출하여 테스트
/my-command test-argument

# 2. --print 모드로 출력만 확인 (실제 변경 없이)
claude --print "/my-command test-argument"

# 3. 디버깅: 커맨드 파일에 중간 확인 단계 추가
---
description: "디버깅용 커맨드"
---

## 디버깅 단계
1. 먼저 $ARGUMENTS 값을 출력하세요
2. 컨텍스트에 로드된 파일 목록을 보여주세요
3. 실제 작업을 수행하기 전에 계획을 설명하세요`}
  language="markdown"
  filename="커맨드 디버깅 방법"
/>

### 커맨드 트러블슈팅 체크리스트

| 증상 | 원인 | 해결 방법 |
|------|------|----------|
| 커맨드가 목록에 안 보임 | 파일 위치 오류 | `.claude/commands/` 디렉토리 확인 |
| 커맨드가 목록에 안 보임 | 파일 확장자 오류 | `.md` 확장자 확인 |
| $ARGUMENTS가 빈 값 | 인자 미전달 | 호출 시 인자 전달: `/cmd 인자값` |
| 프론트매터 무시됨 | YAML 문법 오류 | `---` 구분자, 들여쓰기 확인 |
| allowed-tools 무시됨 | 도구 이름 오타 | 정확한 도구명 사용 (Bash, Read, Write, Edit, Glob, Grep) |
| context 파일 로드 실패 | 경로 오류 | 프로젝트 루트 기준 상대 경로 확인 |
| fork 모드 미작동 | 문법 오류 | `context: fork`로 정확히 지정 |

---

## 커스텀 커맨드 — 이 프로젝트 템플릿 정의 (10개)

아래 10개 커맨드는 Claude Code 내장이 **아닙니다**. 이 프로젝트 템플릿의 `.claude/commands/` 디렉토리에 마크다운 파일로 정의된 **프로젝트 전용 커스텀 커맨드**입니다. 팀의 워크플로우에 맞게 자유롭게 수정할 수 있습니다.

<Callout type="warning" title="커스텀 커맨드는 프로젝트마다 다릅니다">
  아래 커맨드들은 이 템플릿이 제공하는 예시입니다. `.claude/commands/커맨드명.md` 파일이 있어야 동작하며,
  다른 프로젝트에서는 해당 파일이 없으면 사용할 수 없습니다.
</Callout>

### 개발 워크플로우

| 커맨드 | 설명 | 출력물 | 설정 파일 |
|--------|------|--------|-----------|
| `/commit` | 커밋 메시지 생성 | Conventional Commit 형식 메시지 | `.claude/commands/commit.md` |
| `/pr` | PR 설명 생성 | PR 제목, 설명, 체크리스트 | `.claude/commands/pr.md` |
| `/changelog` | 변경 이력 업데이트 | CHANGELOG 엔트리 | `.claude/commands/changelog.md` |
| `/hotfix` | 긴급 패치 가이드 | 핫픽스 워크플로우 | `.claude/commands/hotfix.md` |
| `/migrate` | 마이그레이션 스크립트 | DB/스키마 마이그레이션 | `.claude/commands/migrate.md` |

### 코드 품질

| 커맨드 | 설명 | 출력물 | 설정 파일 |
|--------|------|--------|-----------|
| `/review` | 코드 리뷰 (내장 확장) | 리뷰 코멘트 및 제안 | `.claude/commands/review.md` |
| `/test` | 테스트 케이스 생성 | 단위 테스트 코드 | `.claude/commands/test.md` |
| `/refactor` | 리팩토링 제안 | 개선된 코드 및 설명 | `.claude/commands/refactor.md` |
| `/security` | 보안 스캔 | 취약점 리포트 | `.claude/commands/security.md` |
| `/doc` | 문서 생성 | API 문서, JSDoc 등 | `.claude/commands/doc.md` |

<Callout type="info" title="커스텀 /review vs 내장 /review">
  Claude Code에는 내장 `/review`가 있지만, `.claude/commands/review.md`로 동일 이름의 커스텀 커맨드를 정의하면
  **커스텀 버전이 우선 실행**됩니다. 프로젝트별 리뷰 기준(보안 체크리스트, 컨벤션 검증 등)을 반영할 수 있습니다.
</Callout>

### [커스텀] /commit 상세

스테이징된 변경사항을 분석하여 Conventional Commits 형식의 커밋 메시지를 생성합니다.

<CodeBlock
  code={`# 사용법
/commit

# 출력 형식
<type>(<scope>): <subject>

<body>

<footer>

# 출력 예시
feat(auth): add JWT refresh token support

- Implement refresh token rotation
- Add token blacklist for logout
- Update auth middleware to handle refresh

Closes #123`}
  language="bash"
  filename="/commit 사용 예시"
/>

**타입 선택 기준:**

| 타입 | 사용 시점 |
|------|----------|
| `feat` | 새로운 기능 추가 |
| `fix` | 버그 수정 |
| `docs` | 문서만 변경 |
| `style` | 코드 포맷팅 (기능 변화 없음) |
| `refactor` | 기능 변화 없는 코드 개선 |
| `test` | 테스트 추가/수정 |
| `chore` | 빌드/설정 변경 |
| `perf` | 성능 개선 |
| `security` | 보안 관련 변경 |

### [커스텀] /pr 상세

브랜치의 변경사항을 분석하여 PR 제목과 설명을 생성합니다.

<CodeBlock
  code={`# 사용법
/pr
/pr --base main
/pr --template detailed

# 출력 예시
## PR 제목
feat: JWT 리프레시 토큰 지원

## 요약
변경사항 요약 (2-3문장)

## 변경 상세
### 추가된 것
- 리프레시 토큰 로테이션 구현
- 토큰 블랙리스트 추가

### 변경된 것
- 인증 미들웨어 업데이트

### 제거된 것
- 레거시 토큰 검증 로직

## 관련 이슈
Closes #123

## 테스트
- [ ] 단위 테스트 추가
- [ ] 통합 테스트 확인
- [ ] 수동 테스트 완료

## 체크리스트
- [ ] 자체 코드 리뷰 완료
- [ ] 문서 업데이트
- [ ] 린트 통과`}
  language="markdown"
  filename="/pr 출력 예시"
/>

### [커스텀] /review 상세

지정된 코드 또는 현재 변경사항에 대한 코드 리뷰를 수행합니다. Blocker/Suggestion/Question/Praise 4단계로 분류된 피드백을 생성합니다.

<CodeBlock
  code={`# 사용법
/review
/review src/services/user.ts
/review --focus security

# 출력 예시
## 코드 리뷰 결과

### 요약
- 변경 파일: 3개
- 발견된 이슈: 2개

### 필수 수정 (Blocker)
[src/api/users.ts:45] SQL 인젝션 취약점 발견

### 권장 사항 (Suggestion)
[src/services/user.ts:23] 에러 처리 개선 필요

### 질문 (Question)
[src/services/user.ts:50] 이 로직의 의도가 무엇인가요?

### 좋은 점 (Praise)
에러 핸들링이 일관적으로 잘 구현되어 있습니다

### 결론
수정 요청 (Blocker 해결 필요)`}
  language="markdown"
  filename="/review 출력 예시"
/>

### [커스텀] /test 상세

지정된 코드에 대한 테스트 케이스를 생성합니다. 단위, 통합, E2E 테스트를 지원합니다.

<CodeBlock
  code={`# 사용법
/test src/services/user.ts
/test --type unit
/test --type integration
/test --coverage 80

# 출력 예시
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange
      const userData = { email: 'test@example.com', name: 'Test' };

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result.email).toBe('test@example.com');
      expect(result.id).toBeDefined();
    });

    it('should throw ValidationError for invalid email', async () => {
      const userData = { email: 'invalid', name: 'Test' };
      await expect(userService.createUser(userData))
        .rejects.toThrow(ValidationError);
    });
  });
});`}
  language="typescript"
  filename="/test 출력 예시"
/>

### [커스텀] /doc 상세

코드에 대한 문서를 생성합니다. JSDoc, API 문서, README 등 다양한 형식을 지원합니다.

<CodeBlock
  code={`# 사용법
/doc src/services/user.ts
/doc --type jsdoc
/doc --type api
/doc --type readme

# 출력 예시 (JSDoc)
/**
 * Creates a new user account.
 *
 * @param data - User creation data
 * @returns Created user object
 * @throws {ValidationError} When email is invalid
 *
 * @example
 * const user = await createUser({
 *   email: 'user@example.com',
 *   name: 'John'
 * });
 */`}
  language="typescript"
  filename="/doc 출력 예시"
/>

### [커스텀] /refactor 상세

코드 스멜을 탐지하고 리팩토링을 제안합니다. 성능, 가독성 등 포커스를 지정할 수 있습니다.

<CodeBlock
  code={`# 사용법
/refactor src/services/order.ts
/refactor --focus performance
/refactor --focus readability

# 출력 예시
## 리팩토링 제안

### 대상
- 파일: src/services/order.ts
- 함수: processOrder

### 발견된 코드 스멜
1. Long Method (75줄)
2. Complex Conditional (5단계 중첩)

### 제안

#### Step 1: Extract Function
// Before
function processOrder(order) {
  // ... 75줄의 복잡한 로직 ...
}

// After
function processOrder(order) {
  validateOrder(order);
  const pricing = calculatePricing(order);
  return finalizeOrder(order, pricing);
}

### 예상 효과
- 가독성 향상
- 테스트 용이성 개선`}
  language="markdown"
  filename="/refactor 출력 예시"
/>

### [커스텀] /security 상세

코드의 보안 취약점을 분석합니다. Critical/High/Medium 심각도로 분류된 리포트를 생성합니다.

<CodeBlock
  code={`# 사용법
/security
/security src/api/
/security --severity high

# 출력 예시
## 보안 스캔 결과

### 요약
- 스캔 범위: src/
- Critical: 1개
- High: 2개
- Medium: 3개

### 상세
#### SQL Injection (Critical)
- 위치: src/api/users.ts:45
- 설명: 사용자 입력이 쿼리에 직접 사용됨
- 수정 권고: 파라미터화된 쿼리 사용

### 권장 조치
1. Critical/High 즉시 수정
2. Medium 1주일 내 수정`}
  language="markdown"
  filename="/security 출력 예시"
/>

### [커스텀] /changelog 상세

최근 변경사항을 분석하여 CHANGELOG 엔트리를 생성합니다. Keep a Changelog 형식을 따릅니다.

<CodeBlock
  code={`# 사용법
/changelog
/changelog --version 1.2.0
/changelog --since v1.1.0

# 출력 예시
## [1.2.0] - 2024-01-15

### Added
- JWT 리프레시 토큰 지원 (#123)
- 사용자 프로필 API (#124)

### Changed
- 로그인 플로우 개선 (#125)

### Fixed
- 세션 만료 버그 수정 (#126)

### Security
- XSS 취약점 패치 (#127)`}
  language="markdown"
  filename="/changelog 출력 예시"
/>

### [커스텀] /migrate 상세

데이터베이스 또는 스키마 마이그레이션 스크립트를 생성합니다. SQL, Prisma 등 다양한 형식을 지원합니다.

<CodeBlock
  code={`# 사용법
/migrate add-user-role-column
/migrate --type sql
/migrate --type prisma

# 출력 예시 (SQL)
-- Migration: add_user_role_column
-- Created at: 2024-01-15

-- Up
ALTER TABLE users ADD COLUMN role VARCHAR(50) DEFAULT 'user';
CREATE INDEX idx_users_role ON users(role);

-- Down
DROP INDEX idx_users_role;
ALTER TABLE users DROP COLUMN role;`}
  language="sql"
  filename="/migrate 출력 예시"
/>

### [커스텀] /hotfix 상세

긴급 수정이 필요한 상황에서 브랜치 생성부터 배포, 모니터링까지의 전체 핫픽스 워크플로우를 안내합니다.

<CodeBlock
  code={`# 사용법
/hotfix
/hotfix --issue 123

# 출력 예시
## 핫픽스 워크플로우

### 1. 브랜치 생성
git checkout main
git pull origin main
git checkout -b hotfix/ISSUE-123-critical-bug

### 2. 수정 및 테스트
- [ ] 버그 수정
- [ ] 단위 테스트 추가
- [ ] 로컬 테스트

### 3. 배포
git add .
git commit -m "fix: critical bug description"
git push origin hotfix/ISSUE-123-critical-bug

### 4. PR 생성
- base: main
- 리뷰어: @security-team
- 라벨: hotfix, urgent

### 5. 배포 후
- [ ] 프로덕션 모니터링
- [ ] 근본 원인 분석
- [ ] develop 브랜치에 백포트`}
  language="markdown"
  filename="/hotfix 출력 예시"
/>

---

## 실전 커맨드 모음 — 추가 예시

기본 10개 외에도 팀 필요에 따라 다양한 커맨드를 추가할 수 있습니다. 아래는 실무에서 유용한 추가 커맨드 예시입니다.

### /deploy — 배포 워크플로우

<CodeBlock
  code={`---
description: "배포 전 체크리스트를 실행하고 배포 명령을 안내합니다"
allowed-tools: Bash, Read, Glob, Grep
---

배포 전 점검 및 워크플로우를 안내합니다.

환경: $ARGUMENTS (staging | production)

## 점검 사항
1. 모든 테스트 통과 확인
2. 린트 검사 통과 확인
3. 빌드 성공 확인
4. 환경 변수 설정 확인
5. 마이그레이션 스크립트 확인

## 배포 단계
1. 태그 생성 및 푸시
2. CI/CD 파이프라인 트리거
3. 배포 후 헬스체크
4. 모니터링 대시보드 확인`}
  language="markdown"
  filename=".claude/commands/deploy.md"
/>

### /standup — 스탠드업 리포트

<CodeBlock
  code={`---
description: "최근 커밋 기반으로 스탠드업 리포트를 생성합니다"
allowed-tools: Bash, Read
---

최근 작업 내역을 기반으로 스탠드업 리포트를 생성합니다.

## 절차
1. 최근 24시간 또는 마지막 근무일 이후 커밋 조회
2. 변경사항 분류 및 요약
3. 아래 형식으로 출력

## 출력 형식
### 어제 한 일
- (커밋 기반 요약)

### 오늘 할 일
- (진행 중인 브랜치/이슈 기반)

### 블로커
- (있으면 기재)`}
  language="markdown"
  filename=".claude/commands/standup.md"
/>

### /check-types — 타입 검사

<CodeBlock
  code={`---
description: "TypeScript 타입 에러를 찾고 수정 방법을 안내합니다"
allowed-tools: Bash, Read, Glob, Grep
---

TypeScript 타입 검사를 실행하고 에러를 분석합니다.

## 절차
1. tsc --noEmit 실행
2. 에러 목록 파싱
3. 각 에러에 대한 수정 방법 제안
4. 심각도 순으로 정렬하여 출력`}
  language="markdown"
  filename=".claude/commands/check-types.md"
/>

---

## 커맨드 보안과 권한 관리

### 보안 원칙

<ComparisonTable
  title="커맨드 보안 등급"
  headers={['등급', '허용 도구', '사용 사례', '예시']}
  rows={[
    { feature: '읽기 전용', values: ['Read, Glob, Grep', '분석, 리뷰, 보안 스캔', '/review, /security'] },
    { feature: '제한된 쓰기', values: ['Read, Write, Glob, Grep', '문서 생성, 테스트 작성', '/doc, /test'] },
    { feature: '전체 접근', values: ['모든 도구', '워크플로우 자동화', '/ship, /deploy'] },
  ]}
/>

### 보안 체크리스트

<CodeBlock
  code={`# 커스텀 커맨드 보안 점검

## 1. 최소 권한 원칙
# 분석 전용 커맨드에는 Bash, Write, Edit를 허용하지 않음
allowed-tools: Read, Glob, Grep

## 2. 시크릿 노출 방지
# 커맨드 파일에 API 키, 토큰 등을 절대 하드코딩하지 않음
# 환경 변수 참조만 허용

## 3. 위험한 명령 차단
# Bash 허용 시에도 Hook으로 위험한 명령 차단
# rm -rf, DROP TABLE 등

## 4. 코드 리뷰 필수
# 새 커맨드 추가 시 반드시 PR 리뷰를 거침
# 특히 allowed-tools에 Bash가 포함된 경우 주의`}
  language="markdown"
  filename="커맨드 보안 점검"
/>

<Callout type="warning" title="Bash 도구 허용 시 주의">
  `allowed-tools`에 Bash를 포함하면 커맨드 실행 중 임의의 셸 명령을 수행할 수 있습니다.
  보안이 중요한 환경에서는 Bash 없이 Read/Glob/Grep만으로 구성하거나,
  Hooks의 PreToolUse 이벤트로 위험한 명령을 차단하는 것이 좋습니다.
</Callout>

---

## 커스텀 커맨드 조합 워크플로우

<MermaidDiagram
  chart={`flowchart LR
    subgraph DEV["일반 개발"]
      R1["/review"] --> T1["/test"] --> C1["/commit"] --> P1["/pr"]
    end
    subgraph SEC["보안 중심"]
      S2["/security"] --> R2["/review<br/>--focus security"] --> C2["/commit"]
    end
    subgraph DOC["문서 중심"]
      D3["/doc"] --> CL3["/changelog"] --> C3["/commit"]
    end
    subgraph CICD["CI/CD 자동화"]
      AUTO["/review<br/>(headless)"] --> SCAN["/security<br/>(headless)"] --> REPORT["리포트<br/>생성"]
    end
    style DEV fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style SEC fill:#fdf2ee,stroke:#dc2626,color:#2d2a26
    style DOC fill:#fdf2ee,stroke:#16a34a,color:#2d2a26
    style CICD fill:#fdf2ee,stroke:#2563eb,color:#2d2a26`}
  title="커맨드 조합 워크플로우"
  caption="상황에 따라 다른 커맨드 조합으로 효율적인 워크플로우를 구성합니다. CI/CD에서는 Headless 모드로 자동화할 수 있습니다."
  maxWidth="750px"
/>

<Callout type="tip" title="커스터마이징">
  팀의 워크플로우에 맞게 `.claude/commands/` 디렉토리의 커맨드 파일을 수정하고,
  `.claude/skills/` 디렉토리의 해당 스킬 파일도 함께 조정하세요.
</Callout>

<Callout type="info" title="Claude Code v2.1.3 커맨드/스킬 통합">
  Claude Code v2.1.3에서 슬래시 커맨드와 스킬이 통합되었습니다. `.claude/commands/`와 `.claude/skills/` 디렉토리 모두에서 마크다운 파일을 정의하면 `/파일명`으로 호출할 수 있습니다.
  `$ARGUMENTS` 변수로 전체 인자를 받을 수 있고, `$1`, `$2` 등으로 개별 위치 인자에 접근할 수 있습니다.
  `context: fork` 프론트매터를 추가하면 독립된 서브에이전트에서 실행됩니다.
</Callout>

---

## 스킬 (Skills) 개요

스킬은 `.claude/skills/` 디렉토리에 정의된 **실행 가능한 전문 능력**입니다. 각 스킬은 `SKILL.md` 파일을 포함하는 디렉토리로 구성되며, 슬래시 커맨드(`/스킬명`)로 직접 호출하거나, Claude가 대화 내용과 스킬의 `description`을 매칭하여 자동으로 실행합니다. 각 스킬은 특정 작업에 대한 상세한 절차, 체크리스트, 출력 형식을 정의합니다.

<Callout type="info" title="프롬프트 vs 스킬">
  **프롬프트**는 "어떤 정보를 제공하고 무엇을 요청할지"의 템플릿이고,
  **스킬**은 "AI가 어떻게 작업을 수행할지"의 실행 절차서입니다.
</Callout>

## 5개 스킬 요약

| 스킬 | 커맨드 | 핵심 역할 | 설정 파일 |
|------|--------|----------|-----------|
| **Code Review** | `/review` | 코드 리뷰 (보안, 품질, 성능) | `.claude/skills/code-review/SKILL.md` |
| **Test Generation** | `/test` | 테스트 코드 생성 (단위, 통합, E2E) | `.claude/skills/test-gen/SKILL.md` |
| **Documentation** | `/doc` | 문서 생성 (JSDoc, API, README, ADR) | `.claude/skills/doc-gen/SKILL.md` |
| **Refactor** | `/refactor` | 리팩토링 (7가지 기법, 코드 스멜 탐지) | `.claude/skills/refactor/SKILL.md` |
| **Security Scan** | `/security` | 보안 취약점 분석 (OWASP Top 10) | `.claude/skills/security-scan/SKILL.md` |

---

## Code Review 스킬 상세

6개 영역(기능, 품질, 보안, 성능, 테스트, 문서화)을 체계적으로 검토하고, Blocker/Suggestion/Question/Praise 4단계 피드백을 생성합니다.

### 리뷰 프로세스

<MermaidDiagram
  chart={`flowchart TB
    subgraph P1["Phase 1: 분석"]
      A1["변경 파일 목록 확인"]
      A2["변경 유형 분류<br/>(기능/버그/리팩토링)"]
      A3["영향 범위 파악"]
      A1 --> A2 --> A3
    end
    subgraph P2["Phase 2: 검토"]
      B1["기능 정확성"]
      B2["코드 품질<br/>(컨벤션, DRY, KISS)"]
      B3["보안 취약점"]
      B4["성능 이슈"]
      B5["테스트 커버리지"]
    end
    subgraph P3["Phase 3: 피드백"]
      C1["🚨 필수 수정<br/>(Blocker)"]
      C2["💡 권장 사항<br/>(Suggestion)"]
      C3["❓ 질문<br/>(Question)"]
      C4["✨ 좋은 점<br/>(Praise)"]
    end
    P1 --> P2 --> P3
    style P1 fill:#fdf2ee,stroke:#2563eb,color:#2d2a26
    style P2 fill:#fdf2ee,stroke:#9333ea,color:#2d2a26
    style P3 fill:#fdf2ee,stroke:#16a34a,color:#2d2a26`}
  title="Code Review 프로세스"
  caption="3단계(분석 → 검토 → 피드백)로 체계적인 코드 리뷰를 수행합니다"
/>

### 6개 영역 체크리스트

| 영역 | 검토 내용 |
|------|----------|
| 기능 정확성 | 요구사항 구현 여부, 엣지 케이스, 에러 처리 |
| 코드 품질 | 가독성, SRP, 중복 코드, 네이밍 |
| 보안 | SQL 인젝션, XSS, 하드코딩된 시크릿, 인증/인가 |
| 성능 | N+1 쿼리, 불필요한 연산, 메모리 누수, 캐싱 |
| 테스트 | 테스트 작성 여부, 엣지 케이스 커버리지, 독립성 |
| 문서화 | 공개 API 문서, 복잡 로직 주석, README 업데이트 |

### 피드백 작성 예시

<CodeBlock
  code={`🚨 [필수] 보안 취약점 — SQL 인젝션
// 현재 코드
const query = \`SELECT * FROM users WHERE id = \${userId}\`;

// 수정 제안
const query = 'SELECT * FROM users WHERE id = $1';
const result = await db.query(query, [userId]);

---

💡 [제안] 가독성 개선 — early return 패턴
// 현재 코드
if (user) {
  if (user.isActive) {
    // 긴 코드...
  }
}

// 수정 제안
if (!user) return;
if (!user.isActive) return;
// 긴 코드...

---

❓ [질문] 이 로직에서 null을 반환하는 대신 예외를 던지는 것이 더 적절할 것 같은데, 특별한 이유가 있나요?

---

✨ [좋습니다] 에러 처리가 일관적으로 잘 구현되어 있네요!`}
  language="typescript"
  filename="리뷰 피드백 4단계 예시"
/>

---

## Test Generation 스킬 상세

테스트 피라미드 비율(Unit 70%, Integration 20%, E2E 10%)을 따르며, AAA 패턴과 FIRST 원칙에 기반한 테스트 코드를 생성합니다.

### 테스트 피라미드

<PlotlyChart
  title="테스트 피라미드 비율"
  data={[
    {
      labels: ['Unit Tests (70%)', 'Integration Tests (20%)', 'E2E Tests (10%)'],
      values: [70, 20, 10],
      type: 'pie',
      hole: 0.4,
      marker: {
        colors: ['#da7756', '#e8a98e', '#f0cec0'],
        line: { color: '#d4cdc4', width: 2 },
      },
      textinfo: 'label+percent',
      textfont: { color: '#2d2a26', size: 12 },
      hovertemplate: '%{label}<br>비율: %{percent}<extra></extra>',
    },
  ]}
  layout={{
    margin: { t: 20, b: 20, l: 20, r: 20 },
    showlegend: false,
  }}
  height={320}
/>

### FIRST 원칙

| 원칙 | 설명 |
|------|------|
| **F**ast | 빠르게 실행 |
| **I**ndependent | 테스트 간 독립 |
| **R**epeatable | 동일 결과 보장 |
| **S**elf-validating | 자동 판별 |
| **T**imely | 코드와 함께 작성 |

### 단위 테스트 — AAA 패턴 예시

<CodeBlock
  code={`describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange — 테스트 준비
      const userData = { email: 'test@example.com', name: 'Test User' };
      const mockRepository = createMockUserRepository();

      // Act — 테스트 실행
      const result = await userService.createUser(userData);

      // Assert — 결과 검증
      expect(result.email).toBe(userData.email);
      expect(mockRepository.save).toHaveBeenCalledWith(
        expect.objectContaining(userData)
      );
    });

    it('should throw ValidationError when email is invalid', async () => {
      await expect(userService.createUser({ email: 'invalid' }))
        .rejects.toThrow(ValidationError);
    });
  });
});`}
  language="typescript"
  filename="단위 테스트 (AAA 패턴)"
/>

### 통합 테스트 — API 엔드포인트 예시

<CodeBlock
  code={`describe('POST /api/users', () => {
  it('should create user and return 201', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', name: 'Test User' })
      .expect(201);

    expect(response.body).toMatchObject({
      email: 'test@example.com',
      name: 'Test User',
    });
    expect(response.body.id).toBeDefined();
  });

  it('should return 409 for duplicate email', async () => {
    await request(app).post('/api/users')
      .send({ email: 'test@example.com', name: 'Test' });

    const response = await request(app).post('/api/users')
      .send({ email: 'test@example.com', name: 'Test 2' })
      .expect(409);

    expect(response.body.error).toContain('already exists');
  });
});`}
  language="typescript"
  filename="통합 테스트 (API 엔드포인트)"
/>

### 모킹 가이드

<CodeBlock
  code={`// 의존성 모킹
const mockUserRepo: jest.Mocked<IUserRepository> = {
  findById: jest.fn(),
  save: jest.fn(),
  delete: jest.fn(),
};
mockUserRepo.findById.mockResolvedValue({ id: '1', email: 'test@example.com' });

// 시간 모킹
jest.useFakeTimers();
jest.setSystemTime(new Date('2024-01-01'));

// 환경 변수 모킹
const originalEnv = process.env;
beforeEach(() => { process.env = { ...originalEnv, API_KEY: 'test-key' }; });
afterEach(() => { process.env = originalEnv; });`}
  language="typescript"
  filename="모킹 패턴"
/>

### 레이어별 커버리지 목표

| 레이어 | 목표 커버리지 |
|--------|-------------|
| Domain Layer | > 90% |
| Application Layer | > 80% |
| Presentation Layer | > 70% |
| Infrastructure Layer | > 60% |

---

## Documentation 스킬 상세

4가지 문서 유형(REST API, JSDoc/Docstring, README, ADR)의 생성을 지원합니다.

### 4가지 문서 유형

| 유형 | 대상 | 출력 형식 |
|------|------|----------|
| REST API | 엔드포인트 | Request/Response 스키마, 에러 코드, cURL 예시 |
| JSDoc/Docstring | 함수/클래스 | TypeScript JSDoc, Python Docstring |
| README | 프로젝트 | 배지, Quick Start, 구조, 환경 변수 |
| ADR | 아키텍처 결정 | Context, Decision, Alternatives, Consequences |

### REST API 문서 예시

<CodeBlock
  code={`## Create User
POST /api/v1/users

### Request Headers
| Header | Required | Description |
|--------|----------|-------------|
| Authorization | Yes | Bearer token |
| Content-Type | Yes | application/json |

### Request Body
{
  "email": "user@example.com",
  "name": "John Doe",
  "role": "user"
}

### Response (201 Created)
{
  "id": "usr_123abc",
  "email": "user@example.com",
  "name": "John Doe",
  "createdAt": "2024-01-01T00:00:00Z"
}

### Error Responses
| Status | Code | Description |
|--------|------|-------------|
| 400 | VALIDATION_ERROR | Invalid request body |
| 409 | DUPLICATE_EMAIL | Email already exists |
| 401 | UNAUTHORIZED | Missing or invalid token |`}
  language="markdown"
  filename="REST API 문서 예시"
/>

### JSDoc 예시

<CodeBlock
  code={`/**
 * Creates a new user account.
 *
 * This function validates the input data, checks for duplicate emails,
 * and creates a new user in the database.
 *
 * @param data - The user creation data
 * @param options - Optional configuration
 * @returns The created user object
 *
 * @throws {ValidationError} When email format is invalid
 * @throws {DuplicateError} When email already exists
 *
 * @example
 * const user = await createUser({
 *   email: 'user@example.com',
 *   name: 'John Doe'
 * });
 *
 * @see {@link updateUser} for updating existing users
 * @since 1.0.0
 */
async function createUser(
  data: CreateUserInput,
  options?: CreateUserOptions
): Promise<User> { ... }`}
  language="typescript"
  filename="JSDoc 문서 예시"
/>

### ADR (Architecture Decision Record) 예시

<CodeBlock
  code={`# ADR-001: Use PostgreSQL as Primary Database

## Status
Accepted

## Context
복잡한 관계형 데이터 모델, 트랜잭션 지원, JSON 데이터 타입, 전문 검색 기능 필요

## Considered Alternatives
### MySQL 8
- 장점: 더 넓은 호스팅 옵션
- 단점: JSON 지원이 PostgreSQL보다 약함

### MongoDB
- 장점: 스키마 유연성
- 단점: 복잡한 조인 어려움, 트랜잭션 제한

## Decision
PostgreSQL 14+를 주 데이터베이스로 사용

## Consequences
- Positive: 강력한 ACID, 우수한 JSONB, 풍부한 확장(PostGIS 등)
- Negative: 팀 학습 필요, MySQL 대비 호스팅 비용 약간 높음`}
  language="markdown"
  filename="ADR 문서 예시"
/>

---

## Refactor 스킬 상세

7가지 리팩토링 기법과 코드 스멜 탐지 기준을 제공합니다. "테스트 존재 → 작은 단계 → 동작 보존 → 지속 검증" 4원칙을 따릅니다.

### 7가지 리팩토링 기법

| # | 기법 | 적용 시점 |
|---|------|----------|
| 1 | **함수 추출** (Extract Function) | 코드 블록이 무엇을 하는지 설명이 필요할 때 |
| 2 | **변수 추출** (Extract Variable) | 복잡한 표현식을 이해하기 어려울 때 |
| 3 | **함수 인라인** (Inline Function) | 함수 본문이 이름만큼 명확할 때 |
| 4 | **조건문 분해** (Decompose Conditional) | 복잡한 조건문이 있을 때 |
| 5 | **다형성으로 교체** (Replace Conditional with Polymorphism) | 타입별 switch/if 분기가 있을 때 |
| 6 | **매개변수 객체** (Introduce Parameter Object) | 여러 매개변수가 함께 전달될 때 |
| 7 | **보호절** (Guard Clauses) | 깊은 중첩 조건문이 있을 때 |

### Before/After 예시: 함수 추출

<CodeBlock
  code={`// Before — 하나의 함수에 모든 로직
function printOwing(invoice: Invoice) {
  let outstanding = 0;

  console.log("***********************");
  console.log("**** Customer Owes ****");
  console.log("***********************");

  for (const order of invoice.orders) {
    outstanding += order.amount;
  }

  console.log(\`name: \${invoice.customer}\`);
  console.log(\`amount: \${outstanding}\`);
}

// After — 역할별 함수 분리
function printOwing(invoice: Invoice) {
  printBanner();
  const outstanding = calculateOutstanding(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutstanding(invoice: Invoice): number {
  return invoice.orders.reduce((sum, order) => sum + order.amount, 0);
}`}
  language="typescript"
  filename="함수 추출 (Extract Function)"
/>

### Before/After 예시: 보호절

<CodeBlock
  code={`// Before — 깊은 중첩
function getPayAmount(employee: Employee): number {
  let result: number;
  if (employee.isSeparated) {
    result = separatedAmount();
  } else {
    if (employee.isRetired) {
      result = retiredAmount();
    } else {
      result = normalPayAmount();
    }
  }
  return result;
}

// After — 보호절로 평탄화
function getPayAmount(employee: Employee): number {
  if (employee.isSeparated) return separatedAmount();
  if (employee.isRetired) return retiredAmount();
  return normalPayAmount();
}`}
  language="typescript"
  filename="보호절 (Guard Clauses)"
/>

### 코드 스멜 탐지 기준

| 카테고리 | 스멜 | 기준 | 리팩토링 기법 |
|----------|------|------|-------------|
| 함수 | Long Method | 20줄 이상 | Extract Function |
| 함수 | Long Parameter List | 3개 이상 | Parameter Object |
| 함수 | Duplicate Code | 동일 코드 반복 | Extract Function |
| 클래스 | Large Class | 너무 많은 책임 | Extract Class |
| 클래스 | Feature Envy | 다른 클래스 데이터 과다 접근 | Move Method |
| 조건문 | Complex Conditional | 복잡한 if/switch | Decompose Conditional |
| 조건문 | Nested Conditionals | 깊은 중첩 | Guard Clauses |
| 조건문 | Type Code | 타입별 분기 | Polymorphism |

### 리팩토링 프로세스

<MermaidDiagram
  chart={`flowchart LR
    subgraph S1["1. 분석"]
      A1["코드 스멜 식별"]
      A2["영향 범위 파악"]
    end
    subgraph S2["2. 준비"]
      B1["테스트 통과 확인"]
      B2["안전 커밋 생성"]
    end
    subgraph S3["3. 실행"]
      C1["작은 단위 변경"]
      C2["변경마다 테스트"]
    end
    subgraph S4["4. 검증"]
      D1["전체 테스트 실행"]
      D2["코드 리뷰 요청"]
    end
    S1 --> S2 --> S3 --> S4
    style S1 fill:#fdf2ee,stroke:#2563eb,color:#2d2a26
    style S2 fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style S3 fill:#fdf2ee,stroke:#9333ea,color:#2d2a26
    style S4 fill:#fdf2ee,stroke:#16a34a,color:#2d2a26`}
  title="리팩토링 프로세스"
  caption="분석 → 준비 → 실행 → 검증. 각 단계마다 테스트로 안전성을 확보합니다"
  maxWidth="680px"
/>

---

## Security Scan 스킬 상세

OWASP Top 10 기반으로 6가지 주요 취약점 패턴을 탐지합니다. 각 취약점에 대해 **취약한 코드 vs 안전한 코드** 패턴을 비교합니다.

### OWASP Top 10 체크리스트

[OWASP Top 10:2025](https://owasp.org/Top10/2025/)는 웹 애플리케이션의 가장 치명적인 보안 위험 10가지를 정의합니다.

| 순위 | 취약점 (OWASP 2025) | 검사 내용 |
|------|--------|----------|
| A01 | 접근 제어 취약점 (Broken Access Control) | 권한 검증, 직접 객체 참조 |
| A02 | 보안 설정 오류 (Security Misconfiguration) | 기본 설정, 불필요한 기능 |
| A03 | 소프트웨어 공급망 취약점 (Supply Chain Failures) | 의존성 스캔, lock 파일, 서드파티 검증 |
| A04 | 암호화 실패 (Cryptographic Failures) | 평문 저장, 약한 알고리즘 |
| A05 | 인젝션 (Injection) | SQL, NoSQL, OS, LDAP 인젝션 |
| A06 | 불안전한 설계 (Insecure Design) | 위협 모델링, 보안 패턴 |
| A07 | 인증 실패 (Authentication Failures) | 세션 관리, 비밀번호 정책 |
| A08 | 소프트웨어/데이터 무결성 실패 (Integrity Failures) | 서명 검증, 데이터 무결성 |
| A09 | 로깅 및 알림 실패 (Logging & Alerting Failures) | 감사 로그, 알림 |
| A10 | 예외 처리 미흡 (Mishandling Exceptional Conditions) | 에러 핸들링, fail-open 방지 |

### 취약한 코드 vs 안전한 코드

<CodeBlock
  code={`// ❌ SQL Injection — 문자열 직접 결합
const query = \`SELECT * FROM users WHERE id = \${userId}\`;

// ✅ 안전 — 파라미터화된 쿼리
const query = 'SELECT * FROM users WHERE id = $1';
const result = await db.query(query, [userId]);

// ❌ XSS — innerHTML 직접 삽입
element.innerHTML = userInput;

// ✅ 안전 — textContent 또는 DOMPurify
element.textContent = userInput;
element.innerHTML = DOMPurify.sanitize(userInput);

// ❌ 인증 — 평문 비밀번호, localStorage에 JWT
const hash = md5(password);
localStorage.setItem('token', jwtToken);

// ✅ 안전 — bcrypt + httpOnly 쿠키
const hash = await bcrypt.hash(password, 12);
res.cookie('token', jwtToken, {
  httpOnly: true, secure: true, sameSite: 'strict'
});

// ❌ IDOR — 권한 검사 없이 직접 접근
app.get('/api/orders/:id', async (req, res) => {
  const order = await Order.findById(req.params.id);
  return res.json(order);
});

// ✅ 안전 — 소유권 확인
app.get('/api/orders/:id', authenticate, async (req, res) => {
  const order = await Order.findOne({
    _id: req.params.id, userId: req.user.id
  });
  if (!order) return res.status(404).json({ error: 'Not found' });
  return res.json(order);
});`}
  language="typescript"
  filename="취약한 코드 vs 안전한 코드 패턴"
/>

### 보안 스캔 3단계 프로세스

| 단계 | 내용 |
|------|------|
| 1. 정적 분석 | 코드 패턴 검사, 하드코딩된 시크릿 탐지, 취약한 함수 사용, 의존성 취약점 |
| 2. 데이터 흐름 분석 | 사용자 입력 추적, 신뢰 경계 식별, 데이터 검증/이스케이프 확인 |
| 3. 설정 검토 | 보안 헤더, CORS 정책, 인증/세션 설정, 암호화 설정 |

---

## SKILL.md 프론트매터 전체 옵션

SKILL.md 파일의 YAML 프론트매터에서 사용 가능한 전체 옵션입니다.

<CodeBlock
  code={`---
name: my-skill                      # 스킬 식별자 (선택, 미지정 시 디렉토리명 사용)
description: 스킬 설명               # Claude 자동 매칭에 사용 (권장)
context: fork                       # fork: 독립 서브에이전트로 실행 (선택)
model: sonnet                       # 사용할 모델 (opus, sonnet, haiku)
allowed-tools: Bash, Read           # 허용 도구 제한
disable-model-invocation: true      # Claude 자동 호출 차단
user-invocable: false               # 사용자 수동 호출 차단
argument-hint: "[issue-number]"     # 자동완성 시 인자 힌트
---`}
  language="yaml"
  filename="SKILL.md 프론트매터 전체 옵션"
/>

<ComparisonTable
  headers={['옵션', '타입', '기본값', '설명']}
  rows={[
    { feature: 'name', values: ['string', '(선택)', '스킬 식별자. 미지정 시 디렉토리명 사용. /name으로 호출'] },
    { feature: 'description', values: ['string', '(권장)', 'Claude 자동 매칭에 사용되는 설명. 미지정 시 본문 첫 단락 사용'] },
    { feature: 'argument-hint', values: ['string', '없음', '자동완성 시 인자 형식 힌트 (예: [issue-number])'] },
    { feature: 'context', values: ['"fork" | 없음', '없음', 'fork 시 독립 서브에이전트로 실행'] },
    { feature: 'model', values: ['string', '(상속)', '사용할 모델 (opus/sonnet/haiku)'] },
    { feature: 'allowed-tools', values: ['string', '모든 도구', '스킬 활성 시 허용할 도구 제한'] },
    { feature: 'disable-model-invocation', values: ['boolean', 'false', 'true면 사용자만 호출 가능'] },
    { feature: 'user-invocable', values: ['boolean', 'true', 'false면 Claude만 자동 호출 가능'] },
  ]}
/>

## context: fork — 서브에이전트 격리 실행

`context: fork`를 설정하면 스킬이 **독립된 서브에이전트**로 실행됩니다. 메인 세션의 컨텍스트를 보존하면서 무거운 작업을 분리 실행할 수 있습니다.

<CodeBlock
  code={`---
name: deep-review
description: 전체 코드베이스 심층 리뷰
context: fork
model: opus
---

# Deep Code Review

전체 코드베이스를 분석하고 아키텍처, 보안, 성능 관점에서 종합 리포트를 생성합니다.

## 수행 절차
1. 프로젝트 구조 분석
2. 각 모듈별 코드 품질 평가
3. 보안 취약점 스캔
4. 성능 병목 식별
5. 종합 리포트 생성`}
  language="markdown"
  filename=".claude/skills/deep-review/SKILL.md"
/>

<Callout type="tip" title="context: fork를 사용하면">
  메인 세션의 컨텍스트 윈도우를 소비하지 않습니다. 대규모 분석 작업에서 특히 유용합니다.
</Callout>

## Lifecycle Hooks (스킬 내 Hook 정의)

스킬 내부에서 Lifecycle Hook을 정의하여 스킬 실행 전후에 자동 작업을 수행할 수 있습니다.

<CodeBlock
  code={`---
name: deploy
description: 프로덕션 배포
disable-model-invocation: true
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/pre-deploy-check.sh"
  Stop:
    - hooks:
        - type: command
          command: "echo 'Deploy completed at $(date)' >> deploy.log"
---

# Production Deploy

배포 전 셸 명령 실행 시 자동으로 사전 점검을 수행하고,
스킬 종료 시 배포 로그를 기록합니다.`}
  language="yaml"
  filename=".claude/skills/deploy/SKILL.md"
/>

<Callout type="warning" title="위험한 스킬은 disable-model-invocation: true 필수">
  deploy 같은 위험한 스킬은 반드시 disable-model-invocation: true를 설정하여 사용자가 명시적으로만 호출할 수 있도록 하세요.
</Callout>

---

## 스킬 호출 제어

스킬의 프론트매터로 누가 호출할 수 있는지 제어합니다:

| 프론트매터 | 사용자 호출 | Claude 자동 호출 | 설명 |
|-----------|:---------:|:--------------:|------|
| (기본값) | O | O | description이 항상 컨텍스트에 포함 |
| `disable-model-invocation: true` | O | X | 수동 호출만 허용 |
| `user-invocable: false` | X | O | Claude만 자동 호출 가능 |

<CodeBlock
  code={`---
name: deploy-production
description: Deploy to production environment
disable-model-invocation: true
---

# Production Deploy
이 스킬은 반드시 /deploy-production으로 직접 호출해야 합니다.
Claude가 임의로 실행하지 않습니다.`}
  language="markdown"
  filename=".claude/skills/deploy-production/SKILL.md"
/>

## 스킬 커스터마이징

<CodeBlock
  code={`# .claude/skills/code-review/SKILL.md 커스터마이징 예시

## 추가 체크리스트
- [ ] 접근성 (a11y) 검사
- [ ] 국제화 (i18n) 검사
- [ ] 성능 벤치마크 기준 충족

## 팀 특화 규칙
- React 컴포넌트는 Storybook 스토리 필수
- API 엔드포인트는 OpenAPI 스펙 업데이트 필수`}
  language="markdown"
  filename="스킬 커스터마이징"
/>

<Callout type="tip" title="Claude Code에서 스킬 실행">
  Claude Code v2.1.3 이후 `.claude/commands/`와 `.claude/skills/` 디렉토리가 통합되어,
  어느 디렉토리든 마크다운 파일을 두면 `/파일명`으로 호출할 수 있습니다.
  프론트매터에 `context: fork`를 추가하면 독립된 서브에이전트로 실행됩니다.
</Callout>

<ChapterNav
  prev={{ title: '문서 템플릿', path: '/docs/part-2--프로젝트-설정-문서-템플릿' }}
  next={{ title: '프롬프트 엔지니어링', path: '/docs/part-3--핵심-기능-프롬프트-엔지니어링' }}
/>
