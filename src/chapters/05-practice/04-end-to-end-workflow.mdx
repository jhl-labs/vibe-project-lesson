import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { Timeline } from '../../components/Timeline';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/E2E 워크플로우" />

# End-to-End 워크플로우

> 요구사항부터 PR 머지까지, Claude Code로 전체 개발 사이클 수행하기

## 시나리오

기존 Express.js API 프로젝트에 **"사용자 프로필 이미지 업로드"** 기능을 추가하는 실전 워크플로우입니다. Part 1에서 배운 프롬프트 기법, Part 3의 워크플로우 도구들, Part 4의 MCP 통합을 모두 활용합니다.

<MermaidDiagram
  chart={`flowchart LR
    A["1. 요구사항\n분석"] --> B["2. 설계\n(Plan Mode)"]
    B --> C["3. 구현"]
    C --> D["4. 테스트"]
    D --> E["5. 코드 리뷰"]
    E --> F["6. PR 생성"]
    style A fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style F fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="End-to-End 워크플로우 6단계"
  caption="예시 워크플로우: Explore → Plan → Implement → Commit"
/>

---

## 전체 개발 라이프사이클 개요

실무에서의 개발 라이프사이클은 단순히 코드를 작성하는 것 이상입니다. Claude Code는 **각 단계에 최적화된 프롬프트 전략**을 통해 전체 사이클을 가속합니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph Planning["계획 단계"]
      A1["요구사항 수집"] --> A2["기술 스펙 작성"]
      A2 --> A3["아키텍처 설계"]
      A3 --> A4["작업 분할"]
    end
    subgraph Development["개발 단계"]
      B1["환경 설정"] --> B2["핵심 로직 구현"]
      B2 --> B3["통합 테스트"]
      B3 --> B4["코드 리뷰"]
    end
    subgraph Delivery["배포 단계"]
      C1["CI/CD 파이프라인"] --> C2["스테이징 배포"]
      C2 --> C3["프로덕션 배포"]
      C3 --> C4["모니터링"]
    end
    subgraph Maintenance["유지보수 단계"]
      D1["장애 감지"] --> D2["근본 원인 분석"]
      D2 --> D3["핫픽스 배포"]
      D3 --> D4["회고 & 개선"]
    end
    Planning --> Development
    Development --> Delivery
    Delivery --> Maintenance
    Maintenance -->|"피드백 루프"| Planning
    style Planning fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style Development fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style Delivery fill:#f0fff0,stroke:#4CAF50,color:#2d2a26
    style Maintenance fill:#fff8f0,stroke:#FF9800,color:#2d2a26`}
  title="전체 개발 라이프사이클"
  caption="계획 → 개발 → 배포 → 유지보수의 순환 구조에서 Claude Code 활용"
/>

<ComparisonTable
  title="라이프사이클 단계별 Claude Code 활용 전략"
  headers={['단계', '주요 활동', 'Claude Code 활용법']}
  rows={[
    { feature: '요구사항 분석', values: ['스펙 정의, 엣지 케이스 발견', '인터뷰 패턴으로 빠진 요구사항 발굴'] },
    { feature: '설계', values: ['아키텍처 결정, API 스펙', 'Plan Mode에서 수정 없이 설계 검토'] },
    { feature: '구현', values: ['코드 작성, 리팩토링', '단계별 분할 구현 + 자동 검증'] },
    { feature: '테스트', values: ['단위/통합/E2E 테스트', '테스트 케이스 나열 방식으로 커버리지 극대화'] },
    { feature: '배포', values: ['CI/CD, 인프라 설정', 'Headless Mode로 파이프라인 자동화'] },
    { feature: '모니터링', values: ['로그 분석, 알림 설정', '장애 로그 분석 및 핫픽스 생성'] },
  ]}
/>

---

## 1단계: 요구사항 분석 (Explore)

먼저 기존 코드베이스를 탐색하여 현재 구조를 파악합니다.

<CodeBlock
  code={`# 인터뷰 패턴: Claude에게 질문을 먼저 받기
> 사용자 프로필 이미지 업로드 기능을 추가하려고 해.
> 구현을 시작하기 전에 내가 결정해야 할 사항들을 질문해줘.

# Claude의 질문 예시:
# 1. 이미지 저장소: 로컬 파일 시스템 vs S3 vs CloudFlare R2?
# 2. 이미지 크기 제한과 허용 포맷은?
# 3. 리사이즈/썸네일 생성이 필요한가?
# 4. 기존 User 모델에 profileImageUrl 필드를 추가하면 되는가?
# 5. 인증된 사용자만 업로드 가능한가?

# 개발자 답변 후 → Claude가 스펙 정리`}
  language="text"
  filename="1단계: 요구사항 인터뷰"
/>

<CodeBlock
  code={`# 서브에이전트로 코드베이스 탐색 (메인 컨텍스트 보존)
> 서브에이전트를 사용해서 현재 프로젝트의 파일 업로드 관련 코드가 있는지,
> User 모델 구조는 어떤지, 인증 미들웨어는 어떻게 구현되어 있는지 조사해줘.`}
  language="text"
  filename="서브에이전트로 탐색"
/>

<Callout type="tip" title="컨텍스트 보존 전략">
  탐색을 서브에이전트에 위임하면 메인 세션의 컨텍스트가 깨끗하게 유지됩니다.
  탐색 결과만 요약되어 돌아오므로 이후 구현 단계에서 컨텍스트가 부족해지는 문제를 방지합니다.
</Callout>

### 요구사항 분석 심화: 비기능 요구사항 발굴

기능 요구사항만으로는 부족합니다. Claude Code에게 **비기능 요구사항**도 함께 발굴하게 합니다.

<CodeBlock
  code={`# 비기능 요구사항 발굴 프롬프트
> 이 기능의 비기능 요구사항도 정리해줘.
> 다음 관점에서 검토해:
> - 성능: 동시 업로드 처리량, 응답 시간 목표
> - 보안: 파일 검증, 접근 제어, 악성 파일 차단
> - 확장성: 사용자 증가 시 스토리지 전략
> - 가용성: S3 장애 시 폴백 전략
> - 운영: 로깅, 모니터링 메트릭, 알람 기준

# Claude 출력 예시:
# 성능: 10MB 이하 이미지 3초 이내 업로드 완료
# 보안: magic bytes 검증, 바이러스 스캔 연동 고려
# 확장성: CDN 배포로 정적 자산 분리
# 가용성: 업로드 실패 시 3회 재시도 + 사용자 알림
# 운영: 업로드 성공/실패 비율 대시보드`}
  language="text"
  filename="비기능 요구사항 발굴"
/>

---

## 2단계: 설계 (Plan Mode)

`Shift+Tab`을 2회 눌러 Plan Mode에 진입합니다 (Normal → Auto-accept → **Plan Mode**). Plan Mode에서는 Claude가 파일을 수정하지 않고 **읽기와 계획만** 수행합니다.

<CodeBlock
  code={`# Plan Mode 진입 후
> 다음 요구사항으로 구현 계획을 세워줘:
> - S3에 이미지 저장 (aws-sdk v3 사용)
> - 최대 5MB, JPEG/PNG/WebP만 허용
> - Sharp로 200x200 썸네일 생성
> - User 모델에 profileImageUrl 필드 추가
> - 인증된 사용자만 업로드 가능
> - 기존 auth 미들웨어 패턴을 따를 것

# Claude의 계획 출력 예시:
# 1. 새 파일: src/infrastructure/storage/s3-client.ts
# 2. 새 파일: src/application/user/upload-avatar.use-case.ts
# 3. 수정: src/domain/user/entity.ts (profileImageUrl 필드 추가)
# 4. 수정: User 모델에 profileImageUrl 필드 추가
# 5. 새 파일: src/presentation/api/users/upload-avatar.ts
# 6. 새 파일: src/__tests__/upload-avatar.test.ts

# 계획 승인 후 Shift+Tab 2회로 구현 모드로 전환`}
  language="text"
  filename="2단계: Plan Mode에서 설계"
/>

<Callout type="info" title="Plan Mode 활용 팁">
  - **확장 사고(Extended Thinking)**: 기본적으로 **활성화**되어 있으며, 필요 시 설정이나 토글(Alt+T)로 끌 수 있습니다 ([Anthropic Docs](https://platform.claude.com/docs/en/build-with-claude/extended-thinking)).
  - **계획 저장**: 복잡한 기능은 계획을 별도 마크다운 파일로 저장하면 세션 간 참조 가능
  - **위험도 매칭**: 고위험 변경(DB 스키마, 인증)은 Plan Mode에서 충분히 검토한 후 구현
</Callout>

---

## 3단계: 구현 (Implement)

계획이 승인되면 단계별로 구현합니다.

<CodeBlock
  code={`# 3-1. 도메인 레이어 수정
> 계획의 1단계를 실행해줘. User 엔터티에 profileImageUrl 필드를 추가해줘.

# 3-2. 인프라 레이어 구현
> S3 클라이언트를 구현해줘. 기존 src/infrastructure/ 패턴을 따르고,
> 환경 변수로 버킷명과 리전을 설정할 수 있게 해줘.

# 3-3. 유스케이스 구현
> 이미지 업로드 유스케이스를 구현해줘.
> - 파일 크기 5MB 제한
> - JPEG, PNG, WebP만 허용
> - Sharp로 200x200 썸네일 생성
> - 원본과 썸네일 모두 S3에 저장
> 구현 후 테스트를 실행해줘.

# 3-4. API 라우터 구현
> @src/presentation/api/users/ 패턴을 따라 업로드 엔드포인트를 추가해줘.
> multer로 multipart/form-data를 처리하고, 기존 authMiddleware를 사용해.`}
  language="text"
  filename="3단계: 단계별 구현 프롬프트"
/>

<Callout type="warning" title="검증 수단을 항상 포함하세요">
  각 단계에서 "구현 후 테스트를 실행해줘"를 포함하면 Claude가 **자기 검증 루프(self-verification loop)**를 수행합니다. Anthropic 문서는 테스트 실행을 통한 검증을 꾸준히 권장합니다.
</Callout>

### Claude가 생성하는 것

각 단계에서 Claude는 기존 프로젝트 패턴에 맞춰 파일을 생성/수정합니다:
- **Domain**: User 엔터티에 `profileImageUrl` 필드 추가
- **Infrastructure**: S3 클라이언트 — 환경 변수로 버킷/리전 설정
- **Application**: `UploadAvatarUseCase` — 파일 검증 → 썸네일 생성 → S3 업로드 → DB 업데이트
- **Presentation**: multer로 multipart/form-data 처리하는 API 엔드포인트

"구현 후 테스트를 실행해줘"가 포함된 단계에서는 Claude가 자동으로 테스트를 돌리고, 실패하면 수정합니다.

---

## 4단계: 테스트

<CodeBlock
  code={`# 테스트 작성 요청 (구체적으로!)
> upload-avatar.use-case.ts의 테스트를 작성해줘.
> 다음 케이스를 커버해:
> 1. 정상 업로드 (JPEG 1MB)
> 2. 파일 크기 초과 (6MB)
> 3. 허용하지 않는 파일 타입 (GIF)
> 4. S3 업로드 실패 시 에러 처리
> 5. 썸네일이 200x200으로 생성되는지
>
> S3Client는 mock하고, sharp은 실제 동작을 테스트해.
> 테스트 작성 후 실행까지 해줘.`}
  language="text"
  filename="4단계: 테스트 작성 프롬프트"
/>

<Callout type="tip" title="테스트 프롬프트 작성법">
  테스트 케이스를 **번호로 나열**하면 Claude가 빠뜨리지 않습니다. "테스트를 작성해줘"보다 "다음 5개 케이스를 커버해줘"가 훨씬 정확한 결과를 만듭니다.
</Callout>

---

## 5단계: 코드 리뷰 (새 세션)

Writer/Reviewer 패턴으로 새 세션에서 리뷰합니다.

<CodeBlock
  code={`# 새 터미널/세션에서 리뷰
> git diff main 의 변경사항을 리뷰해줘. 다음을 중점적으로 확인해:
> 1. 보안: 파일 업로드 시 취약점 (파일명 인젝션, MIME 위장 등)
> 2. 에러 처리: 모든 실패 경로가 적절히 처리되는지
> 3. 성능: 대용량 파일 처리 시 메모리 이슈가 없는지
> 4. 테스트 커버리지: 엣지 케이스가 충분히 커버되는지`}
  language="text"
  filename="5단계: 새 세션에서 코드 리뷰"
/>

<Callout type="info" title="Writer/Reviewer 패턴">
  구현한 세션과 **다른 세션**에서 리뷰하면, 새로운 컨텍스트의 Claude가
  구현 과정의 편향 없이 객관적으로 코드를 평가합니다.
  이 패턴은 Anthropic 공식 블로그와 커뮤니티에서 널리 권장됩니다.
</Callout>

### 리뷰에서 자주 발견되는 이슈

<ComparisonTable
  title="파일 업로드 보안 점검 항목"
  headers={['취약점', '위험', '대응 방법']}
  rows={[
    { feature: 'MIME 위장', values: ['확장자를 바꿔 실행 파일 업로드', 'magic bytes 검증 (file-type 라이브러리)'] },
    { feature: '파일명 인젝션', values: ['../../ 경로로 디렉토리 탐색', 'UUID로 파일명 생성, 원본 파일명 미사용'] },
    { feature: '무제한 업로드', values: ['디스크/메모리 고갈', 'multer limits 설정 (5MB)'] },
    { feature: '미인증 접근', values: ['누구나 이미지 업로드', 'authMiddleware 필수 적용'] },
  ]}
/>

---

## 6단계: PR 생성

<CodeBlock
  code={`# 리뷰 반영 후 커밋 & PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.
> PR 설명에 다음을 포함해:
> - 기능 요약
> - 변경된 파일 목록과 이유
> - 테스트 방법
> - AI 사용 내역

# Claude가 자동으로:
# 1. git add & commit (Conventional Commits 형식)
# 2. git push
# 3. gh pr create (GitHub CLI)`}
  language="text"
  filename="6단계: PR 생성"
/>

---

## 전체 프롬프트 요약

<ComparisonTable
  title="단계별 핵심 프롬프트 패턴"
  headers={['단계', '핵심 기법', '목적']}
  rows={[
    { feature: '1. 요구사항', values: ['인터뷰 패턴 + 서브에이전트 탐색', '정확한 스펙 확정 + 컨텍스트 보존'] },
    { feature: '2. 설계', values: ['Plan Mode (Shift+Tab)', '코드 수정 없이 계획만 수립'] },
    { feature: '3. 구현', values: ['단계별 분할 + 검증 포함', '각 단계를 독립적으로 검증'] },
    { feature: '4. 테스트', values: ['구체적 테스트 케이스 번호 나열', '엣지 케이스까지 커버'] },
    { feature: '5. 리뷰', values: ['Writer/Reviewer 패턴', '편향 없는 객관적 리뷰'] },
    { feature: '6. PR', values: ['AI 사용 내역 포함', '투명한 AI 활용 기록'] },
  ]}
/>

---

## 실전 시나리오 1: 스타트업 MVP 개발 전 과정

스타트업에서 3주 안에 SaaS MVP를 Claude Code로 개발하는 전체 과정입니다. 실제 스타트업들이 Claude Code를 도입하여 개발 속도를 극적으로 높이고 있는 사례를 기반으로 합니다.

<Timeline
  events={[
    { title: 'Week 1: 기획 & 설계', description: '요구사항 정의, DB 스키마, API 스펙, 와이어프레임' },
    { title: 'Week 2: 핵심 기능 구현', description: '인증, 핵심 도메인 로직, API 엔드포인트, 프론트엔드 기본 UI' },
    { title: 'Week 3: 품질 & 배포', description: '테스트, 보안 리뷰, CI/CD 설정, 스테이징/프로덕션 배포' },
  ]}
/>

### Week 1: 기획 & 설계

<CodeBlock
  code={`# === Day 1-2: 요구사항 정의 ===

# 제품 요구사항 문서(PRD) 초안 생성
> 다음 SaaS 제품의 PRD를 작성해줘:
> - 제품명: TaskFlow (프로젝트 관리 도구)
> - 핵심 기능: 칸반보드, 태스크 관리, 팀원 초대, 실시간 알림
> - 타겟 사용자: 10-50명 규모의 스타트업 팀
> - 기술 스택: Next.js, Prisma, PostgreSQL, Redis
> - MVP 범위: 회원가입/로그인, 프로젝트 생성, 칸반보드, 태스크 CRUD
>
> PRD에 각 기능의 우선순위(P0/P1/P2)와 수락 기준(Acceptance Criteria)을 포함해줘.

# === Day 3-4: DB 스키마 설계 ===

# Plan Mode에서 DB 스키마 설계
> 다음 요구사항으로 Prisma 스키마를 설계해줘 (수정하지 말고 계획만):
> - User: 이메일 인증, OAuth (Google), 프로필
> - Workspace: 팀 단위 격리, 멤버 역할 (owner, admin, member)
> - Project: 워크스페이스 내 프로젝트, 칸반 컬럼 설정
> - Task: 제목, 설명, 담당자, 상태, 우선순위, 마감일
> - 인덱싱 전략과 관계 설정도 포함해줘

# === Day 5: API 스펙 ===

> 설계된 스키마를 기반으로 RESTful API 스펙을 작성해줘.
> OpenAPI 3.0 형식으로, 인증/인가 정책을 포함해.
> MVP 범위의 엔드포인트만 포함해 (P0 기능만).`}
  language="text"
  filename="MVP Week 1: 기획 & 설계 프롬프트"
/>

### Week 2: 핵심 기능 구현

<CodeBlock
  code={`# === Day 6-7: 프로젝트 초기화 & 인증 ===

> Next.js 프로젝트를 초기화하고 다음을 설정해줘:
> - Prisma + PostgreSQL 연동
> - NextAuth.js로 이메일/Google OAuth 인증
> - 미들웨어로 보호 라우트 설정
> - 환경 변수 템플릿 (.env.example)
> 설정 후 개발 서버가 정상 실행되는지 확인해줘.

# === Day 8-10: 핵심 도메인 로직 ===

# Agent Teams로 병렬 구현
> Agent Teams를 사용해서 다음 기능을 병렬로 구현해줘:
> Teammate 1: Workspace CRUD + 멤버 초대/역할 관리 API
> Teammate 2: Project CRUD + 칸반 컬럼 관리 API
> Teammate 3: Task CRUD + 상태 변경/담당자 할당 API
> Teammate 4: 프론트엔드 레이아웃 + 라우팅 + 공통 컴포넌트
>
> 모든 API는 인증 미들웨어를 거쳐야 하고,
> 워크스페이스 격리(tenant isolation)를 지켜야 해.
> 각 팀원은 구현 후 테스트를 실행해줘.

# === Day 11-12: 칸반보드 UI ===

> @app/(dashboard)/projects/[id]/board/page.tsx 에 칸반보드 UI를 구현해줘.
> - @hello-pangea/dnd 또는 dnd-kit으로 드래그 앤 드롭
> - 컬럼: To Do, In Progress, Done (커스터마이징 가능)
> - 태스크 카드: 제목, 담당자 아바타, 우선순위 배지, 마감일
> - 낙관적 업데이트(optimistic update)로 즉각 반응
> - 모바일에서는 스크롤로 컬럼 이동`}
  language="text"
  filename="MVP Week 2: 핵심 기능 구현 프롬프트"
/>

### Week 3: 품질 & 배포

<CodeBlock
  code={`# === Day 13-14: 테스트 ===

> 다음 테스트를 작성하고 실행해줘:
> 1. API 단위 테스트: 모든 유스케이스 (인증, 워크스페이스, 프로젝트, 태스크)
> 2. API 통합 테스트: 실제 DB를 사용한 전체 플로우
> 3. 프론트엔드 컴포넌트 테스트: 칸반보드 드래그 앤 드롭
> 4. E2E 테스트: 회원가입 → 워크스페이스 생성 → 태스크 생성 → 상태 변경
>
> 테스트 커버리지 80% 이상을 목표로 해.

# === Day 15: 보안 리뷰 (새 세션에서) ===

> git diff main 의 전체 변경사항을 보안 관점에서 리뷰해줘:
> 1. SQL 인젝션 / XSS / CSRF 취약점
> 2. 인증/인가 우회 가능성
> 3. 환경 변수에 시크릿 하드코딩 여부
> 4. 워크스페이스 격리 위반 (다른 팀 데이터 접근)
> 5. Rate limiting 부재 여부`}
  language="text"
  filename="MVP Week 3: 품질 & 배포 프롬프트"
/>

---

## 실전 시나리오 2: 레거시 시스템 마이그레이션

Express.js + MongoDB 기반 레거시 모놀리스를 NestJS + PostgreSQL 기반 클린 아키텍처로 마이그레이션하는 워크플로우입니다.

<MermaidDiagram
  chart={`flowchart LR
    subgraph Legacy["레거시 시스템"]
      L1["Express.js"]
      L2["MongoDB"]
      L3["모놀리식 구조"]
    end
    subgraph Migration["마이그레이션 단계"]
      M1["1. 현행 분석"]
      M2["2. 신규 설계"]
      M3["3. 점진적 이전"]
      M4["4. 데이터 마이그레이션"]
      M5["5. 검증 & 전환"]
    end
    subgraph New["신규 시스템"]
      N1["NestJS"]
      N2["PostgreSQL"]
      N3["클린 아키텍처"]
    end
    Legacy --> M1
    M1 --> M2
    M2 --> M3
    M3 --> M4
    M4 --> M5
    M5 --> New
    style Legacy fill:#fff0f0,stroke:#e74c3c,color:#2d2a26
    style Migration fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style New fill:#f0fff0,stroke:#4CAF50,color:#2d2a26`}
  title="레거시 마이그레이션 워크플로우"
  caption="레거시 분석부터 점진적 이전, 데이터 마이그레이션까지"
/>

<CodeBlock
  code={`# === 1단계: 레거시 코드 분석 ===

> 서브에이전트를 사용해서 이 프로젝트를 분석해줘:
> - 전체 파일 구조와 모듈 의존성 맵
> - MongoDB 컬렉션별 스키마 (실제 문서 구조 추론)
> - API 엔드포인트 목록과 각각의 비즈니스 로직
> - 인증/인가 방식
> - 외부 서비스 의존성 (이메일, 결제 등)
> - 기술 부채: 중복 코드, 사용되지 않는 코드, 하드코딩된 값

# === 2단계: 마이그레이션 계획 (Plan Mode) ===

> 분석 결과를 바탕으로 마이그레이션 계획을 세워줘:
> - MongoDB → PostgreSQL 스키마 매핑 (관계형으로 정규화)
> - 모놀리스 → 클린 아키텍처 레이어 분리 계획
> - API 호환성 유지 전략 (기존 클라이언트 깨지지 않게)
> - 데이터 마이그레이션 스크립트 계획
> - 점진적 전환 전략 (Strangler Fig Pattern)
> - 롤백 계획

# === 3단계: Strangler Fig 패턴으로 점진적 이전 ===

> 첫 번째 마이그레이션 대상으로 User 모듈을 이전해줘.
> 1. NestJS에 User 모듈 구현 (PostgreSQL)
> 2. API 프록시 설정: /api/users → 신규 서비스로 라우팅
> 3. 나머지 엔드포인트는 레거시로 유지
> 4. 통합 테스트로 기존 API 동작과 동일함을 검증
> 5. MongoDB → PostgreSQL 데이터 동기화 스크립트

# === 4단계: 데이터 마이그레이션 ===

> MongoDB에서 PostgreSQL로 데이터를 마이그레이션하는 스크립트를 작성해줘:
> - 배치 처리 (1000건씩)
> - 트랜잭션으로 원자성 보장
> - 실패 시 재시도 로직 (최대 3회)
> - 마이그레이션 진행 상황 로깅
> - dry-run 모드 지원
> - 검증 스크립트: 원본/대상 데이터 건수 및 무결성 비교`}
  language="text"
  filename="레거시 마이그레이션 프롬프트"
/>

<Callout type="warning" title="마이그레이션의 황금률">
  레거시 마이그레이션에서 가장 중요한 것은 **기존 동작을 절대 깨뜨리지 않는 것**입니다.
  Claude Code에게 반드시 기존 API 테스트를 먼저 작성하게 한 후, 그 테스트를 통과하는 새 구현을 만들어야 합니다.
  Strangler Fig 패턴을 사용하면 모듈 단위로 점진적으로 전환할 수 있습니다.
</Callout>

---

## CI/CD 파이프라인 통합

Claude Code의 Headless Mode(`claude -p`)를 활용하면 CI/CD 파이프라인에서 자동으로 코드 리뷰, 테스트 생성, 문서 업데이트를 수행할 수 있습니다.

### GitHub Actions 통합

<CodeBlock
  code={`# .github/workflows/claude-review.yml
name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  claude-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Claude Code
        run: curl -fsSL https://claude.ai/install.sh | bash

      - name: Run Claude Review
        env:
          ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          DIFF=$(git diff origin/main...HEAD)
          REVIEW=$(claude -p "다음 코드 변경사항을 리뷰해줘. 보안 취약점, 에러 처리 누락, 성능 이슈를 중점적으로 확인해. 개선 사항은 구체적인 코드 예시와 함께 제안해: $DIFF")
          gh pr comment \${{ github.event.pull_request.number }} --body "$REVIEW"

  claude-test-coverage:
    runs-on: ubuntu-latest
    needs: claude-review
    steps:
      - uses: actions/checkout@v4

      - name: Check Test Coverage
        env:
          ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # 변경된 파일에 대한 테스트 커버리지 확인
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD | grep -E '\\.(ts|tsx)$' | grep -v '\\.test\\.')
          claude -p "다음 파일들의 테스트 커버리지를 확인하고, 테스트가 부족한 부분에 대해 테스트 코드를 생성해줘: $CHANGED_FILES"`}
  language="yaml"
  filename=".github/workflows/claude-review.yml"
/>

### Docker 통합

<CodeBlock
  code={`# Dockerfile.claude - Claude Code가 포함된 개발 컨테이너
FROM node:20-slim

# 시스템 의존성 설치
RUN apt-get update && apt-get install -y git curl && \\
    rm -rf /var/lib/apt/lists/*

# Claude Code 설치 (네이티브 바이너리 권장)
RUN curl -fsSL https://claude.ai/install.sh | bash

# 프로젝트 설정
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

# Claude Code 설정 (CLAUDE.md 활용)
# API 키는 런타임에 환경 변수로 주입
ENV ANTHROPIC_API_KEY=""

# Headless Mode로 실행하는 엔트리포인트
ENTRYPOINT ["claude", "-p"]`}
  language="dockerfile"
  filename="Dockerfile.claude"
/>

<CodeBlock
  code={`# docker-compose.claude.yml - Claude 자동화 파이프라인
services:
  claude-review:
    build:
      context: .
      dockerfile: Dockerfile.claude
    environment:
      - ANTHROPIC_API_KEY
    volumes:
      - .:/app
    command: >
      "이 프로젝트의 최근 변경사항을 리뷰하고,
       발견된 이슈를 REVIEW.md 파일로 생성해줘."

  claude-test:
    build:
      context: .
      dockerfile: Dockerfile.claude
    environment:
      - ANTHROPIC_API_KEY
    volumes:
      - .:/app
    command: >
      "테스트 커버리지가 낮은 파일을 찾아서
       추가 테스트를 생성하고 실행해줘."

  claude-docs:
    build:
      context: .
      dockerfile: Dockerfile.claude
    environment:
      - ANTHROPIC_API_KEY
    volumes:
      - .:/app
    command: >
      "변경된 API 엔드포인트의 문서를 업데이트해줘.
       OpenAPI 스펙과 README를 최신 상태로 맞춰줘."`}
  language="yaml"
  filename="docker-compose.claude.yml"
/>

<ComparisonTable
  title="CI/CD 파이프라인 자동화 대상"
  headers={['자동화 항목', '트리거', 'Claude 프롬프트 패턴']}
  rows={[
    { feature: 'PR 코드 리뷰', values: ['PR 생성/업데이트', 'git diff를 리뷰해줘 + 보안/성능 중점'] },
    { feature: '테스트 생성', values: ['새 파일 추가 시', '변경 파일의 테스트 커버리지 확인 & 생성'] },
    { feature: 'API 문서 업데이트', values: ['API 라우터 변경 시', 'OpenAPI 스펙을 변경사항에 맞게 업데이트'] },
    { feature: '보안 스캔', values: ['매 커밋 시', '보안 취약점 점검 + 수정 방안 제시'] },
    { feature: '의존성 업데이트', values: ['주간 스케줄', '취약한 의존성 확인 + 호환성 테스트'] },
  ]}
/>

---

## 모니터링과 피드백 루프

프로덕션 배포 후에도 Claude Code는 모니터링 데이터를 분석하고 개선 포인트를 찾는 데 활용됩니다.

<MermaidDiagram
  chart={`flowchart TB
    A["프로덕션 서비스"] -->|"로그, 메트릭"| B["모니터링 시스템"]
    B -->|"이상 감지"| C["알림 발생"]
    C --> D["Claude Code로 분석"]
    D -->|"근본 원인 파악"| E["핫픽스 생성"]
    E -->|"자동 테스트"| F["CI/CD 파이프라인"]
    F -->|"배포"| A
    D -->|"패턴 분석"| G["CLAUDE.md 규칙 추가"]
    G -->|"예방"| H["다음 개발 사이클"]
    style A fill:#f0fff0,stroke:#4CAF50,color:#2d2a26
    style B fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style C fill:#fff0f0,stroke:#e74c3c,color:#2d2a26
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style F fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style G fill:#fff8f0,stroke:#FF9800,color:#2d2a26
    style H fill:#f0fff0,stroke:#4CAF50,color:#2d2a26`}
  title="모니터링 피드백 루프"
  caption="프로덕션 이상 감지 → Claude 분석 → 핫픽스 → CLAUDE.md 규칙화"
/>

<CodeBlock
  code={`# === 프로덕션 로그 분석 ===

# 에러 로그를 Claude Code로 분석 (민감 정보 제거 필수!)
> 다음 에러 로그를 분석해줘 (PII는 마스킹됨):
>
> [ERROR] 2026-02-06T14:23:45Z UploadAvatarUseCase:
> TimeoutError: S3 PutObject timed out after 30000ms
> Stack: at S3Client.send (s3-client.ts:45)
>        at UploadAvatarUseCase.execute (upload-avatar.use-case.ts:32)
>
> 최근 1시간 동안 동일 에러 47건 발생.
> 원인을 분석하고 수정 방안을 제시해줘.

# Claude 분석 예시:
# 원인: S3 리전 설정 불일치 (ap-northeast-2 → us-east-1 폴백 발생)
# 수정: 환경 변수 AWS_REGION 확인, 리전 일치 확인
# 예방: 타임아웃을 60초로 증가 + 재시도 로직 추가
# 모니터링: S3 레이턴시 메트릭 알람 설정

# === 성능 메트릭 분석 ===

> 다음 API 성능 데이터를 분석해줘:
> - POST /api/users/avatar: p50=1.2s, p95=4.8s, p99=12.3s
> - GET /api/users/profile: p50=45ms, p95=120ms, p99=350ms
> - GET /api/tasks: p50=89ms, p95=890ms, p99=2.1s
>
> 병목 지점을 식별하고, 각각에 대한 최적화 방안을 제시해줘.
> 코드 변경이 필요하면 구체적인 수정 사항을 알려줘.`}
  language="text"
  filename="프로덕션 모니터링 & 분석 프롬프트"
/>

<Callout type="warning" title="프로덕션 로그 주의사항">
  프로덕션 로그를 Claude Code에 전달할 때 반드시 **PII(개인식별정보)를 마스킹**해야 합니다.
  이메일, IP 주소, 사용자 이름, 토큰 등은 사전에 제거하거나 익명화하세요.
  이는 개인정보보호법 준수를 위해 필수적입니다.
</Callout>

---

## 장애 대응 워크플로우

프로덕션 장애가 발생했을 때 Claude Code를 활용한 체계적인 대응 워크플로우입니다.

<Timeline
  events={[
    { title: '1. 장애 감지 (0-5분)', description: '모니터링 알람 수신, 영향 범위 파악' },
    { title: '2. 근본 원인 분석 (5-15분)', description: 'Claude Code로 로그 분석, 최근 배포 변경사항 검토' },
    { title: '3. 핫픽스 개발 (15-30분)', description: '최소한의 변경으로 문제 해결, 테스트 포함' },
    { title: '4. 긴급 배포 (30-45분)', description: 'CI/CD 파이프라인으로 핫픽스 배포' },
    { title: '5. 사후 분석 (48시간 이내)', description: '포스트모템 작성, 재발 방지 대책, CLAUDE.md 규칙 추가' },
  ]}
/>

<CodeBlock
  code={`# === 장애 대응 시나리오: API 응답 시간 급증 ===

# 1단계: 빠른 상황 파악
> 프로덕션에서 API 응답 시간이 급증하고 있어.
> 다음 정보를 분석해줘:
> - 최근 배포 시점: 30분 전 (커밋 abc123)
> - 영향받는 엔드포인트: GET /api/tasks (p95: 890ms → 8.9s)
> - 영향받지 않는 엔드포인트: 나머지 모두 정상
> - DB CPU: 15% → 92%
>
> 최근 배포의 git diff를 확인하고 원인을 추정해줘.

# Claude 분석:
# 커밋 abc123에서 Task 쿼리에 N+1 문제 도입
# Task.findAll()에서 관련 User를 개별 조회 → JOIN으로 수정 필요

# 2단계: 핫픽스 생성
> 원인이 파악됐어. 핫픽스를 만들어줘:
> - Task 쿼리에 User 정보를 JOIN으로 가져오도록 수정
> - 기존 테스트가 통과하는지 확인
> - 새 테스트 추가: Task 목록 조회 시 쿼리 수가 N+1이 아닌 것을 검증
> - 커밋 메시지에 "hotfix:" 프리픽스 사용

# 3단계: 긴급 배포
> 핫픽스를 커밋하고, hotfix/fix-task-query-n-plus-one 브랜치로 PR을 생성해줘.
> PR 설명에 장애 내용, 원인, 수정 사항을 포함해.

# 4단계: 사후 분석 (포스트모템)
> 이 장애에 대한 포스트모템을 작성해줘:
> - 타임라인 (감지 → 원인 파악 → 수정 → 배포)
> - 근본 원인 (Root Cause)
> - 영향 범위
> - 수정 내용
> - 재발 방지 대책 3가지
> - CLAUDE.md에 추가할 규칙 제안`}
  language="text"
  filename="장애 대응 워크플로우 프롬프트"
/>

<Callout type="tip" title="CLAUDE.md에 장애 교훈 반영하기">
  장애 사후 분석의 핵심은 **같은 문제가 반복되지 않도록** 하는 것입니다.
  CLAUDE.md에 규칙을 추가하면 Claude Code가 향후 유사한 코드를 생성할 때 자동으로 주의합니다.
  예를 들어 `"ORM 쿼리 작성 시 반드시 N+1 문제를 점검할 것"` 같은 규칙을 추가하세요.
</Callout>

---

## 팀 협업에서의 E2E 워크플로우

여러 개발자가 Claude Code를 함께 사용할 때의 협업 패턴과 주의사항입니다.

<MermaidDiagram
  chart={`flowchart TB
    subgraph SharedConfig["공유 설정"]
      SC1["CLAUDE.md\n(프로젝트 규칙)"]
      SC2[".claude/rules/\n(코딩 컨벤션)"]
      SC3[".claude/commands/\n(팀 공용 슬래시 명령)"]
    end
    subgraph DevA["개발자 A"]
      A1["Feature 브랜치"]
      A2["Claude 세션 A"]
      A3["CLAUDE.local.md\n(개인 설정)"]
    end
    subgraph DevB["개발자 B"]
      B1["Feature 브랜치"]
      B2["Claude 세션 B"]
      B3["CLAUDE.local.md\n(개인 설정)"]
    end
    subgraph DevC["개발자 C"]
      C1["Feature 브랜치"]
      C2["Claude 세션 C"]
      C3["CLAUDE.local.md\n(개인 설정)"]
    end
    SharedConfig --> DevA
    SharedConfig --> DevB
    SharedConfig --> DevC
    A1 -->|"PR"| D["main 브랜치"]
    B1 -->|"PR"| D
    C1 -->|"PR"| D
    style SharedConfig fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style DevA fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style DevB fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style DevC fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="팀 협업 구조"
  caption="공유 설정(CLAUDE.md)은 Git으로 관리, 개인 설정(CLAUDE.local.md)은 .gitignore"
/>

### 팀 공용 슬래시 명령 만들기

<CodeBlock
  code={`# .claude/commands/review-pr.md
# 팀 공용 PR 리뷰 명령

다음 관점에서 현재 브랜치의 변경사항을 리뷰해주세요:

## 필수 확인 항목
1. **보안**: SQL 인젝션, XSS, 인증/인가 우회
2. **에러 처리**: 모든 외부 호출에 try-catch, 사용자 친화적 에러 메시지
3. **테스트**: 변경된 로직에 대한 테스트 존재 여부
4. **컨벤션**: .claude/rules/conventions.md 준수 여부
5. **성능**: N+1 쿼리, 불필요한 반복, 메모리 누수

## 출력 형식
각 항목별로 PASS/WARN/FAIL로 평가하고,
WARN 또는 FAIL인 항목은 구체적인 수정 제안을 포함해주세요.`}
  language="markdown"
  filename=".claude/commands/review-pr.md"
/>

<CodeBlock
  code={`# .claude/commands/create-feature.md
# 팀 공용 기능 개발 시작 명령

다음 절차로 새 기능 개발을 시작해주세요:

1. main 브랜치에서 feature/$ARGUMENTS 브랜치 생성
2. 요구사항에 대해 질문 (인터뷰 패턴)
3. Plan Mode에서 구현 계획 수립
4. 계획을 docs/plans/$ARGUMENTS.md로 저장
5. 구현 모드로 전환하여 단계별 구현 시작`}
  language="markdown"
  filename=".claude/commands/create-feature.md"
/>

### 팀 협업 모범 사례

<ComparisonTable
  title="팀 협업에서의 Claude Code 활용 가이드"
  headers={['상황', '권장 방법', '피해야 할 것']}
  rows={[
    { feature: 'CLAUDE.md 변경', values: ['PR로 팀 리뷰 후 머지', '개인이 임의로 규칙 변경'] },
    { feature: '개인 작업 스타일', values: ['CLAUDE.local.md 사용 (.gitignore)', 'CLAUDE.md에 개인 선호 추가'] },
    { feature: 'PR 리뷰 도구', values: ['팀 공용 /review-pr 명령 사용', '각자 다른 리뷰 프롬프트 사용'] },
    { feature: '컨텍스트 공유', values: ['docs/plans/ 에 설계 문서 저장', '구두/채팅으로만 컨텍스트 전달'] },
    { feature: 'AI 사용 표기', values: ['PR에 AI 사용 내역 명시', 'AI 사용 여부 숨기기'] },
    { feature: '장애 교훈', values: ['CLAUDE.md에 규칙으로 반영', '구두 전달 후 잊어버림'] },
  ]}
/>

---

## 실패 시 대처

<CodeBlock
  code={`# 같은 이슈로 2번 이상 실패했을 때
/clear
# 더 나은 프롬프트로 새 세션 시작

# 특정 체크포인트로 되돌리기
> 직전 작업을 취소하고 이전 상태로 돌아가줘

# 구현 중 방향이 잘못되었을 때
# Esc를 눌러 즉시 중단 → 방향 수정 후 재지시`}
  language="bash"
  filename="실패 대처 명령어"
/>

### 실패 시나리오별 대응 전략

<ComparisonTable
  title="실패 시나리오와 대응"
  headers={['상황', '증상', '대응']}
  rows={[
    { feature: '같은 에러 반복', values: ['동일 수정을 2회 이상 시도', '/clear 후 에러 메시지와 함께 새 세션 시작'] },
    { feature: '컨텍스트 소진', values: ['Claude 응답 품질 저하, 이전 내용 잊음', '/clear 후 핵심 컨텍스트만 다시 제공'] },
    { feature: '잘못된 방향', values: ['구현이 요구사항과 다른 방향으로 진행', 'Esc로 중단, Plan Mode로 전환하여 재설계'] },
    { feature: '테스트 실패', values: ['구현은 완료했으나 테스트가 통과하지 않음', '실패 로그를 복사하여 "이 테스트 실패를 수정해줘" 요청'] },
  ]}
/>

<Callout type="tip" title="Hooks 활용으로 품질 자동화">
  Part 3에서 배운 Hooks를 설정하면 이 워크플로우가 더 강력해집니다:
  - `PostToolUse` + `Edit|Write` → 자동 포맷팅 (Prettier)
  - `Stop` + `agent` → 매 응답 후 자동 테스트 실행
  - `PreToolUse` + `Bash` → 위험 명령 차단
</Callout>

---

## Agent Teams로 병렬 개발하기 (2026년 2월~)

위의 6단계 워크플로우를 **Agent Teams**로 수행하면, 독립적인 단계를 병렬로 실행하여 전체 소요 시간을 대폭 줄일 수 있습니다.

<MermaidDiagram
  chart={`flowchart TB
    A["1. 요구사항 분석\n(Team Lead)"] --> B["2. 설계\n(Team Lead - Plan Mode)"]
    B --> C1["3a. 프론트엔드 구현\n(Teammate 1)"]
    B --> C2["3b. 백엔드 구현\n(Teammate 2)"]
    B --> C3["3c. 테스트 작성\n(Teammate 3)"]
    B --> C4["3d. API 문서 작성\n(Teammate 4)"]
    C1 --> D["4. 통합 & 리뷰\n(Team Lead)"]
    C2 --> D
    C3 --> D
    C4 --> D
    D --> E["5. PR 생성"]
    style A fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C1 fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style C2 fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style C3 fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style C4 fill:#f0f4ff,stroke:#5B8DEF,color:#2d2a26
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="Agent Teams 병렬 워크플로우"
  caption="설계 완료 후 4개 팀원이 병렬로 작업하고, Team Lead가 결과를 통합합니다"
/>

### Agent Teams 워크플로우 프롬프트

<CodeBlock
  code={`# === Agent Teams로 "사용자 프로필 이미지 업로드" 병렬 개발 ===

# Team Lead에게 전체 작업 위임
> Agent Teams를 사용해서 프로필 이미지 업로드 기능을 구현해줘.
> 다음과 같이 팀을 구성해:
>
> Teammate 1 (프론트엔드): React 컴포넌트 - 이미지 선택, 미리보기, 크롭, 업로드 UI
> Teammate 2 (백엔드): Express.js API - multer, S3 업로드, Sharp 썸네일, User 모델 수정
> Teammate 3 (테스트): 단위/통합 테스트 - 프론트엔드 컴포넌트 + 백엔드 유스케이스
> Teammate 4 (문서): API 문서 + 컴포넌트 Storybook 스토리
>
> 요구사항:
> - S3에 이미지 저장 (aws-sdk v3)
> - 최대 5MB, JPEG/PNG/WebP만 허용
> - Sharp로 200x200 썸네일 생성
> - 인증된 사용자만 업로드 가능
> - 기존 프로젝트 패턴과 컨벤션을 따를 것

# Team Lead가 자동으로:
# 1. 설계 계획을 수립하고 팀원들에게 작업 할당
# 2. 각 팀원이 독립 컨텍스트에서 병렬 작업 시작
# 3. 팀원 간 인터페이스 조율 (API 스펙, 타입 정의 공유)
# 4. 결과 통합 및 충돌 해결
# 5. 최종 테스트 실행 및 리뷰`}
  language="text"
  filename="Agent Teams 병렬 개발 프롬프트"
/>

### Headless Mode 대안

Agent Teams를 사용하지 않고도 `claude -p`로 유사한 병렬 워크플로우를 구성할 수 있습니다.

<CodeBlock
  code={`#!/bin/bash
# headless-parallel-dev.sh — 병렬 개발 스크립트

echo "=== 병렬 개발 시작 ==="

# 백엔드와 프론트엔드를 병렬로 구현
claude -p "src/infrastructure/storage/ 에 S3 클라이언트를 구현해줘. aws-sdk v3 사용." &
PID1=$!

claude -p "src/components/avatar/ 에 이미지 업로드 React 컴포넌트를 구현해줘." &
PID2=$!

claude -p "src/application/user/ 에 UploadAvatar 유스케이스를 구현해줘." &
PID3=$!

# 모든 작업 완료 대기
wait $PID1 $PID2 $PID3

echo "=== 병렬 구현 완료, 통합 테스트 시작 ==="

# 통합 후 테스트 실행
claude -p "방금 추가된 이미지 업로드 기능의 통합 테스트를 작성하고 실행해줘."`}
  language="bash"
  filename="Headless Mode 병렬 개발 스크립트"
/>

<Callout type="info" title="Agent Teams vs Headless Mode">
  **Agent Teams**: 에이전트들이 자율적으로 협력하고 통신. 복잡한 상호 의존 작업에 적합.
  **Headless Mode** (`claude -p`): 독립적인 작업을 단순 병렬 실행. CI/CD, 스크립트 자동화에 적합.
  두 방식은 상호 보완적이며, 프로젝트 상황에 맞게 선택합니다.
</Callout>

### 실제 성과 사례

Anthropic과 기업들이 공개한 Agent Teams / 병렬 Claude Code 활용 사례:

<ComparisonTable
  title="Agent Teams 실증 사례"
  headers={['사례', '규모', '성과']}
  rows={[
    { feature: 'C 컴파일러 구축 (Anthropic)', values: ['16 에이전트, 약 2,000 세션, $20K 비용', '100K줄 Rust 코드, Linux 6.9 컴파일, 컴파일러 테스트 스위트 99% 통과 ([블로그](https://www.anthropic.com/engineering/building-c-compiler))'] },
    { feature: 'Ramp (핀테크)', values: ['30일간 엔지니어링팀 적용, 50% 주간 채택', '100만줄+ AI 코드, 인시던트 조사 시간 최대 80% 단축 ([사례](https://claude.com/customers/ramp))'] },
    { feature: 'Anthropic 보안팀 내부', values: ['일상 업무 적용', '스택 트레이스 분석 + 런북 자동 생성으로 인시던트 대응 가속 ([출처](https://claude.com/blog/how-anthropic-teams-use-claude-code))'] },
    { feature: 'Anthropic 마케팅팀', values: ['광고 자동화', '수백 개 광고 변형 생성 수시간 → 수분 (서브에이전트 파이프라인) ([출처](https://claude.com/blog/how-anthropic-teams-use-claude-code))'] },
  ]}
/>

---

## 각 단계별 상세 프롬프트 전략

개발 라이프사이클의 각 단계에서 Claude Code의 성능을 극대화하기 위한 상세 프롬프트 전략입니다.

### 요구사항 분석 단계 프롬프트

<CodeBlock
  code={`# 1. 사용자 스토리 생성
> 다음 기능에 대한 사용자 스토리를 작성해줘:
> 기능: 팀원 초대 및 권한 관리
> 형식: "As a [역할], I want to [행동], so that [이유]"
> 각 스토리에 수락 기준(Acceptance Criteria)을 포함해.
> 엣지 케이스도 별도 스토리로 작성해줘.

# 2. 기술적 제약사항 분석
> 현재 프로젝트의 기술적 제약사항을 분석해줘:
> - Node.js 버전 호환성
> - 기존 ORM과의 호환성
> - 현재 인증 시스템과의 통합 가능성
> - 성능 병목이 될 수 있는 지점

# 3. 의존성 영향 분석
> 이 기능을 추가할 때 영향받는 기존 코드를 모두 찾아줘.
> 파일 경로, 함수명, 변경 이유를 포함해서 목록으로 정리해줘.`}
  language="text"
  filename="요구사항 분석 상세 프롬프트"
/>

### 설계 단계 프롬프트

<CodeBlock
  code={`# 1. 아키텍처 결정 기록 (ADR) 생성
> 다음 결정에 대한 ADR을 작성해줘:
> 제목: 이미지 저장소로 S3 선택
> 배경: 프로필 이미지 업로드 기능 추가 필요
> 고려한 옵션: 로컬 파일 시스템, S3, CloudFlare R2
> 결정: S3
> 근거: 확장성, CDN 통합 용이성, 팀 내 경험
> 결과: aws-sdk v3 의존성 추가, IAM 설정 필요

# 2. API 인터페이스 설계
> RESTful API 인터페이스를 설계해줘:
> - 엔드포인트 URL, HTTP 메서드
> - 요청/응답 바디 (TypeScript 타입)
> - 에러 응답 형식 (상태 코드별)
> - 인증/인가 요구사항
> - Rate limiting 정책

# 3. 시퀀스 다이어그램
> 이미지 업로드 플로우의 시퀀스 다이어그램을 Mermaid로 그려줘.
> 클라이언트 → API → 유스케이스 → S3 → DB 순서로.`}
  language="text"
  filename="설계 단계 상세 프롬프트"
/>

### 구현 단계 프롬프트

<CodeBlock
  code={`# 1. 점진적 구현 (레이어별)
> 도메인 레이어부터 구현을 시작해줘.
> 각 레이어 완료 후:
> - 타입 체크를 실행해줘 (tsc --noEmit)
> - 해당 레이어의 단위 테스트를 실행해줘
> - 다음 레이어로 넘어가기 전에 결과를 보여줘

# 2. 기존 패턴 참조
> @src/application/user/update-profile.use-case.ts 패턴을 참조해서
> 동일한 구조로 upload-avatar.use-case.ts를 구현해줘.
> 다른 점은 파일 처리 로직이 추가된다는 것뿐이야.

# 3. 에러 처리 전략
> 에러 처리를 다음 전략으로 구현해줘:
> - 도메인 에러: 비즈니스 규칙 위반 (InvalidFileTypeError 등)
> - 인프라 에러: S3 연결 실패 등 (재시도 포함)
> - 프레젠테이션 에러: HTTP 상태 코드로 매핑
> 각 에러 클래스를 src/shared/errors/ 에 구현해줘.`}
  language="text"
  filename="구현 단계 상세 프롬프트"
/>

### 테스트 단계 프롬프트

<CodeBlock
  code={`# 1. 테스트 피라미드 전략
> 다음 테스트 피라미드 전략으로 테스트를 작성해줘:
>
> 단위 테스트 (70%):
> - UploadAvatarUseCase: 5개 케이스 (정상, 크기 초과, 타입 오류, S3 실패, 썸네일)
> - User 엔터티: 3개 케이스 (profileImageUrl 업데이트, 유효성 검증)
> - S3Client: 3개 케이스 (업로드, 삭제, 존재 확인)
>
> 통합 테스트 (20%):
> - API 엔드포인트: 4개 케이스 (정상, 미인증, 잘못된 요청, 서버 에러)
>
> E2E 테스트 (10%):
> - 전체 플로우: 로그인 → 이미지 선택 → 업로드 → 프로필 확인

# 2. 테스트 데이터 관리
> 테스트용 이미지 파일을 생성하는 헬퍼 함수를 만들어줘:
> - createTestImage(format, sizeKB): Buffer 생성
> - createOversizedImage(): 6MB 이미지
> - createInvalidFile(): 실행 파일로 위장한 파일

# 3. 테스트 실행 & 커버리지 확인
> 모든 테스트를 실행하고, 커버리지 리포트를 보여줘.
> 커버리지가 80% 미만인 파일이 있으면 추가 테스트를 작성해줘.`}
  language="text"
  filename="테스트 단계 상세 프롬프트"
/>

### 배포 단계 프롬프트

<CodeBlock
  code={`# 1. 환경별 설정 확인
> 다음 환경별 설정이 올바른지 확인해줘:
> - development: 로컬 MinIO (S3 호환)
> - staging: S3 스테이징 버킷
> - production: S3 프로덕션 버킷 + CloudFront CDN
>
> .env.example에 필요한 환경 변수가 모두 있는지 확인하고,
> 누락된 것이 있으면 추가해줘.

# 2. 마이그레이션 스크립트 확인
> DB 마이그레이션이 안전한지 확인해줘:
> - 롤백 가능한가?
> - 다운타임 없이 적용 가능한가?
> - 기존 데이터에 영향이 없는가?

# 3. 배포 체크리스트 생성
> 이번 배포의 체크리스트를 생성해줘:
> - 환경 변수 설정 여부
> - DB 마이그레이션 실행 순서
> - S3 버킷/IAM 설정 완료 여부
> - 롤백 계획
> - 모니터링 대시보드 확인 항목`}
  language="text"
  filename="배포 단계 상세 프롬프트"
/>

---

## 실습: 전체 워크플로우 직접 해보기

아래 프롬프트를 순서대로 Claude Code에 입력하여 전체 워크플로우를 체험합니다.

<CodeBlock
  code={`# === 실습 시나리오: 기존 API에 "비밀번호 변경" 기능 추가 ===

# 1단계: 요구사항 인터뷰
> 사용자 비밀번호 변경 기능을 추가하려고 해.
> 구현 전에 내가 결정해야 할 사항들을 질문해줘.

# (Claude의 질문에 답변: 현재 비밀번호 확인 필요, bcrypt 사용,
#  최소 8자, 최근 3개 비밀번호 재사용 금지)

# 2단계: 설계 (Shift+Tab 2회로 Plan Mode 진입)
> 다음 요구사항으로 구현 계획을 세워줘:
> - 현재 비밀번호 확인 후 변경
> - bcrypt로 해싱
> - 최소 8자, 대소문자+숫자+특수문자 포함
> - 최근 3개 비밀번호 재사용 금지
> - 변경 후 이메일 알림 발송

# 3단계: 구현 (Shift+Tab 2회로 구현 모드)
> 계획을 실행해줘. Domain Layer부터 시작해서
> 각 레이어를 순서대로 구현해줘.
> 각 단계마다 테스트를 실행해줘.

# 4단계: 테스트
> 다음 케이스를 커버하는 테스트를 작성하고 실행해줘:
> 1. 정상 비밀번호 변경
> 2. 현재 비밀번호 불일치
> 3. 새 비밀번호가 정책 미충족 (8자 미만, 특수문자 없음 등)
> 4. 최근 3개 비밀번호 재사용 시도
> 5. 미인증 사용자 접근

# 5단계: 리뷰 (새 세션에서)
> git diff main 의 변경사항을 리뷰해줘.
> 보안, 에러 처리, 테스트 커버리지를 중점 확인해.

# 6단계: PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.`}
  language="text"
  filename="실습: 비밀번호 변경 기능 전체 워크플로우"
/>

---

## 실습: 프론트엔드 워크플로우 직접 해보기

백엔드 시나리오와 별도로, 프론트엔드 기능을 처음부터 구현하는 워크플로우입니다.

<CodeBlock
  code={`# === 실습 시나리오: React 대시보드에 "알림 센터" 추가 ===

# 1단계: 요구사항 인터뷰
> 대시보드 헤더에 알림 센터(벨 아이콘 + 드롭다운)를 추가하려고 해.
> 구현 전에 내가 결정해야 할 사항들을 질문해줘.

# (Claude 질문 예시: 실시간 vs 폴링, 읽음/안읽음 구분,
#  알림 타입, 최대 표시 개수, 알림 클릭 시 동작)

# 2단계: 타입 먼저 정의 (Plan Mode)
> 다음 요구사항으로 타입과 구현 계획을 세워줘:
> - 알림 타입: info, warning, error, success
> - 읽음/안읽음 상태
> - 최대 50개, 오래된 순 자동 삭제
> - 벨 아이콘에 안읽은 알림 수 배지
> - 드롭다운에 알림 목록, "모두 읽음" 버튼

# 3단계: 구현
> @src/types/dashboard.ts 에 NotificationProps 타입을 추가하고,
> @src/components/dashboard/StatCard.tsx 패턴을 따라
> NotificationBell 컴포넌트를 구현해줘.
> useNotifications 커스텀 훅도 만들어줘.
> 구현 후 테스트를 실행해줘.

# 4단계: 테스트
> 다음 케이스를 커버하는 테스트를 작성하고 실행해줘:
> 1. 알림이 없을 때 배지 숨김
> 2. 안읽은 알림 수 배지 표시
> 3. 벨 클릭 시 드롭다운 토글
> 4. 알림 클릭 시 읽음 처리
> 5. "모두 읽음" 클릭 시 전체 읽음
> 6. 키보드 접근성 (Enter로 토글, Esc로 닫기)

# 5단계: 리뷰 (새 세션에서)
> git diff main 의 변경사항을 리뷰해줘.
> 접근성, 메모리 누수(이벤트 리스너 cleanup), 상태 관리를 중점 확인해.

# 6단계: PR 생성
> 변경사항을 커밋하고 PR을 생성해줘.`}
  language="text"
  filename="실습: 알림 센터 기능 전체 워크플로우"
/>

<Callout type="info" title="프론트엔드 워크플로우 특징">
  백엔드와 동일한 6단계지만 프론트엔드만의 차이가 있습니다:
  - **타입 먼저**: props 인터페이스를 먼저 정의하면 구현이 정확해집니다
  - **기존 패턴 참조**: `@` 기호로 기존 컴포넌트를 참조하여 일관성 유지
  - **접근성 필수**: 키보드 내비게이션, aria 속성, 스크린 리더 지원을 테스트에 포함
  - **cleanup 검증**: 이벤트 리스너, 타이머, 구독 등의 정리를 리뷰에서 확인
</Callout>

---

## E2E 워크플로우 종합 체크리스트

프로젝트에서 E2E 워크플로우를 적용할 때 참조할 수 있는 종합 체크리스트입니다.

<ComparisonTable
  title="E2E 워크플로우 종합 체크리스트"
  headers={['단계', '체크 항목', '자동화 가능 여부']}
  rows={[
    { feature: '요구사항', values: ['인터뷰 패턴 사용, 비기능 요구사항 포함, 엣지 케이스 식별', '부분 자동화 (인터뷰 템플릿)'] },
    { feature: '설계', values: ['Plan Mode 사용, ADR 작성, API 스펙 정의, 시퀀스 다이어그램', '부분 자동화 (계획 템플릿)'] },
    { feature: '구현', values: ['레이어별 분할, 기존 패턴 참조, 검증 포함, 에러 처리', '높은 자동화 (Agent Teams)'] },
    { feature: '테스트', values: ['테스트 피라미드, 구체적 케이스 나열, 커버리지 80%+', '높은 자동화 (CI/CD)'] },
    { feature: '리뷰', values: ['Writer/Reviewer 패턴, 보안/성능/품질 체크', '높은 자동화 (팀 명령어)'] },
    { feature: '배포', values: ['환경별 설정, 마이그레이션 안전성, 롤백 계획, 모니터링', '완전 자동화 (CI/CD)'] },
    { feature: '유지보수', values: ['로그 분석, 성능 메트릭, 장애 대응, 포스트모템', '부분 자동화 (알람 연동)'] },
  ]}
/>

<Callout type="tip" title="워크플로우 개선의 핵심">
  E2E 워크플로우는 한 번 만들고 끝나는 것이 아닙니다.
  매 프로젝트 사이클마다 **회고(retrospective)**를 통해 워크플로우를 개선하세요.
  장애에서 배운 교훈, 반복되는 실수 패턴, 효과적이었던 프롬프트를
  CLAUDE.md와 팀 공용 명령어에 반영하면 팀 전체의 생산성이 지속적으로 향상됩니다.
</Callout>

<ChapterNav
  prev={{ title: '프론트엔드 프로젝트', path: '/docs/part-5--실전-예제-프론트엔드-프로젝트' }}
  next={{ title: '보안', path: '/docs/part-6--거버넌스-보안' }}
/>
