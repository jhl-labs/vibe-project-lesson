import { Meta } from '@storybook/addon-docs/blocks';
import { Callout } from '../../components/Callout';
import { CodeBlock } from '../../components/CodeBlock';
import { FileTree } from '../../components/FileTree';
import { ComparisonTable } from '../../components/ComparisonTable';
import { MermaidDiagram } from '../../components/MermaidDiagram';
import { ChapterNav } from '../../components/ChapterNav';

<Meta title="Part 5: 실전 예제/Python API" />

# Python API 예제

> TypeScript API와 동일한 아키텍처를 Python으로 구현하며, Clean Architecture가 언어에 독립적임을 체험하기

앞 챕터에서 TypeScript로 만든 Clean Architecture API를 이번에는 **Python(FastAPI)으로 동일하게 구현**합니다. 두 결과를 비교하면서 "언어와 프레임워크는 다르지만 아키텍처 원칙은 같다"는 것을 직접 확인합니다.

## 완성 목표

<MermaidDiagram
  chart={`flowchart TB
    A["HTTP Request"] --> B["Presentation Layer\n(FastAPI Router)"]
    B --> C["Application Layer\n(Use Case)"]
    C --> D["Domain Layer\n(Entity + Protocol)"]
    C --> E["Infrastructure Layer\n(SQLAlchemy Repository)"]
    E --> F["SQLite / PostgreSQL"]
    style D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style C fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style B fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style E fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="Python Clean Architecture 레이어 구조"
  caption="의존성 방향: Presentation -> Application -> Domain <- Infrastructure"
/>

6개의 실습을 순서대로 진행하면 위 구조의 API가 완성됩니다. 각 실습은 **하나의 프롬프트**로 이루어지며, `pip install -r requirements.txt && uvicorn app.main:app --reload`만으로 실행 가능합니다.

---

## API 요청 처리 흐름

<MermaidDiagram
  chart={`sequenceDiagram
    participant C as Client
    participant R as FastAPI Router
    participant M as Middleware
    participant U as UseCase
    participant D as Domain Entity
    participant Repo as Repository
    participant DB as SQLite DB

    C->>R: POST /api/users
    R->>M: 요청 검증 (Pydantic)
    M->>R: 검증 통과
    R->>U: CreateUserUseCase.execute()
    U->>Repo: find_by_email() 중복 확인
    Repo->>DB: SELECT query
    DB-->>Repo: None (중복 없음)
    Repo-->>U: None
    U->>D: User.create() 엔터티 생성
    D-->>U: User 인스턴스
    U->>Repo: save(user)
    Repo->>DB: INSERT query
    DB-->>Repo: OK
    Repo-->>U: 완료
    U-->>R: UserResponseDto
    R-->>C: 201 Created + JSON`}
  title="API 요청 처리 시퀀스"
  caption="각 레이어가 자신의 책임만 수행하고, 다음 레이어에 위임합니다"
/>

---

## 최종 프로젝트 구조

<FileTree
  title="examples/python-api/"
  data={[
    {
      name: 'app/',
      type: 'folder',
      children: [
        { name: 'main.py', type: 'file', description: 'FastAPI 앱 엔트리포인트' },
        {
          name: 'domain/',
          type: 'folder',
          description: '비즈니스 로직 (순수, 의존성 없음)',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'entity.py', type: 'file', description: 'User 엔터티 (@dataclass)' },
                { name: 'repository.py', type: 'file', description: 'Repository Protocol' },
                { name: 'exceptions.py', type: 'file', description: '도메인 예외 클래스' },
              ],
            },
          ],
        },
        {
          name: 'application/',
          type: 'folder',
          description: '유스케이스',
          highlight: true,
          children: [
            {
              name: 'user/',
              type: 'folder',
              children: [
                { name: 'use_cases.py', type: 'file', description: '유스케이스' },
                { name: 'dtos.py', type: 'file', description: 'DTO (frozen dataclass)' },
              ],
            },
          ],
        },
        {
          name: 'infrastructure/',
          type: 'folder',
          children: [
            {
              name: 'database/',
              type: 'folder',
              children: [
                { name: 'models.py', type: 'file', description: 'SQLAlchemy ORM 모델' },
                { name: 'repository.py', type: 'file', description: 'Repository 구현체' },
                { name: 'migrations/', type: 'folder', description: 'Alembic 마이그레이션' },
              ],
            },
          ],
        },
        {
          name: 'presentation/',
          type: 'folder',
          children: [
            {
              name: 'api/',
              type: 'folder',
              children: [
                { name: 'users.py', type: 'file', description: 'API 라우터' },
                { name: 'deps.py', type: 'file', description: '의존성 주입 팩토리' },
              ],
            },
            {
              name: 'schemas/',
              type: 'folder',
              children: [
                { name: 'user.py', type: 'file', description: 'Pydantic v2 스키마' },
              ],
            },
            {
              name: 'middleware/',
              type: 'folder',
              children: [
                { name: 'error_handler.py', type: 'file', description: '전역 예외 핸들러' },
                { name: 'request_logger.py', type: 'file', description: '요청 로깅' },
              ],
            },
          ],
        },
        {
          name: 'core/',
          type: 'folder',
          children: [
            { name: 'config.py', type: 'file', description: 'pydantic-settings 환경 설정' },
            { name: 'database.py', type: 'file', description: 'SQLAlchemy async 엔진' },
          ],
        },
      ],
    },
    {
      name: 'tests/',
      type: 'folder',
      children: [
        { name: 'conftest.py', type: 'file', description: 'pytest 픽스처 (DB, Client)' },
        { name: 'test_user_entity.py', type: 'file', description: '엔터티 단위 테스트' },
        { name: 'test_create_user.py', type: 'file', description: '유스케이스 단위 테스트' },
        { name: 'test_api_integration.py', type: 'file', description: 'API 통합 테스트' },
        { name: 'factories.py', type: 'file', description: '테스트 팩토리 함수' },
      ],
    },
    { name: 'alembic.ini', type: 'file', description: 'Alembic 설정' },
    { name: 'requirements.txt', type: 'file' },
    { name: 'Dockerfile', type: 'file' },
    { name: 'docker-compose.yml', type: 'file' },
    { name: '.env.example', type: 'file' },
  ]}
/>

<Callout type="tip" title="SQLite로 간편하게">
  이 프로젝트는 `aiosqlite`로 SQLite를 사용합니다. Docker나 별도 DB 설치 없이 `pip install -r requirements.txt && uvicorn app.main:app --reload`만으로 바로 시작할 수 있습니다. 프로덕션에서는 Alembic 마이그레이션과 함께 PostgreSQL로 전환합니다.
</Callout>

---

## 실습 1: CLAUDE.md 작성 + 프로젝트 초기화

<CodeBlock
  code={`CLAUDE.md를 생성해줘. 내용은 다음과 같아:
- 프로젝트: FastAPI + SQLAlchemy + pytest 기반 Clean Architecture API
- DB: SQLite (aiosqlite), 프로덕션에서는 PostgreSQL 전환 가능
- 아키텍처: domain/ → application/ → infrastructure/ → presentation/
- domain은 외부 의존성 금지, application은 domain Protocol만 의존
- 파일명 snake_case, 클래스 PascalCase
- 테스트: pytest + AsyncMock, httpx로 통합 테스트
- Pydantic v2 사용, model_config로 설정
- 에러 처리: 커스텀 도메인 예외 → FastAPI HTTPException 변환`}
  language="text"
  filename="프롬프트 1-1: CLAUDE.md 생성"
/>

<CodeBlock
  code={`FastAPI + SQLAlchemy + pytest 프로젝트를 초기화해줘.
Clean Architecture 구조로 다음 디렉토리를 생성해:
- app/domain/user/
- app/application/user/
- app/infrastructure/database/
- app/presentation/api/
- app/presentation/schemas/
- app/presentation/middleware/
- app/core/
- tests/

requirements.txt에 다음을 포함해:
fastapi, uvicorn[standard], sqlalchemy[asyncio],
aiosqlite, pydantic-settings, pydantic[email],
pytest, pytest-asyncio, httpx, alembic

.env.example도 생성해줘.`}
  language="text"
  filename="프롬프트 1-2: 프로젝트 초기화"
/>

### Claude가 생성하는 것

- `requirements.txt` -- FastAPI, SQLAlchemy, pytest 등 의존성 목록
- `app/core/config.py` -- `pydantic-settings` 기반 환경 설정 (`DATABASE_URL`, `DEBUG`)
- `app/core/database.py` -- SQLAlchemy async 엔진 + 세션 팩토리
- `.env.example` -- 환경 변수 템플릿
- 위 FileTree에 표시된 디렉토리 구조 (`__init__.py` 포함)

### 여기서 배우는 것

<Callout type="info" title="Python에서의 환경 설정">
  TypeScript에서는 `dotenv`로 환경 변수를 읽었지만, Python에서는 **`pydantic-settings`**가 `.env` 파일 로딩 + 타입 검증을 한 번에 처리합니다. `Settings` 클래스에 `database_url: str`을 선언하면, 환경 변수가 없을 때 타입 에러로 알려줍니다.
</Callout>

<CodeBlock
  code={`# app/core/config.py
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """애플리케이션 설정.

    환경 변수 또는 .env 파일에서 자동 로딩됩니다.
    """
    database_url: str = "sqlite+aiosqlite:///./app.db"
    debug: bool = False
    app_name: str = "Python Clean API"
    api_prefix: str = "/api"

    model_config = {
        "env_file": ".env",
        "env_file_encoding": "utf-8",
    }


settings = Settings()`}
  language="python"
  filename="app/core/config.py - pydantic-settings 기반 환경 설정"
/>

<Callout type="tip" title="TypeScript dotenv와의 차이">
  TypeScript에서는 `process.env.DATABASE_URL`을 문자열로 읽고 수동으로 타입을 변환했습니다. Python의 `pydantic-settings`는 **타입 선언만으로 자동 변환과 검증**이 이루어집니다. `debug: bool`로 선언하면 환경 변수 `"true"` 문자열이 자동으로 `True`로 변환됩니다.
</Callout>

---

## 실습 2: Domain Layer -- Python 스타일의 비즈니스 로직

<CodeBlock
  code={`app/domain/user/ 아래에 다음을 구현해줘:
1. entity.py: User 데이터클래스
   - @dataclass, create() 클래스메서드 (이메일 정규식 검증, 소문자 변환)
   - activate/deactivate 상태 전이 (pending→active→inactive)
   - 상태 전이 위반 시 InvalidStateTransitionError 발생
2. repository.py: UserRepository Protocol (find_by_id, find_by_email, save)
3. exceptions.py: 도메인 예외 클래스들
   - DomainError (기본), InvalidEmailError, DuplicateEmailError,
     UserNotFoundError, InvalidStateTransitionError

외부 라이브러리 없이 Python 표준 라이브러리만 사용해.`}
  language="text"
  filename="프롬프트 2: Domain Layer"
/>

### Claude가 생성하는 것

- **`entity.py`** -- `@dataclass`로 정의된 `User` 엔터티. TypeScript의 `class`와 역할은 같지만, Python의 `@dataclass`는 `__init__`, `__eq__` 등을 자동 생성
- **`repository.py`** -- `Protocol` 클래스로 정의된 `UserRepository`. TypeScript의 `interface`에 해당
- **`exceptions.py`** -- 계층 구조를 가진 도메인 예외 클래스들

### 여기서 배우는 것

<Callout type="info" title="Protocol vs Interface -- 같은 목적, 다른 방식">
  TypeScript는 `interface IUserRepository`로 계약을 정의하고, 구현체가 `implements`를 명시합니다.

  Python의 `Protocol`은 **구조적 서브타이핑(structural subtyping)**을 사용합니다. `implements` 키워드 없이, 메서드 시그니처만 일치하면 자동으로 호환됩니다. 이것이 Python의 **duck typing** 철학입니다: "오리처럼 걷고 꽥꽥거리면, 오리다."

  **두 방식 모두** Domain이 인터페이스를 정의하고 Infrastructure가 구현한다는 핵심 원칙은 동일합니다.
</Callout>

<CodeBlock
  code={`# app/domain/user/entity.py
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
import re
import uuid


class UserStatus(str, Enum):
    PENDING = "pending"
    ACTIVE = "active"
    INACTIVE = "inactive"


def _utc_now() -> datetime:
    return datetime.now(timezone.utc)


@dataclass
class User:
    id: str
    email: str
    name: str
    status: UserStatus = UserStatus.PENDING
    created_at: datetime = field(default_factory=_utc_now)

    # 이메일 정규식: Domain이 정의하는 비즈니스 규칙
    _EMAIL_REGEX = re.compile(
        r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$"
    )

    @classmethod
    def create(cls, email: str, name: str) -> "User":
        """팩토리 메서드: 검증을 거쳐 User를 생성합니다."""
        email_lower = email.strip().lower()

        if not cls._EMAIL_REGEX.match(email_lower):
            from app.domain.user.exceptions import InvalidEmailError
            raise InvalidEmailError(email)

        if not name or not name.strip():
            raise ValueError("Name cannot be empty")

        return cls(
            id=str(uuid.uuid4()),
            email=email_lower,
            name=name.strip(),
        )

    def activate(self) -> None:
        """pending -> active 상태 전이."""
        if self.status != UserStatus.PENDING:
            from app.domain.user.exceptions import InvalidStateTransitionError
            raise InvalidStateTransitionError(
                self.status.value, UserStatus.ACTIVE.value
            )
        self.status = UserStatus.ACTIVE

    def deactivate(self) -> None:
        """active -> inactive 상태 전이."""
        if self.status != UserStatus.ACTIVE:
            from app.domain.user.exceptions import InvalidStateTransitionError
            raise InvalidStateTransitionError(
                self.status.value, UserStatus.INACTIVE.value
            )
        self.status = UserStatus.INACTIVE`}
  language="python"
  filename="app/domain/user/entity.py - @dataclass 기반 엔터티"
/>

<CodeBlock
  code={`# app/domain/user/repository.py
from typing import Optional, Protocol

from app.domain.user.entity import User


class UserRepository(Protocol):
    """Repository 계약 (Protocol = 구조적 서브타이핑).

    이 Protocol을 만족하는 클래스는
    'implements' 키워드 없이도 자동으로 호환됩니다.
    """

    async def find_by_id(self, user_id: str) -> Optional[User]: ...

    async def find_by_email(self, email: str) -> Optional[User]: ...

    async def save(self, user: User) -> None: ...

    async def find_all(
        self, skip: int = 0, limit: int = 100
    ) -> list[User]: ...`}
  language="python"
  filename="app/domain/user/repository.py - Protocol 기반 인터페이스"
/>

<CodeBlock
  code={`# app/domain/user/exceptions.py


class DomainError(Exception):
    """모든 도메인 예외의 기본 클래스."""

    def __init__(self, message: str, code: str = "DOMAIN_ERROR"):
        self.message = message
        self.code = code
        super().__init__(self.message)


class InvalidEmailError(DomainError):
    def __init__(self, email: str):
        super().__init__(
            message=f"Invalid email format: {email}",
            code="INVALID_EMAIL",
        )


class DuplicateEmailError(DomainError):
    def __init__(self, email: str):
        super().__init__(
            message=f"Email already exists: {email}",
            code="DUPLICATE_EMAIL",
        )


class UserNotFoundError(DomainError):
    def __init__(self, user_id: str):
        super().__init__(
            message=f"User not found: {user_id}",
            code="USER_NOT_FOUND",
        )


class InvalidStateTransitionError(DomainError):
    def __init__(self, current: str, target: str):
        super().__init__(
            message=f"Cannot transition from {current} to {target}",
            code="INVALID_STATE_TRANSITION",
        )`}
  language="python"
  filename="app/domain/user/exceptions.py - 계층적 도메인 예외"
/>

<Callout type="tip" title="확인 포인트">
  생성된 `entity.py`의 `import` 목록을 확인해보세요. `dataclasses`, `re`, `uuid`만 있고, FastAPI나 SQLAlchemy 같은 외부 패키지가 없어야 합니다. TypeScript Domain Layer와 같은 원칙입니다.
</Callout>

<Callout type="info" title="ABC vs Protocol -- 어떤 것을 선택할까?">
  Python에서 인터페이스를 정의하는 방법은 두 가지입니다:

  - **`ABC` (Abstract Base Class)**: `from abc import ABC, abstractmethod`를 사용하며, 구현체가 명시적으로 상속해야 합니다. Java의 `abstract class`와 유사합니다.
  - **`Protocol`**: `from typing import Protocol`을 사용하며, 메서드 시그니처만 일치하면 됩니다. Go의 인터페이스와 유사합니다.

  Clean Architecture에서는 **Protocol을 권장**합니다. Infrastructure 레이어가 Domain을 상속(import)하지 않아도 되므로 의존성 방향이 더 깔끔합니다.
</Callout>

---

## 실습 3: Application Layer -- 유스케이스 흐름

<CodeBlock
  code={`app/application/user/ 아래에 유스케이스를 구현해줘:
1. dtos.py: CreateUserDto, UserResponseDto (frozen=True 데이터클래스)
   - UserResponseDto에 from_entity() 클래스메서드 포함
2. use_cases.py: CreateUserUseCase, GetUserUseCase, ListUsersUseCase
   - 생성자에서 UserRepository Protocol을 주입받음
   - 이메일 중복 체크 → User.create() → save → DTO 반환
   - 도메인 예외를 그대로 전파 (Application에서 변환하지 않음)`}
  language="text"
  filename="프롬프트 3: Application Layer"
/>

### Claude가 생성하는 것

- **`dtos.py`** -- `frozen=True`로 불변 보장된 데이터클래스들. TypeScript의 `readonly`와 동일한 목적
- **`use_cases.py`** -- `CreateUserUseCase`, `GetUserUseCase`, `ListUsersUseCase`. TypeScript 버전과 흐름이 거의 동일

### 여기서 배우는 것

<Callout type="info" title="TypeScript와 비교해보세요">
  TypeScript의 `create-user.ts`와 Python의 `use_cases.py`를 나란히 열어보면, **비즈니스 흐름이 거의 1:1로 대응**됩니다:

  1. `find_by_email` -- 중복 확인
  2. `User.create()` -- 엔터티 생성
  3. `save()` -- 영속화
  4. `from_entity()` -- DTO 변환

  언어 문법은 다르지만 유스케이스의 구조는 동일합니다. 이것이 Clean Architecture가 **언어 독립적**이라는 의미입니다.
</Callout>

<CodeBlock
  code={`# app/application/user/dtos.py
from dataclasses import dataclass

from app.domain.user.entity import User


@dataclass(frozen=True)
class CreateUserDto:
    """사용자 생성 입력 DTO (불변)."""
    email: str
    name: str


@dataclass(frozen=True)
class UserResponseDto:
    """사용자 응답 DTO (불변)."""
    id: str
    email: str
    name: str
    status: str
    created_at: str

    @classmethod
    def from_entity(cls, user: User) -> "UserResponseDto":
        """Domain 엔터티 -> 응답 DTO 변환."""
        return cls(
            id=user.id,
            email=user.email,
            name=user.name,
            status=user.status.value,
            created_at=user.created_at.isoformat(),
        )`}
  language="python"
  filename="app/application/user/dtos.py - 불변 DTO"
/>

<CodeBlock
  code={`# app/application/user/use_cases.py
from app.domain.user.entity import User
from app.domain.user.exceptions import (
    DuplicateEmailError,
    UserNotFoundError,
)
from app.domain.user.repository import UserRepository

from .dtos import CreateUserDto, UserResponseDto


class CreateUserUseCase:
    """사용자 생성 유스케이스.

    흐름: 중복 확인 -> 엔터티 생성 -> 저장 -> DTO 반환
    """

    def __init__(self, user_repository: UserRepository) -> None:
        self._repo = user_repository

    async def execute(self, dto: CreateUserDto) -> UserResponseDto:
        # 1. 이메일 중복 확인
        existing = await self._repo.find_by_email(dto.email.lower())
        if existing is not None:
            raise DuplicateEmailError(dto.email)

        # 2. 도메인 엔터티 생성 (비즈니스 검증 포함)
        user = User.create(email=dto.email, name=dto.name)

        # 3. 영속화
        await self._repo.save(user)

        # 4. 응답 DTO로 변환
        return UserResponseDto.from_entity(user)


class GetUserUseCase:
    """사용자 조회 유스케이스."""

    def __init__(self, user_repository: UserRepository) -> None:
        self._repo = user_repository

    async def execute(self, user_id: str) -> UserResponseDto:
        user = await self._repo.find_by_id(user_id)
        if user is None:
            raise UserNotFoundError(user_id)
        return UserResponseDto.from_entity(user)


class ListUsersUseCase:
    """사용자 목록 조회 유스케이스."""

    def __init__(self, user_repository: UserRepository) -> None:
        self._repo = user_repository

    async def execute(
        self, skip: int = 0, limit: int = 100
    ) -> list[UserResponseDto]:
        users = await self._repo.find_all(skip=skip, limit=limit)
        return [UserResponseDto.from_entity(u) for u in users]`}
  language="python"
  filename="app/application/user/use_cases.py - 유스케이스 구현"
/>

<ComparisonTable
  title="UseCase 구현 비교: TypeScript vs Python"
  headers={['단계', 'TypeScript', 'Python']}
  rows={[
    { feature: '중복 확인', values: ['await this.userRepository.findByEmail(dto.email)', 'await self._repo.find_by_email(dto.email)'] },
    { feature: '엔터티 생성', values: ['User.create({ email, name })', 'User.create(email=dto.email, name=dto.name)'] },
    { feature: '영속화', values: ['await this.userRepository.save(user)', 'await self._repo.save(user)'] },
    { feature: 'DTO 변환', values: ['UserResponseDto.fromEntity(user)', 'UserResponseDto.from_entity(user)'] },
    { feature: '에러 처리', values: ['throw new EmailAlreadyExistsError()', 'raise DuplicateEmailError(dto.email)'] },
  ]}
/>

---

## 실습 4: Infrastructure Layer -- SQLAlchemy 저장소

<CodeBlock
  code={`app/infrastructure/database/ 아래에 구현해줘:
1. models.py: SQLAlchemy UserModel (id, email, name, status 컬럼)
   - mapped_column과 Mapped 타입 사용 (SQLAlchemy 2.0 스타일)
2. user_repository.py: SQLAlchemyUserRepository
   - AsyncSession을 생성자로 주입
   - UserRepository Protocol의 메서드 구현 (find_by_id, find_by_email, save, find_all)
   - ORM 모델 <-> Domain 엔터티 변환 메서드 포함`}
  language="text"
  filename="프롬프트 4: Infrastructure Layer"
/>

### Claude가 생성하는 것

- **`models.py`** -- SQLAlchemy 2.0 스타일 ORM 모델. DB 테이블 구조를 정의
- **`user_repository.py`** -- `UserRepository` Protocol을 만족하는 구현체. ORM 모델과 Domain 엔터티 간 변환 로직 포함

### 여기서 배우는 것

<Callout type="info" title="ORM 모델과 Domain 엔터티의 분리">
  생성된 코드에서 `UserModel`(ORM)과 `User`(Domain)가 **별도 클래스**인 것을 확인하세요. Repository 안에 `_to_domain()` 같은 변환 메서드가 있습니다.

  왜 분리하나요? ORM 모델은 DB 테이블 구조에 종속되지만, Domain 엔터티는 비즈니스 규칙만 표현해야 합니다. 이 분리 덕분에 DB 스키마가 변경되어도 Domain 로직은 영향을 받지 않습니다.
</Callout>

<CodeBlock
  code={`# app/infrastructure/database/models.py
from datetime import datetime

from sqlalchemy import String, DateTime, func
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    mapped_column,
)


class Base(DeclarativeBase):
    pass


class UserModel(Base):
    """SQLAlchemy ORM 모델.

    Domain 엔터티(User)와 별도의 클래스입니다.
    DB 스키마 변경이 Domain 로직에 영향을 주지 않습니다.
    """
    __tablename__ = "users"

    id: Mapped[str] = mapped_column(
        String(36), primary_key=True
    )
    email: Mapped[str] = mapped_column(
        String(255), unique=True, index=True, nullable=False
    )
    name: Mapped[str] = mapped_column(
        String(100), nullable=False
    )
    status: Mapped[str] = mapped_column(
        String(20), nullable=False, default="pending"
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime, server_default=func.now()
    )`}
  language="python"
  filename="app/infrastructure/database/models.py - SQLAlchemy 2.0 ORM 모델"
/>

<CodeBlock
  code={`# app/infrastructure/database/repository.py
from typing import Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.domain.user.entity import User, UserStatus
from app.domain.user.repository import UserRepository
from .models import UserModel


class SQLAlchemyUserRepository:
    """SQLAlchemy 기반 UserRepository 구현체.

    UserRepository Protocol을 만족하지만
    명시적 상속(implements)이 필요하지 않습니다.
    """

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def find_by_id(self, user_id: str) -> Optional[User]:
        stmt = select(UserModel).where(UserModel.id == user_id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return self._to_domain(model) if model else None

    async def find_by_email(self, email: str) -> Optional[User]:
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return self._to_domain(model) if model else None

    async def save(self, user: User) -> None:
        model = UserModel(
            id=user.id,
            email=user.email,
            name=user.name,
            status=user.status.value,
            created_at=user.created_at,
        )
        self._session.add(model)
        await self._session.commit()

    async def find_all(
        self, skip: int = 0, limit: int = 100
    ) -> list[User]:
        stmt = (
            select(UserModel)
            .offset(skip)
            .limit(limit)
            .order_by(UserModel.created_at.desc())
        )
        result = await self._session.execute(stmt)
        models = result.scalars().all()
        return [self._to_domain(m) for m in models]

    @staticmethod
    def _to_domain(model: UserModel) -> User:
        """ORM 모델 -> Domain 엔터티 변환."""
        return User(
            id=model.id,
            email=model.email,
            name=model.name,
            status=UserStatus(model.status),
            created_at=model.created_at,
        )`}
  language="python"
  filename="app/infrastructure/database/repository.py - Repository 구현체"
/>

<Callout type="tip" title="TypeScript 버전과의 차이">
  TypeScript API는 InMemoryRepository(Map 기반)를 사용했고, Python API는 SQLAlchemy + SQLite를 사용합니다. **어느 쪽이든 Domain과 Application Layer의 코드는 동일합니다.** 저장소 구현이 달라도 인터페이스(Protocol)만 지키면 상위 레이어에 영향이 없다는 것을 두 예제로 직접 확인할 수 있습니다.
</Callout>

### Alembic 데이터베이스 마이그레이션

<Callout type="info" title="Alembic으로 스키마 관리">
  프로덕션 환경에서는 SQLAlchemy의 `create_all()`이 아닌 **Alembic 마이그레이션**으로 스키마를 관리합니다. Alembic은 TypeScript 생태계의 Prisma Migrate나 TypeORM Migration에 해당합니다.
</Callout>

<CodeBlock
  code={`# Alembic 초기화 및 마이그레이션 생성
alembic init app/infrastructure/database/migrations

# 마이그레이션 자동 생성
alembic revision --autogenerate -m "create users table"

# 마이그레이션 적용
alembic upgrade head

# 마이그레이션 롤백
alembic downgrade -1`}
  language="bash"
  filename="Alembic CLI 명령어"
/>

---

## 실습 5: Presentation Layer -- FastAPI 라우터와 미들웨어

<CodeBlock
  code={`Presentation Layer를 구현해줘:
1. app/presentation/schemas/user.py
   - Pydantic v2 BaseModel로 CreateUserRequest, UserResponse 정의
   - CreateUserRequest에 EmailStr로 이메일 검증
   - model_config로 JSON 예시 포함
2. app/presentation/api/deps.py
   - FastAPI Depends용 의존성 팩토리 함수들
   - get_db_session, get_user_repository, get_create_user_use_case 등
3. app/presentation/api/users.py
   - APIRouter에 POST /users/ (201), GET /users/{user_id} (200),
     GET /users/ (200, 목록 조회) 등록
   - FastAPI Depends로 UseCase 의존성 주입
4. app/presentation/middleware/error_handler.py
   - 도메인 예외를 HTTPException으로 변환하는 전역 핸들러
5. app/presentation/middleware/request_logger.py
   - 요청/응답 로깅 미들웨어
6. app/main.py
   - FastAPI 앱 생성, lifespan으로 시작 시 테이블 자동 생성
   - 미들웨어 등록, users 라우터 등록`}
  language="text"
  filename="프롬프트 5: Presentation Layer + 앱 조립"
/>

### Claude가 생성하는 것

- **`schemas/user.py`** -- Pydantic v2 모델로 HTTP 요청/응답 스키마 정의. `EmailStr`로 이메일 형식 자동 검증
- **`api/deps.py`** -- FastAPI 의존성 주입을 위한 팩토리 함수들
- **`api/users.py`** -- FastAPI 라우터. `Depends()`로 UseCase를 주입받는 엔드포인트
- **`middleware/error_handler.py`** -- 도메인 예외를 HTTP 에러로 변환
- **`middleware/request_logger.py`** -- 구조화된 요청 로깅
- **`main.py`** -- FastAPI 앱 조립. `lifespan`으로 DB 테이블 자동 생성

### Pydantic v2 스키마

<CodeBlock
  code={`# app/presentation/schemas/user.py
from pydantic import BaseModel, EmailStr, Field


class CreateUserRequest(BaseModel):
    """사용자 생성 요청 스키마.

    Pydantic v2는 JSON Schema를 자동 생성하여
    OpenAPI(Swagger) 문서에 반영합니다.
    """
    email: EmailStr = Field(
        ...,
        description="사용자 이메일",
        examples=["user@example.com"],
    )
    name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="사용자 이름",
        examples=["홍길동"],
    )

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "user@example.com",
                    "name": "홍길동",
                }
            ]
        }
    }


class UserResponse(BaseModel):
    """사용자 응답 스키마."""
    id: str
    email: str
    name: str
    status: str
    created_at: str

    model_config = {"from_attributes": True}


class UserListResponse(BaseModel):
    """사용자 목록 응답 스키마."""
    users: list[UserResponse]
    total: int`}
  language="python"
  filename="app/presentation/schemas/user.py - Pydantic v2 스키마"
/>

### FastAPI 의존성 주입

<CodeBlock
  code={`# app/presentation/api/deps.py
from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import async_session_factory
from app.infrastructure.database.repository import (
    SQLAlchemyUserRepository,
)
from app.application.user.use_cases import (
    CreateUserUseCase,
    GetUserUseCase,
    ListUsersUseCase,
)


async def get_db_session() -> AsyncGenerator[AsyncSession, None]:
    """요청마다 새로운 DB 세션을 생성하고 종료합니다."""
    async with async_session_factory() as session:
        yield session


async def get_user_repository(
    session: AsyncSession = Depends(get_db_session),
) -> SQLAlchemyUserRepository:
    return SQLAlchemyUserRepository(session)


async def get_create_user_use_case(
    repo: SQLAlchemyUserRepository = Depends(get_user_repository),
) -> CreateUserUseCase:
    return CreateUserUseCase(repo)


async def get_get_user_use_case(
    repo: SQLAlchemyUserRepository = Depends(get_user_repository),
) -> GetUserUseCase:
    return GetUserUseCase(repo)


async def get_list_users_use_case(
    repo: SQLAlchemyUserRepository = Depends(get_user_repository),
) -> ListUsersUseCase:
    return ListUsersUseCase(repo)`}
  language="python"
  filename="app/presentation/api/deps.py - 의존성 주입 팩토리"
/>

### 에러 처리 미들웨어

<CodeBlock
  code={`# app/presentation/middleware/error_handler.py
from fastapi import Request, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import (
    BaseHTTPMiddleware,
    RequestResponseEndpoint,
)

from app.domain.user.exceptions import (
    DomainError,
    DuplicateEmailError,
    InvalidEmailError,
    InvalidStateTransitionError,
    UserNotFoundError,
)

# 도메인 예외 -> HTTP 상태 코드 매핑
_ERROR_STATUS_MAP: dict[type[DomainError], int] = {
    InvalidEmailError: status.HTTP_400_BAD_REQUEST,
    DuplicateEmailError: status.HTTP_409_CONFLICT,
    UserNotFoundError: status.HTTP_404_NOT_FOUND,
    InvalidStateTransitionError: status.HTTP_422_UNPROCESSABLE_ENTITY,
}


class ErrorHandlerMiddleware(BaseHTTPMiddleware):
    """도메인 예외를 HTTP 응답으로 변환하는 미들웨어.

    Domain Layer의 예외가 Presentation Layer의
    HTTP 상태 코드에 직접 의존하지 않도록 합니다.
    """

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ):
        try:
            return await call_next(request)
        except DomainError as exc:
            status_code = _ERROR_STATUS_MAP.get(
                type(exc),
                status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
            return JSONResponse(
                status_code=status_code,
                content={
                    "error": exc.code,
                    "message": exc.message,
                },
            )`}
  language="python"
  filename="app/presentation/middleware/error_handler.py - 전역 예외 핸들러"
/>

<Callout type="info" title="FastAPI Depends vs Express 수동 조립">
  TypeScript에서는 `app.ts`에서 직접 `new Repository()` -> `new UseCase(repo)` -> `new Controller(useCase)`로 조립했습니다.

  Python(FastAPI)에서는 **`Depends()` 함수**가 이를 대신합니다. 팩토리 함수를 정의하면 FastAPI가 요청마다 자동으로 의존성을 생성하고 주입합니다. 프레임워크가 DI 컨테이너 역할을 하는 셈입니다.

  방식은 다르지만, **"UseCase는 인터페이스에만 의존한다"**는 원칙은 동일합니다.
</Callout>

<Callout type="tip" title="이중 검증의 의미">
  Pydantic의 `EmailStr`이 이미 이메일을 검증하는데, 왜 Domain에서도 정규식으로 검증하나요? Presentation Layer의 검증은 "HTTP 입력이 올바른가"를 확인하고, Domain의 검증은 "비즈니스 규칙에 맞는가"를 확인합니다. API가 아닌 다른 진입점(CLI, 배치 등)에서도 Domain 검증이 작동해야 하기 때문입니다.
</Callout>

### FastAPI 앱 조립

<CodeBlock
  code={`# app/main.py
from contextlib import asynccontextmanager

from fastapi import FastAPI

from app.core.config import settings
from app.core.database import engine
from app.infrastructure.database.models import Base
from app.presentation.api.users import router as users_router
from app.presentation.middleware.error_handler import (
    ErrorHandlerMiddleware,
)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """앱 시작/종료 시 실행되는 lifecycle 함수."""
    # 시작: 테이블 자동 생성 (개발 환경)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # 종료: 엔진 정리
    await engine.dispose()


app = FastAPI(
    title=settings.app_name,
    lifespan=lifespan,
    docs_url="/docs",       # Swagger UI
    redoc_url="/redoc",     # ReDoc
)

# 미들웨어 등록
app.add_middleware(ErrorHandlerMiddleware)

# 라우터 등록
app.include_router(
    users_router,
    prefix=f"{settings.api_prefix}/users",
    tags=["Users"],
)`}
  language="python"
  filename="app/main.py - FastAPI 앱 엔트리포인트"
/>

### 비동기 처리 패턴

<Callout type="info" title="async/await와 BackgroundTasks">
  FastAPI는 Python의 `async/await`를 네이티브로 지원합니다. SQLAlchemy 2.0의 `AsyncSession`과 결합하면 **비동기 I/O 기반의 고성능 API**를 구현할 수 있습니다.

  메일 발송 같은 비동기 후처리는 `BackgroundTasks`를 활용합니다:
</Callout>

<CodeBlock
  code={`# BackgroundTasks 활용 예시
from fastapi import BackgroundTasks


async def send_welcome_email(email: str, name: str) -> None:
    """환영 이메일 발송 (비동기 백그라운드)."""
    # 실제로는 이메일 서비스 호출
    print(f"Sending welcome email to {email}")


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_user(
    request: CreateUserRequest,
    background_tasks: BackgroundTasks,
    use_case: CreateUserUseCase = Depends(
        get_create_user_use_case
    ),
) -> UserResponse:
    result = await use_case.execute(
        CreateUserDto(email=request.email, name=request.name)
    )
    # 응답 후 백그라운드에서 이메일 발송
    background_tasks.add_task(
        send_welcome_email, result.email, result.name
    )
    return UserResponse(**result.__dict__)`}
  language="python"
  filename="BackgroundTasks를 활용한 비동기 후처리"
/>

### API 문서화 (OpenAPI)

<Callout type="info" title="FastAPI의 자동 API 문서화">
  FastAPI는 Pydantic 스키마에서 **OpenAPI 문서를 자동 생성**합니다. 별도의 Swagger 설정 없이 `/docs`(Swagger UI)와 `/redoc`(ReDoc)에 접속하면 인터랙티브 API 문서를 확인할 수 있습니다.

  TypeScript(Express)에서는 `swagger-jsdoc` + `swagger-ui-express`를 별도로 설정해야 했지만, FastAPI는 프레임워크 자체에 내장되어 있습니다.
</Callout>

---

## 실습 6: 테스트 전략

<CodeBlock
  code={`다음 테스트를 작성하고 실행해줘:

1. tests/factories.py: 테스트 팩토리 함수
   - create_test_user() 헬퍼 (기본값으로 유효한 User 생성)

2. tests/test_user_entity.py: User 엔터티 단위 테스트
   - 정상 생성, 이메일 소문자 변환, 잘못된 이메일 거부
   - 상태 전이: pending->active, active->inactive
   - 잘못된 상태 전이 시 InvalidStateTransitionError

3. tests/test_create_user.py: CreateUserUseCase 단위 테스트
   - AsyncMock으로 Repository mock
   - 정상 생성, 이메일 중복, 잘못된 이메일, 소문자 변환

4. tests/test_api_integration.py: API 통합 테스트
   - httpx AsyncClient로 실제 HTTP 요청 테스트
   - POST /api/users -> 201, GET /api/users/{id} -> 200
   - 중복 이메일 -> 409, 존재하지 않는 ID -> 404

5. tests/conftest.py: pytest 픽스처
   - 인메모리 SQLite 세션 (테스트마다 테이블 생성/삭제)
   - httpx AsyncClient 픽스처

pytest-asyncio를 사용하고, 테스트 실행까지 해줘.`}
  language="text"
  filename="프롬프트 6: 테스트 전략"
/>

### Claude가 생성하는 것

- **`factories.py`** -- 테스트 데이터를 쉽게 생성하는 팩토리 함수
- **`test_user_entity.py`** -- 엔터티 단위 테스트 (pytest.raises로 예외 검증)
- **`test_create_user.py`** -- UseCase 단위 테스트 (`AsyncMock`으로 Repository mock)
- **`test_api_integration.py`** -- httpx로 실제 HTTP 요청을 보내는 통합 테스트
- **`conftest.py`** -- pytest 픽스처 (인메모리 SQLite, httpx 클라이언트)
- 모든 테스트 실행 결과

### 테스트 픽스처

<CodeBlock
  code={`# tests/conftest.py
import pytest
import pytest_asyncio
from httpx import ASGITransport, AsyncClient
from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)

from app.infrastructure.database.models import Base
from app.main import app
from app.presentation.api.deps import get_db_session


# 테스트 전용 인메모리 SQLite 엔진
test_engine = create_async_engine(
    "sqlite+aiosqlite:///:memory:",
    echo=False,
)
TestSessionFactory = async_sessionmaker(
    test_engine, class_=AsyncSession, expire_on_commit=False
)


@pytest_asyncio.fixture
async def db_session():
    """테스트마다 테이블을 생성하고 삭제합니다."""
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    async with TestSessionFactory() as session:
        yield session

    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest_asyncio.fixture
async def client(db_session: AsyncSession):
    """httpx AsyncClient 픽스처.

    FastAPI의 의존성을 테스트 세션으로 오버라이드합니다.
    """
    async def override_get_db():
        yield db_session

    app.dependency_overrides[get_db_session] = override_get_db
    transport = ASGITransport(app=app)

    async with AsyncClient(
        transport=transport,
        base_url="http://test",
    ) as ac:
        yield ac

    app.dependency_overrides.clear()`}
  language="python"
  filename="tests/conftest.py - pytest 픽스처"
/>

### 팩토리 함수

<CodeBlock
  code={`# tests/factories.py
from app.domain.user.entity import User


def create_test_user(
    email: str = "test@example.com",
    name: str = "Test User",
) -> User:
    """테스트용 User 엔터티를 생성합니다.

    기본값이 유효한 데이터이므로,
    특정 필드만 오버라이드하여 사용할 수 있습니다.
    """
    return User.create(email=email, name=name)


def create_test_user_data(
    email: str = "test@example.com",
    name: str = "Test User",
) -> dict:
    """API 요청용 JSON 데이터를 반환합니다."""
    return {"email": email, "name": name}`}
  language="python"
  filename="tests/factories.py - 테스트 팩토리"
/>

### 단위 테스트: 엔터티

<CodeBlock
  code={`# tests/test_user_entity.py
import pytest

from app.domain.user.entity import User, UserStatus
from app.domain.user.exceptions import (
    InvalidEmailError,
    InvalidStateTransitionError,
)


class TestUserCreate:
    def test_create_valid_user(self):
        user = User.create(
            email="test@example.com", name="Test"
        )
        assert user.email == "test@example.com"
        assert user.name == "Test"
        assert user.status == UserStatus.PENDING

    def test_email_lowercased(self):
        user = User.create(
            email="TEST@EXAMPLE.COM", name="Test"
        )
        assert user.email == "test@example.com"

    def test_invalid_email_rejected(self):
        with pytest.raises(InvalidEmailError):
            User.create(email="not-an-email", name="Test")

    def test_empty_name_rejected(self):
        with pytest.raises(ValueError):
            User.create(email="test@example.com", name="")


class TestUserStateTransition:
    def test_activate_from_pending(self):
        user = User.create(
            email="test@example.com", name="Test"
        )
        user.activate()
        assert user.status == UserStatus.ACTIVE

    def test_deactivate_from_active(self):
        user = User.create(
            email="test@example.com", name="Test"
        )
        user.activate()
        user.deactivate()
        assert user.status == UserStatus.INACTIVE

    def test_cannot_activate_from_active(self):
        user = User.create(
            email="test@example.com", name="Test"
        )
        user.activate()
        with pytest.raises(InvalidStateTransitionError):
            user.activate()

    def test_cannot_deactivate_from_pending(self):
        user = User.create(
            email="test@example.com", name="Test"
        )
        with pytest.raises(InvalidStateTransitionError):
            user.deactivate()`}
  language="python"
  filename="tests/test_user_entity.py - 엔터티 단위 테스트"
/>

### 단위 테스트: 유스케이스

<CodeBlock
  code={`# tests/test_create_user.py
from unittest.mock import AsyncMock

import pytest

from app.application.user.dtos import CreateUserDto
from app.application.user.use_cases import CreateUserUseCase
from app.domain.user.exceptions import (
    DuplicateEmailError,
    InvalidEmailError,
)


@pytest.fixture
def mock_repo():
    """AsyncMock으로 Repository를 모킹합니다."""
    repo = AsyncMock()
    repo.find_by_email.return_value = None
    repo.save.return_value = None
    return repo


@pytest.fixture
def use_case(mock_repo):
    return CreateUserUseCase(mock_repo)


class TestCreateUserUseCase:
    @pytest.mark.asyncio
    async def test_create_success(self, use_case, mock_repo):
        dto = CreateUserDto(
            email="new@example.com", name="New User"
        )
        result = await use_case.execute(dto)

        assert result.email == "new@example.com"
        assert result.name == "New User"
        assert result.status == "pending"
        mock_repo.save.assert_called_once()

    @pytest.mark.asyncio
    async def test_duplicate_email(self, use_case, mock_repo):
        from tests.factories import create_test_user

        mock_repo.find_by_email.return_value = (
            create_test_user(email="dup@example.com")
        )

        with pytest.raises(DuplicateEmailError):
            await use_case.execute(
                CreateUserDto(
                    email="dup@example.com", name="Dup"
                )
            )

    @pytest.mark.asyncio
    async def test_invalid_email(self, use_case):
        with pytest.raises(InvalidEmailError):
            await use_case.execute(
                CreateUserDto(
                    email="invalid", name="Test"
                )
            )

    @pytest.mark.asyncio
    async def test_email_lowercased(
        self, use_case, mock_repo
    ):
        result = await use_case.execute(
            CreateUserDto(
                email="UPPER@EXAMPLE.COM", name="Test"
            )
        )
        assert result.email == "upper@example.com"`}
  language="python"
  filename="tests/test_create_user.py - UseCase 단위 테스트"
/>

### 통합 테스트

<CodeBlock
  code={`# tests/test_api_integration.py
import pytest
from httpx import AsyncClient


@pytest.mark.asyncio
class TestUserAPI:
    async def test_create_user(self, client: AsyncClient):
        response = await client.post(
            "/api/users/",
            json={
                "email": "test@example.com",
                "name": "Test User",
            },
        )
        assert response.status_code == 201
        data = response.json()
        assert data["email"] == "test@example.com"
        assert data["status"] == "pending"

    async def test_get_user(self, client: AsyncClient):
        # 먼저 사용자 생성
        create_resp = await client.post(
            "/api/users/",
            json={
                "email": "get@example.com",
                "name": "Get User",
            },
        )
        user_id = create_resp.json()["id"]

        # 생성한 사용자 조회
        get_resp = await client.get(
            f"/api/users/{user_id}"
        )
        assert get_resp.status_code == 200
        assert get_resp.json()["id"] == user_id

    async def test_duplicate_email_returns_409(
        self, client: AsyncClient
    ):
        await client.post(
            "/api/users/",
            json={
                "email": "dup@example.com",
                "name": "First",
            },
        )
        response = await client.post(
            "/api/users/",
            json={
                "email": "dup@example.com",
                "name": "Second",
            },
        )
        assert response.status_code == 409

    async def test_not_found_returns_404(
        self, client: AsyncClient
    ):
        response = await client.get(
            "/api/users/nonexistent-id"
        )
        assert response.status_code == 404`}
  language="python"
  filename="tests/test_api_integration.py - API 통합 테스트"
/>

### 여기서 배우는 것

<Callout type="info" title="Python Mock vs TypeScript Mock">
  - TypeScript: `jest.Mocked<IUserRepository>` -- `jest.fn()`으로 각 메서드를 직접 모킹
  - Python: `AsyncMock()` -- `unittest.mock`의 비동기 모킹. `return_value`와 `assert_called_once()`로 검증

  문법은 다르지만 **패턴은 동일**합니다: 인터페이스를 만족하는 가짜 객체를 만들어 주입하고, 호출 여부를 검증합니다.
</Callout>

<Callout type="tip" title="conftest.py의 역할">
  생성된 `conftest.py`를 보면, 매 테스트마다 **인메모리 SQLite 테이블을 생성하고 삭제**합니다. 이 덕분에 테스트 간 데이터 오염 없이 격리된 환경에서 실행됩니다. TypeScript의 `beforeEach`에서 `jest.fn()`을 초기화하는 것과 같은 목적입니다.
</Callout>

<Callout type="info" title="테스트 피라미드">
  이 프로젝트의 테스트는 세 단계로 구성됩니다:

  1. **엔터티 단위 테스트** (가장 빠름): 외부 의존성 없이 순수 비즈니스 로직만 검증
  2. **UseCase 단위 테스트** (빠름): AsyncMock으로 Repository를 대체하여 흐름 검증
  3. **API 통합 테스트** (느림): httpx로 실제 HTTP 요청을 보내 전체 파이프라인 검증

  하위 레이어 테스트가 많고, 상위 레이어 테스트는 핵심 시나리오만 검증하는 것이 **테스트 피라미드** 전략입니다.
</Callout>

---

## Docker 컨테이너화

<CodeBlock
  code={`# Dockerfile
FROM python:3.12-slim AS base

WORKDIR /app

# 의존성 설치 (캐시 활용을 위해 requirements만 먼저 복사)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 소스 코드 복사
COPY . .

# 프로덕션 실행
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]`}
  language="dockerfile"
  filename="Dockerfile - 컨테이너 이미지 빌드"
/>

<CodeBlock
  code={`# docker-compose.yml
services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite+aiosqlite:///./data/app.db
      - DEBUG=false
    volumes:
      - app-data:/app/data

  # 프로덕션 환경에서는 PostgreSQL 사용
  # db:
  #   image: postgres:16-alpine
  #   environment:
  #     POSTGRES_DB: cleanapi
  #     POSTGRES_USER: app
  #     POSTGRES_PASSWORD_FILE: /run/secrets/db_password
  #   volumes:
  #     - pgdata:/var/lib/postgresql/data

volumes:
  app-data:`}
  language="yaml"
  filename="docker-compose.yml - 컨테이너 오케스트레이션"
/>

<Callout type="tip" title="Docker 빌드 최적화">
  `requirements.txt`를 소스 코드보다 먼저 복사하는 이유는 **Docker 레이어 캐싱** 때문입니다. 의존성이 변경되지 않으면 `pip install` 단계를 건너뛰어 빌드 시간이 크게 단축됩니다. TypeScript 프로젝트에서 `package.json`과 `package-lock.json`을 먼저 복사하는 것과 같은 원리입니다.
</Callout>

---

## CI/CD 파이프라인

<CodeBlock
  code={`# .github/workflows/ci.yml
name: Python API CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Lint (ruff)
        run: ruff check .

      - name: Type check (mypy)
        run: mypy app/

      - name: Run tests
        run: pytest --cov=app --cov-report=xml -v

      - name: Upload coverage
        uses: codecov/codecov-action@v5
        with:
          file: coverage.xml`}
  language="yaml"
  filename=".github/workflows/ci.yml - GitHub Actions CI"
/>

<Callout type="info" title="CI에서의 품질 게이트">
  CI 파이프라인은 세 가지 품질 게이트를 통과해야 합니다:

  1. **ruff**: Python 린터. ESLint에 해당하며, PEP 8 준수와 코드 스타일을 검사합니다
  2. **mypy**: 정적 타입 검사기. TypeScript의 `tsc --noEmit`에 해당합니다
  3. **pytest**: 테스트 실행 + 커버리지 측정. Jest의 `--coverage`에 해당합니다
</Callout>

---

## TypeScript API vs Python API 비교

<ComparisonTable
  title="TS API vs Python API 구현 비교"
  headers={['항목', 'TypeScript', 'Python']}
  rows={[
    { feature: '프레임워크', values: ['Express.js', 'FastAPI'] },
    { feature: '저장소', values: ['InMemoryRepository (Map)', 'SQLAlchemy + SQLite'] },
    { feature: '테스트', values: ['Jest + jest.Mocked', 'pytest + AsyncMock'] },
    { feature: '인터페이스', values: ['interface (명시적 implements)', 'Protocol (구조적, duck typing)'] },
    { feature: '비동기', values: ['async/await', 'async/await'] },
    { feature: '타입 시스템', values: ['정적 (컴파일 타임)', '동적 (런타임 힌트 + mypy)'] },
    { feature: '데이터 클래스', values: ['class (private constructor)', '@dataclass'] },
    { feature: '의존성 주입', values: ['생성자 주입 (수동 조립)', 'FastAPI Depends (프레임워크 DI)'] },
    { feature: '입력 검증', values: ['값 객체 (Email class)', 'Pydantic v2 + 엔터티 검증'] },
    { feature: '네이밍', values: ['camelCase', 'snake_case'] },
    { feature: 'API 문서', values: ['swagger-jsdoc (수동 설정)', 'FastAPI 내장 (자동 생성)'] },
    { feature: '린트', values: ['ESLint', 'ruff'] },
    { feature: '타입 검사', values: ['tsc --noEmit', 'mypy'] },
    { feature: '에러 처리', values: ['Express 미들웨어', '도메인 예외 -> HTTP 매핑 미들웨어'] },
    { feature: 'DB 마이그레이션', values: ['Prisma Migrate / TypeORM', 'Alembic'] },
  ]}
/>

### 아키텍처 비교 다이어그램

<MermaidDiagram
  chart={`flowchart LR
    subgraph TypeScript["TypeScript API"]
        direction TB
        TS_P["Presentation\n(Express Controller)"]
        TS_A["Application\n(UseCase class)"]
        TS_D["Domain\n(class + interface)"]
        TS_I["Infrastructure\n(InMemory Map)"]
        TS_P --> TS_A --> TS_D
        TS_I --> TS_D
    end

    subgraph Python["Python API"]
        direction TB
        PY_P["Presentation\n(FastAPI Router)"]
        PY_A["Application\n(UseCase class)"]
        PY_D["Domain\n(dataclass + Protocol)"]
        PY_I["Infrastructure\n(SQLAlchemy)"]
        PY_P --> PY_A --> PY_D
        PY_I --> PY_D
    end

    TypeScript ~~~ Python

    style TS_D fill:#fdf2ee,stroke:#da7756,color:#2d2a26
    style PY_D fill:#fdf2ee,stroke:#da7756,color:#2d2a26`}
  title="TypeScript vs Python 아키텍처 비교"
  caption="언어와 프레임워크는 다르지만, 레이어 구조와 의존성 방향은 동일합니다"
/>

<Callout type="info" title="언어가 달라도 아키텍처는 같다">
  두 예제에서 확인할 수 있는 공통점:
  - **Domain Layer**가 인터페이스(Protocol/interface)를 정의하고, Infrastructure Layer가 구현
  - **Application Layer**는 인터페이스에만 의존하여, 저장소가 Map이든 SQLite든 상관없음
  - **Presentation Layer**는 프레임워크(Express/FastAPI)에 특화된 변환만 담당

  프레임워크와 DB는 **세부사항(detail)**이며, 비즈니스 로직과 분리됩니다. 이것이 Clean Architecture의 핵심 가치입니다.
</Callout>

---

## 정리: 레이어별 역할과 규칙

<ComparisonTable
  title="Clean Architecture 레이어별 역할 (Python)"
  headers={['레이어', '역할', '의존 대상', '테스트 방법']}
  rows={[
    { feature: 'Domain', values: ['엔터티, Protocol, 비즈니스 규칙', '없음 (순수 Python)', '단위 테스트 (mock 불필요)'] },
    { feature: 'Application', values: ['유스케이스, 흐름 조율', 'Domain Protocol', '단위 테스트 (AsyncMock)'] },
    { feature: 'Infrastructure', values: ['SQLAlchemy Repository', 'Domain Protocol', '통합 테스트 (인메모리 SQLite)'] },
    { feature: 'Presentation', values: ['FastAPI Router, Pydantic', 'Application UseCase', '통합 테스트 (httpx)'] },
  ]}
/>

<Callout type="tip" title="이 실습에서 가장 중요한 한 가지">
  6개 실습을 통해 만든 코드에서 **저장소를 SQLite에서 PostgreSQL로 교체한다고 상상해보세요.** 바꿔야 하는 것은 `app/core/config.py`의 `DATABASE_URL`과 `requirements.txt`에 `asyncpg` 추가뿐입니다. Domain, Application, Presentation Layer는 전혀 건드리지 않습니다. Alembic 마이그레이션만 새로 생성하면 됩니다. 이것이 Clean Architecture와 의존성 역전이 주는 실질적 가치입니다.
</Callout>

<Callout type="info" title="다음 단계: 프론트엔드 프로젝트">
  이 Python API를 백엔드로 사용하는 프론트엔드 프로젝트를 다음 챕터에서 구현합니다. TypeScript API와 Python API 중 어느 것을 백엔드로 사용하든, 프론트엔드의 HTTP 호출 코드는 동일합니다. 이것이 **API 계약(OpenAPI 스키마)**으로 소통하는 이유입니다.
</Callout>


<ChapterNav
  prev={{ title: 'TypeScript API', path: '/docs/part-5--실전-예제-typescript-api' }}
  next={{ title: '프론트엔드 프로젝트', path: '/docs/part-5--실전-예제-프론트엔드-프로젝트' }}
/>
